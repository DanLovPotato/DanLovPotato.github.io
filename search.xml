<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Image Process</title>
      <link href="/2023/09/21/ImageProcess/classNote/"/>
      <url>/2023/09/21/ImageProcess/classNote/</url>
      
        <content type="html"><![CDATA[<h2 id="Gaussian-smoothing"><a href="#Gaussian-smoothing" class="headerlink" title="Gaussian smoothing"></a>Gaussian smoothing</h2><p><a href="https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm#:~:text=The%20effect%20of%20Gaussian%20smoothing,order%20to%20be%20accurately%20represented">https://homepages.inf.ed.ac.uk/rbf/HIPR2/gsmooth.htm#:~:text=The%20effect%20of%20Gaussian%20smoothing,order%20to%20be%20accurately%20represented</a>.)</p><p>The idea of Gaussian smoothing is to use 2-D Gaussian distribution as a &#96;point-spread’ function, and this is achieved by convolution.</p><h2 id="High-x2F-Low-pass-filter-Fourier-transform"><a href="#High-x2F-Low-pass-filter-Fourier-transform" class="headerlink" title="High&#x2F;Low pass filter, Fourier transform"></a>High&#x2F;Low pass filter, Fourier transform</h2><p><a href="https://www.cnblogs.com/wj-1314/p/11983496.html#:~:text=%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%AF%E4%BB%A5,%E5%A2%9E%E5%BC%BA%E5%92%8C%E9%94%90%E5%8C%96%E7%AD%89%E3%80%82">https://www.cnblogs.com/wj-1314/p/11983496.html#:~:text=%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%8F%AF%E4%BB%A5,%E5%A2%9E%E5%BC%BA%E5%92%8C%E9%94%90%E5%8C%96%E7%AD%89%E3%80%82</a></p><p><strong>傅里叶变换的作用</strong>：</p><p>傅里叶变换（Fourier Transform，简称FT）常用于数字信号处理，它的目的是将时间域上的信号转变为频率域上的信号。</p><p>　　对于数字图像这种离散的信号，频率大小表示信号变换的剧烈程度或者说信号变化的快慢。频率越大，变换越剧烈，频率越小，信号越平缓，对应到的图像中，高频信号往往是图像中的边缘信号和噪声信号，而低频信号包含图像变化频繁的图像轮廓及背景灯信号。</p><p>　　需要说明的是：傅里叶变换得到的频谱图上的点与原图像上的点之间不存在一一对应的关系。</p><ul><li>高频：变换剧烈的灰度分量，例如边界</li><li>低频：变换缓慢的灰度分量，例如一片大海</li></ul><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> Image Process </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BackTracking</title>
      <link href="/2023/08/17/LeetCode/BackTracking/"/>
      <url>/2023/08/17/LeetCode/BackTracking/</url>
      
        <content type="html"><![CDATA[<h1 id="Back-Tracking🌼"><a href="#Back-Tracking🌼" class="headerlink" title="Back Tracking🌼"></a>Back Tracking🌼</h1><p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html">二叉树：以为使用了递归，其实还隐藏着回溯</a>。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><h3 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h3><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><h3 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给出Carl总结的回溯算法模板。</p><p>在讲<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归</a>中我们说了递归三部曲，这里我再给大家列出回溯三部曲。</p><ul><li>回溯函数模板返回值以及参数</li></ul><p>在回溯算法中，我的习惯是函数起名字为backtracking</p><p>回溯算法中函数返回值一般为void。</p><p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p><p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p><p>回溯函数伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></table></figure><ul><li>回溯函数终止条件</li></ul><p>既然是树形结构，那么我们在讲解<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归</a>的时候，就知道遍历树形结构一定要有终止条件。</p><p>所以回溯也有要终止条件。</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回溯搜索的遍历过程</li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><a href="https://camo.githubusercontent.com/7f6cf608866ba0994390df40f15f870691429cab9d6a9872cd0ce572f012ae39/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303133303137333633313137342e706e67"><img src="https://camo.githubusercontent.com/7f6cf608866ba0994390df40f15f870691429cab9d6a9872cd0ce572f012ae39/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303133303137333633313137342e706e67" alt="回溯算法理论基础"></a></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); // 递归</span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p>分析完过程，回溯算法模板框架如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p><p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p><p>Generally, every <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">constraint satisfaction problem</a> which has clear and well-defined constraints on any objective solution, that incrementally builds candidate to the solution and abandons a candidate (“backtracks”) as soon as it determines that the candidate cannot possibly be completed to a valid solution, can be solved by Backtracking. However, most of the problems that are discussed, can be solved using other known algorithms like <em>Dynamic Programming</em> or <em>Greedy Algorithms</em> in logarithmic, linear, linear-logarithmic time complexity in order of input size, and therefore, outshine the backtracking algorithm in every respect (since backtracking algorithms are generally exponential in both time and space). However, a few problems still remain, that only have backtracking algorithms to solve them until now. </p><h3 id="linkedList-VS-ArrayList"><a href="#linkedList-VS-ArrayList" class="headerlink" title="linkedList VS. ArrayList"></a>linkedList VS. ArrayList</h3><p><a href="https://www.geeksforgeeks.org/arraylist-vs-linkedlist-java/">https://www.geeksforgeeks.org/arraylist-vs-linkedlist-java/</a></p><p>ArrayList provides constant time for search operation, so it is better to use ArrayList if searching is more frequent operation than add and remove operation. </p><p>The LinkedList provides constant time for add and remove operations. So it is better to use LinkedList for manipulation.</p><p><strong>LinkedList:</strong></p><ol><li>Adding Elements:<ul><li><code>addFirst(element)</code>: Adds an element to the beginning of the list.</li><li><code>addLast(element)</code>: Adds an element to the end of the list.</li><li><code>add(index, element)</code>: Adds an element at the specified index.</li></ul></li><li>Removing Elements:<ul><li><code>removeFirst()</code>: Removes and returns the first element.</li><li><code>removeLast()</code>: Removes and returns the last element.</li><li><code>remove(index)</code>: Removes the element at the specified index.</li></ul></li><li>Accessing Elements:<ul><li><code>get(index)</code>: Retrieves the element at the specified index.</li><li>linkedList.set(i, newValue);</li></ul></li><li>Iterating:<ul><li>Iterating through elements using an iterator or enhanced for loop.</li></ul></li><li>Size:<ul><li><code>size()</code>: Returns the number of elements in the list.</li></ul></li></ol><p><strong>ArrayList:</strong></p><ol><li>Adding Elements:<ul><li><code>add(element)</code>: Adds an element to the end of the list.</li><li><code>add(index, element)</code>: Adds an element at the specified index.</li></ul></li><li>Removing Elements:<ul><li><code>remove(index)</code>: Removes the element at the specified index.</li><li><code>removeRange(fromIndex, toIndex)</code>: Removes elements within the specified range.</li></ul></li><li>Accessing Elements:<ul><li><code>get(index)</code>: Retrieves the element at the specified index.</li><li><code>set(index, element)</code>: Replaces the element at the specified index.</li></ul></li><li>Iterating:<ul><li>Iterating through elements using an iterator or enhanced for loop.</li></ul></li><li>Size:<ul><li><code>size()</code>: Returns the number of elements in the list.</li></ul></li></ol><p><strong>ArrayList Specific:</strong></p><ol><li>Dynamic Sizing:<ul><li>The underlying array dynamically grows as elements are added, reducing the need for manual resizing.</li></ul></li><li>Random Access:<ul><li>Provides fast O(1) random access to elements by index.</li></ul></li><li>Insertion&#x2F;Deletion Trade-Off:<ul><li>Insertions and deletions at the beginning&#x2F;middle of the list are slower (O(n)) due to shifting elements.</li></ul></li></ol><p><strong>LinkedList Specific:</strong></p><ol><li>Insertion&#x2F;Deletion:<ul><li>Offers fast O(1) insertion and deletion at the beginning and end of the list.</li><li>Mid-list insertions&#x2F;deletions are slower (O(n)) due to traversal.</li></ul></li><li>Memory Overhead:<ul><li>Uses more memory due to storing both elements and references&#x2F;pointers.</li></ul></li><li>No Random Access:<ul><li>Accessing elements by index is slower (O(n)) since traversal is required.</li></ul></li></ol><p>Both <code>LinkedList</code> and <code>ArrayList</code> provide similar APIs for common operations like adding, removing, accessing, and iterating through elements. The choice between them depends on your specific use case and the operations you’ll perform most frequently.</p><h3 id="77-Combinations-排列问题"><a href="#77-Combinations-排列问题" class="headerlink" title="77. Combinations  排列问题"></a><a href="https://leetcode.com/problems/combinations/">77. Combinations</a>  排列问题</h3><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span><br><span class="line">Explanation: There are 4 choose 2 = 6 total combinations.</span><br><span class="line">Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;  </span><br><span class="line">        seek(n,k,1);</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     public void seek(int n, int k, int start) &#123;</span><br><span class="line">         if(path.size() == k )&#123;</span><br><span class="line">             res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         for(int i = start; i &lt;= n; i++)&#123;</span><br><span class="line">             path.add(i); //like put in the element 1</span><br><span class="line">             seek(n,k, i+1); // recursive like 从1以后的元素遍历，加进去</span><br><span class="line">             path.removeLast();  // backtrack 比如说加了1，2 进去然后把2退出来，再加3进去成为1，3</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回溯函数终止条件</li></ul><p>什么时候到达所谓的叶子节点了呢？</p><p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p><p>如图红色部分：</p><p><a href="https://camo.githubusercontent.com/63f4077f082ba18f134e3e9eeb083409b6729204a6439f7a1cd7dcd281cf57ea/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353430373930372e706e67"><img src="https://camo.githubusercontent.com/63f4077f082ba18f134e3e9eeb083409b6729204a6439f7a1cd7dcd281cf57ea/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353430373930372e706e67" alt="77.组合3"></a></p><p>此时用result二维数组，把path保存起来，并终止本层递归。</p><p>所以终止条件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (path.size() == k) &#123;</span><br><span class="line">    result.push_back(path);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单层搜索的过程</li></ul><p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p><p><a href="https://camo.githubusercontent.com/f8b8bec488f2b60d3c81d96391f3c6adce3dba237005a3e9f0a512a0d18aac11/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67"><img src="https://camo.githubusercontent.com/f8b8bec488f2b60d3c81d96391f3c6adce3dba237005a3e9f0a512a0d18aac11/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67" alt="77.组合1"></a></p><p>如此我们才遍历完图中的这棵树。</p><p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = startIndex; i &lt;= n; i++) &#123; // 控制树的横向遍历</span><br><span class="line">    path.push_back(i); // 处理节点</span><br><span class="line">    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br><span class="line">    path.pop_back(); // 回溯，撤销处理的节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p><p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p><h3 id="77-Combinations-减枝pruning"><a href="#77-Combinations-减枝pruning" class="headerlink" title="77. Combinations  减枝pruning"></a><a href="https://leetcode.com/problems/combinations/">77. Combinations</a>  减枝pruning</h3><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.md</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void combineHelper(int n, int k, int startIndex)&#123;</span><br><span class="line">    //终止条件</span><br><span class="line">    if (path.size() == k)&#123;</span><br><span class="line">        result.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++)&#123;  //!!!!!!!</span><br><span class="line">        path.add(i);</span><br><span class="line">        combineHelper(n, k, i + 1);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>path.size() ： 已经找的个数<br>k-path.size() ：还需找的个数<br>【x, n】的数组长度起码应该是k-path.size()才有继续搜索的可能， 那么就有 n-x+1 &#x3D; k-path.size()  ， 解方程得 x &#x3D; n+1 - (k-path.size()), 而且这个x是可以作为起点往下搜的 也就是for(i &#x3D; s; i&lt;&#x3D;x; i++) 这里的x是可以取到的</p><h3 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a href="https://leetcode.com/problems/combination-sum-iii/">216. Combination Sum III</a></h3><p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p><ul><li>Only numbers <code>1</code> through <code>9</code> are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        seek(k, n , 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int k, int n, int start)&#123;</span><br><span class="line">        if(path.size() == k)&#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for(int element: path)&#123;</span><br><span class="line">                sum += element;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum == n)&#123;</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt;= 9; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            seek(k,n, i+1);  // notice it&#x27;s i+1 here not start +1</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// pruning!!! better version</span><br><span class="line"></span><br><span class="line">private void backTracking(int targetSum, int k, int startIndex, int sum) &#123;</span><br><span class="line">// 减枝</span><br><span class="line">if (sum &gt; targetSum) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (path.size() == k) &#123;</span><br><span class="line">if (sum == targetSum) result.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 减枝 9 - (k - path.size()) + 1</span><br><span class="line">for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123;</span><br><span class="line">path.add(i);</span><br><span class="line">sum += i;</span><br><span class="line">backTracking(targetSum, k, i + 1, sum);</span><br><span class="line">//回溯</span><br><span class="line">path.removeLast();</span><br><span class="line">//回溯</span><br><span class="line">sum -= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h3><p>Medium</p><p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; res = new ArrayList&lt;String&gt;();</span><br><span class="line">    public StringBuilder temp = new StringBuilder();</span><br><span class="line">    public String[] dict = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if( digits.isEmpty()) return res;</span><br><span class="line">        /*</span><br><span class="line">        notice:</span><br><span class="line">        not return null</span><br><span class="line">        not digits == null</span><br><span class="line">        */</span><br><span class="line">        seek(digits, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(String digits, int num)&#123; // num stands for which digit we are processing 遍历到哪一个数字了</span><br><span class="line">        </span><br><span class="line">        int len = digits.length();</span><br><span class="line">        if(len == num)&#123;</span><br><span class="line">        // you can also say-&gt; if(len == temp.length())&#123;</span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int digit = digits.charAt(num) - &#x27;0&#x27;;</span><br><span class="line">        String str = dict[digit]; // current digit&#x27;s letters </span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            seek(digits, num+1); // append next num&#x27;s letter</span><br><span class="line">            temp.deleteCharAt(temp.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些写法，是把回溯的过程放在递归函数里了，例如如下代码，我可以写成这样：（注意注释中不一样的地方）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 版本二</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">        const string letterMap[10] = &#123;</span><br><span class="line">            &quot;&quot;, // 0</span><br><span class="line">            &quot;&quot;, // 1</span><br><span class="line">            &quot;abc&quot;, // 2</span><br><span class="line">            &quot;def&quot;, // 3</span><br><span class="line">            &quot;ghi&quot;, // 4</span><br><span class="line">            &quot;jkl&quot;, // 5</span><br><span class="line">            &quot;mno&quot;, // 6</span><br><span class="line">            &quot;pqrs&quot;, // 7</span><br><span class="line">            &quot;tuv&quot;, // 8</span><br><span class="line">            &quot;wxyz&quot;, // 9</span><br><span class="line">        &#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    void getCombinations(const string&amp; digits, int index, const string&amp; s) &#123; // 注意参数的不同</span><br><span class="line">        if (index == digits.size()) &#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int digit = digits[index] - &#x27;0&#x27;;</span><br><span class="line">        string letters = letterMap[digit];</span><br><span class="line">        for (int i = 0; i &lt; letters.size(); i++) &#123;</span><br><span class="line">            getCombinations(digits, index + 1, s + letters[i]);  // 注意这里的不同</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        if (digits.size() == 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        getCombinations(digits, 0, &quot;&quot;);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></h3><p>Medium</p><p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the </p><p>frequency</p><p> of at least one of the chosen numbers is different.</p><p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7</span><br><span class="line">Output: [[2,2,3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.</span><br><span class="line">7 is a candidate, and 7 = 7.</span><br><span class="line">These are the only two combinations.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8</span><br><span class="line">Output: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res =  new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        seek(candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if(sum &gt; target)</span><br><span class="line">        return;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            temp.add(candidates[i]);  //notice here is i not index</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            seek(candidates, target, i, sum);</span><br><span class="line">            temp.remove(temp.size() - 1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pruning:</span><br><span class="line">// 剪枝优化</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); // 先进行排序</span><br><span class="line">        backtracking(res, new ArrayList&lt;&gt;(), candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] candidates, int target, int sum, int idx) &#123;</span><br><span class="line">        // 找到了数字和为 target 的组合</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            // 如果 sum + candidates[i] &gt; target 就终止遍历</span><br><span class="line">            if (sum + candidates[i] &gt; target) break;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(res, path, candidates, target, sum + candidates[i], i);</span><br><span class="line">            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II</a></h3><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><p><strong>这道题强调了candidates里面有重复的元素，我们需要去重</strong></p><p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        seek(candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if(sum &gt; target) return;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            if(i &gt;  index &amp;&amp; candidates[i-1] == candidates[i]) !!!!!!!!!!!! //树层逻辑， 横向检查</span><br><span class="line">            continue;</span><br><span class="line">            temp.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            seek(candidates, target, i + 1, sum);</span><br><span class="line">            temp.remove(temp.size() - 1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树层（横向）上不能重复，</p><p>树枝（纵向）上可以重复。</p><p> if(i &gt;  index &amp;&amp; candidates[i-1] &#x3D;&#x3D; candidates[i]) </p><p>这里如果想不明白的话，其实这句话等同于</p><p> if( i !&#x3D;  index &amp;&amp; candidates[i-1] &#x3D;&#x3D; candidates[i]) continue; 从第二个开始去重</p><p>—-&gt; 就是重复出现的只保留最左侧的一支树枝，其他的就去重<br>比如说 【1， 1， 1， 1， 2】 求和是3， 只保留最左侧的 1-&gt;1-&gt;1这样子一支树</p><h3 id="131-Palindrome-Partitioning分割问题"><a href="#131-Palindrome-Partitioning分割问题" class="headerlink" title="131. Palindrome Partitioning分割问题"></a><a href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a>分割问题</h3><p>Medium</p><p>Given a string <code>s</code>, partition <code>s</code> such that every </p><p>substring</p><p> of the partition is a <strong>palindrome</strong>. Return <em>all possible palindrome partitioning of</em> <code>s</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;aab&quot;</span><br><span class="line">Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        seek(s,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean pal(String s, int left, int right)&#123;</span><br><span class="line">        for(int i = left; i &lt; right; i ++)&#123;</span><br><span class="line">            if(s.charAt(i) == s.charAt(right))&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(String s, int index)&#123;</span><br><span class="line">        if(index &gt;= s.length())&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; s.length(); i++)&#123; </span><br><span class="line">        //i++是树的横向，左边划分的杠在动，划的线数量不变,因为++之前都removeLast了</span><br><span class="line">            if(pal(s,index, i))&#123;</span><br><span class="line">                String str = s.substring(index, i+1);</span><br><span class="line">                // for substring, left is closed but the right is open</span><br><span class="line">                path.add(str);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; </span><br><span class="line">            seek(s, i+1); //树的纵向, i+1是右边的划杠在动，划的线增多</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/907a2a94961ed3e0c1b67469e6f51163ce7a044af822069f0983ceccf4c168a2/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067" alt="131.分割回文串"></p><p>视频讲解看93的，讲的更清楚：<a href="https://www.bilibili.com/video/BV1XP4y1U73i/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1XP4y1U73i/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p><h3 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a><a href="https://leetcode.com/problems/restore-ip-addresses/">93. Restore IP Addresses</a></h3><p>Medium</p><p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p><ul><li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li></ul><p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        backtrack(s,0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(String s, int index, int point)&#123; // index is slash</span><br><span class="line">        if(point == 3)&#123;</span><br><span class="line">            //check the last part, the fourth part</span><br><span class="line">            if(isValid(s, index, s.length() - 1))&#123;//left close right close</span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; s.length(); i++)&#123;// i++是树的横向，左边划分的杠在动，划的线数量不变,因为++之前都removeLast了</span><br><span class="line">            if(isValid(s, index, i))&#123;</span><br><span class="line">                s = s.substring(0, i+1)+&quot;.&quot;+s.substring(i+1);</span><br><span class="line">                point++;</span><br><span class="line">                backtrack(s, i + 2, point); //vertical</span><br><span class="line">                point--;</span><br><span class="line">                s = s.substring(0, i+1) + s.substring(i+2);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private Boolean isValid(String s, int start, int end) &#123;</span><br><span class="line">        if (start &gt; end) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.charAt(start) == &#x27;0&#x27; &amp;&amp; start != end) &#123; // 0开头的数字不合法</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            if (s.charAt(i) &gt; &#x27;9&#x27; || s.charAt(i) &lt; &#x27;0&#x27;) &#123; // 遇到⾮数字字符不合法</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * 10 + (s.charAt(i) - &#x27;0&#x27;);</span><br><span class="line">            if (num &gt; 255) &#123; // 如果⼤于255了不合法</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>s.substring(i + 1)</code> expression suggests that you’re extracting a substring from the string <code>s</code>, starting from the index <code>i + 1</code> and continuing until the end of the string.</p><p><img src="https://camo.githubusercontent.com/875e015ae28ea369ec6b67e63581ee5d18fd717dbe5bbfd4404ea713427d78e5/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333230333733353933332d32303233303331303133323331343130392e706e67" alt="93.复原IP地址"></p><h3 id="78-Subsets-求子集问题"><a href="#78-Subsets-求子集问题" class="headerlink" title="78. Subsets 求子集问题"></a><a href="https://leetcode.com/problems/subsets/">78. Subsets</a> 求子集问题</h3><p>Medium</p><p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> </p><p><em>subsets</em></p><p> <em>(the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(temp)); // 加上空子集</span><br><span class="line">        backtrack(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        </span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            //res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            backtrack(nums, i + 1);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></span></p><p><img src="https://camo.githubusercontent.com/a6dcda91c3ef3c4a6ffb3d096d791c50f9bf389b645e337df73b9785e05a07c9/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f37382e2545352541442539302545392539422538362e706e67" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p><h3 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a><a href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h3><p>Medium</p><p>Companies</p><p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> </p><p><em>subsets</em></p><p> <em>(the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,2]</span><br><span class="line">Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrack(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTrack(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(i &gt; index &amp;&amp; nums[i] == nums[i-1])&#123;</span><br><span class="line">               continue;  //最好把这种需要退出的情况写在前面</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">                backTrack(nums, i+1);</span><br><span class="line">                temp.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WRONG VERSION:   ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    public void backTrack(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(i &gt; index &amp;&amp; nums[i] != nums[i-1])&#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">                backTrack(nums, i+1);</span><br><span class="line">                temp.removeLast();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/9bf54f50895f39143eb86212493192fd2785477ce470dd02f68b3eac1d524554/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343139353431313937372e706e67"><img src="https://camo.githubusercontent.com/9bf54f50895f39143eb86212493192fd2785477ce470dd02f68b3eac1d524554/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343139353431313937372e706e67" alt="90.子集II"></a></p><p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p><h3 id="491-Non-decreasing-Subsequences"><a href="#491-Non-decreasing-Subsequences" class="headerlink" title="491. Non-decreasing Subsequences"></a><a href="https://leetcode.com/problems/non-decreasing-subsequences/">491. Non-decreasing Subsequences</a></h3><p>Medium</p><p>Given an integer array <code>nums</code>, return <em>all the different possible non-decreasing subsequences of the given array with at least two elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,6,7,7]</span><br><span class="line">Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        backtrack(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums, int index)&#123;</span><br><span class="line">        // if(nums.length == index)&#123;</span><br><span class="line">        //     return;</span><br><span class="line">        // &#125;  if you add this, the result is wrong, should put this after if(temp.size() &gt; 1) statement</span><br><span class="line">        if(temp.size() &gt; 1)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">           if(!temp.isEmpty() &amp;&amp; nums[i] &lt; temp.getLast())&#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(map.getOrDefault(nums[i], 0) == 1)&#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(nums[i], 1);</span><br><span class="line">           temp.add(nums[i]);</span><br><span class="line">           backtrack(nums, i+1);</span><br><span class="line">           temp.removeLast();</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1EG4y1h78v/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1EG4y1h78v/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p><p>非常非常详细！</p><h3 id="46-Permutations-排列问题"><a href="#46-Permutations-排列问题" class="headerlink" title="46. Permutations 排列问题"></a><a href="https://leetcode.com/problems/permutations/">46. Permutations</a> 排列问题</h3><p>Medium</p><p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        if (nums.length == 0) return res;</span><br><span class="line">        used = new boolean[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums)&#123;</span><br><span class="line">        if(nums.length == temp.size()) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">       // cant use hash map here   HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;nums.length; i++)&#123;</span><br><span class="line">            if(used[i]) continue;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/4d9e48eecd46a5e924bf90eaf6c6221ab99465443c6d043a60ec3080f44e3458/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313230393137343232353134352e706e67"><img src="https://camo.githubusercontent.com/4d9e48eecd46a5e924bf90eaf6c6221ab99465443c6d043a60ec3080f44e3458/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313230393137343232353134352e706e67" alt="46.全排列"></a></p><p>这里和<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题</a>、<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.切割问题</a>和<a href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题</a>最大的不同就是for循环里不用startIndex了。</p><p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p><p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p><p><strong><span style="color: red">！！！！！！！！！！！！ used数组是用来标记图里面，箭头上写的取的几。！！！！！！！！！</span></strong></p><h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a><a href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></h3><p>Medium</p><p>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = new boolean[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums)&#123;</span><br><span class="line">        if(nums.length == temp.size())&#123;</span><br><span class="line">            res.add(new ArrayList(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i - 1] == false) continue; //!!!!!notice !!!</span><br><span class="line">            if(used[i] == true) continue;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            used[i] = false;</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程</p><p>中, 我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><p>在<a href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列</a>中已经详细讲解了排列问题的写法，在<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II</a> 、<a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II</a>中详细讲解了去重的写法</p><h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>大家发现，去重最为关键的代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**如果改成 <code>used[i - 1] == true</code>， 也是正确的!**，去重代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == true) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><strong>对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！</strong></p><p>这么说是不是有点抽象？</p><p>来来来，我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] &#x3D;&#x3D; false)，的树形结构如下：</p><p><a href="https://camo.githubusercontent.com/d376a49f4a94ac97d3cf49210f27b85b3efbb4342bd9c43f54abf45ab83bdc9c/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313430363139322e706e67"><img src="https://camo.githubusercontent.com/d376a49f4a94ac97d3cf49210f27b85b3efbb4342bd9c43f54abf45ab83bdc9c/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313430363139322e706e67" alt="47.全排列II2"></a></p><p>树枝上去重（used[i - 1] &#x3D;&#x3D; true）的树型结构如下：</p><p><a href="https://camo.githubusercontent.com/152d38ad66c1f7ef4e32e9ce709eb36132b721d94fb4cc37264c49d1825255bc/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313433313537312e706e67"><img src="https://camo.githubusercontent.com/152d38ad66c1f7ef4e32e9ce709eb36132b721d94fb4cc37264c49d1825255bc/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313433313537312e706e67" alt="47.全排列II3"></a></p><p>大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><h3 id="去重（一些错误写法的提醒）"><a href="#去重（一些错误写法的提醒）" class="headerlink" title="去重（一些错误写法的提醒）"></a>去重（一些错误写法的提醒）</h3><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.md</a></p><h3 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a><a href="https://leetcode.com/problems/n-queens/">51. N-Queens</a></h3><p>Hard</p><p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p><p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p><p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: [[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        char[][] board = new char[n][n];</span><br><span class="line">        for (char[] c : board) &#123;</span><br><span class="line">            Arrays.fill(c, &#x27;.&#x27;);    !!!!!!!</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(board, n , 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(char[][] board,int n, int row)&#123;</span><br><span class="line">        if(row == n)&#123; //走到叶子节点，那一定是合法的</span><br><span class="line">            res.add(Array2List(board));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(check(board,n,row,i))&#123;</span><br><span class="line">                board[row][i] = &#x27;Q&#x27;;</span><br><span class="line">                backtrack(board, n, row + 1);</span><br><span class="line">                board[row][i] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List Array2List(char[][] chessboard) &#123;!!!!!</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (char[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));  !!!!!</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(char[][] chessboard, int n, int row, int col) &#123;</span><br><span class="line">        // 检查列</span><br><span class="line">        for (int i=0; i&lt;row; ++i) &#123; // 相当于剪枝</span><br><span class="line">            if (chessboard[i][col] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查45度对角线</span><br><span class="line">        for (int i=row, j=col; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) &#123;!!!!!!</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查135度对角线</span><br><span class="line">        for (int i=row, j=col; i&gt;=0 &amp;&amp; j&lt;=n-1; i--, j++) &#123;</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wrong version:</span><br><span class="line"></span><br><span class="line">    public List Array2List(char[][] chessboard) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (char[] c : chessboard) &#123;</span><br><span class="line"></span><br><span class="line">            for(char cc :  c)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(Character.toString(cc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>Output</p><p>[[“.”,”Q”,”.”,”.”,”.”,”.”,”.”,”Q”,”Q”,”.”,”.”,”.”,”.”,”.”,”Q”,”.”],[“.”,”.”,”Q”,”.”,”Q”,”.”,”.”,”.”,”.”,”.”,”.”,”Q”,”.”,”Q”,”.”,”.”]]</p><p>Expected</p><p>[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</p><ol><li><strong>Using <code>Arrays.fill()</code></strong>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codefor (char[] c : board) &#123;</span><br><span class="line">    Arrays.fill(c, &#x27;.&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this approach, you are using the <code>Arrays.fill()</code> method to fill each row of the 2D array <code>board</code> with the character <code>&#39;.&#39;</code>. This method directly modifies the array elements in place, replacing the characters within each subarray with <code>&#39;.&#39;</code>.</p><ol><li><strong>Using nested loops</strong>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codefor (char[] c : board) &#123;</span><br><span class="line">    for (char cc : c) &#123;</span><br><span class="line">        cc = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this approach, you are using nested loops to iterate through each row (<code>char[] c</code>) and then iterating through each character (<code>char cc</code>) within that row. However, the assignment <code>cc = &#39;.&#39;;</code> only updates the value of the loop variable <code>cc</code>, which does not have any effect on the actual characters stored in the <code>board</code> array. This means that the characters within the <code>board</code> array remain unchanged.</p><p>The key difference is that the first approach (<code>Arrays.fill()</code>) directly modifies the array elements, while the second approach (nested loops) only modifies the loop variables without affecting the array contents.</p><p>To achieve the same result as the <code>Arrays.fill()</code> approach, you would need to use the index to update the characters within the <code>board</code> array:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codefor (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">    Arrays.fill(board[i], &#x27;.&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This way, you are directly modifying the characters in the <code>board</code> array using the indices of the rows and columns.</p><p>这样也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    for(int j = 0 ; j &lt; n; j++)&#123;</span><br><span class="line">        board[i][j] = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/2023/07/28/LeetCode/tree/"/>
      <url>/2023/07/28/LeetCode/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="Tree🌼"><a href="#Tree🌼" class="headerlink" title="Tree🌼"></a>Tree🌼</h1><p>Recursive VS. BackTrack</p><p><a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/79682147">https://blog.csdn.net/ajianyingxiaoqinghan/article/details/79682147</a></p><h2 id="Depth-first-traversal"><a href="#Depth-first-traversal" class="headerlink" title="Depth-first traversal"></a>Depth-first traversal</h2><h3 id="The-recursive-traversal-of-a-binary-tree"><a href="#The-recursive-traversal-of-a-binary-tree" class="headerlink" title="The recursive traversal of a binary tree"></a>The recursive traversal of a binary tree</h3><p><strong>In-order traversal (Left-Root-Right)</strong>:</p><ol><li>Traverse the left subtree.</li><li>Visit the current node (Root).</li><li>Traverse the right subtree.</li></ol><p><strong>Pre-order traversal (Root-Left-Right)</strong>:</p><ol><li>Visit the current node (Root).</li><li>Traverse the left subtree.</li><li>Traverse the right subtree.</li></ol><p><strong>Post-order traversal (Left-Right-Root)</strong>:</p><ol><li>Traverse the left subtree.</li><li>Traverse the right subtree.</li><li>Visit the current node (Root).</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 前序遍历·递归·LC144_二叉树的前序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorder(root.left, result);</span><br><span class="line">        preorder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 中序遍历·递归·LC94_二叉树的中序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             // 注意这一句</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 后序遍历·递归·LC145_二叉树的后序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             // 注意这一句</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterative-traversal-of-a-binary-tree"><a href="#Iterative-traversal-of-a-binary-tree" class="headerlink" title="Iterative traversal of a binary tree"></a>Iterative traversal of a binary tree</h3><ol><li><p><strong>Iterative In-order traversal</strong>: In this method, we simulate the function call stack of the recursive in-order traversal using a stack data structure. It involves traversing the left subtree first, then visiting the current node, and finally, traversing the right subtree.</p><p><a href="https://camo.githubusercontent.com/6ea32e330a3c937346b1f48b3808a3ab0aade0f9b3cbe4a93b5580c08727cdb1/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545342542382541442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966"><img src="https://camo.githubusercontent.com/6ea32e330a3c937346b1f48b3808a3ab0aade0f9b3cbe4a93b5580c08727cdb1/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545342542382541442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966" alt="二叉树中序遍历（迭代法）"></a></p></li><li><p><strong>Iterative Pre-order traversal</strong>: In this approach, we use a stack to mimic the recursive pre-order traversal. It involves visiting the current node, then traversing the left subtree, and finally, traversing the right subtree.</p><p><a href="https://camo.githubusercontent.com/b9924e53ce35c0417f176da66bcac1738f75eeb2ab20f4f243c36be62295004a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545352538392538442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966"><img src="https://camo.githubusercontent.com/b9924e53ce35c0417f176da66bcac1738f75eeb2ab20f4f243c36be62295004a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545352538392538442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966" alt="二叉树前序遍历（迭代法）"></a></p></li><li><p><strong>Iterative Post-order traversal</strong>: This method can be a bit more complex than the other two. It requires two stacks or a single stack with additional bookkeeping to simulate the recursive post-order traversal. The nodes are processed in the order of the left subtree, right subtree, and then the current node.</p><p><a href="https://camo.githubusercontent.com/997513e75ec0672ae4d7e8a962d571139646ac3ebef98ba4f89e5fba29db05e7/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830383230303333383932342e706e67"><img src="https://camo.githubusercontent.com/997513e75ec0672ae4d7e8a962d571139646ac3ebef98ba4f89e5fba29db05e7/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830383230303333383932342e706e67" alt="前序到后序"></a></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        while (cur != null || !stack.isEmpty())&#123;</span><br><span class="line">           if (cur != null)&#123; </span><br><span class="line">           // Continuing the traversal of the left nodes </span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">           // reached the end of the root node</span><br><span class="line">           // add value into the result </span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Level-order-traversal"><a href="#Level-order-traversal" class="headerlink" title="Level-order traversal"></a>Level-order traversal</h2><ol><li><p>先搞个que，把root加到que里面</p></li><li><p>while（que的长度不为0）</p><p>记录下que的长度，这就是这一排的元素个数</p><p>挨着把que的元素加到res里面去，加进去一个的同时把这个节点的子节点加入到que里面去。</p></li></ol><h4 id="implement-breadth-first-traversal-level-order-traversal-of-a-binary-tree-using-a-queue"><a href="#implement-breadth-first-traversal-level-order-traversal-of-a-binary-tree-using-a-queue" class="headerlink" title="implement breadth-first traversal (level-order traversal) of a binary tree using a queue."></a>implement breadth-first traversal (level-order traversal) of a binary tree using a queue.</h4><p><a href="https://camo.githubusercontent.com/919d39fe06ad2477c184566959d71de2394c53628d4d7a2cc858087a3a1d113b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3130322545342542412538432545352538462538392545362541302539312545372539412538342545352542312538322545352542412538462545392538312538442545352538452538362e676966"><img src="https://camo.githubusercontent.com/919d39fe06ad2477c184566959d71de2394c53628d4d7a2cc858087a3a1d113b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3130322545342542412538432545352538462538392545362541302539312545372539412538342545352542312538322545352542412538462545392538312538442545352538452538362e676966" alt="102二叉树的层序遍历"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 102.二叉树的层序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        //checkFun01(root,0);</span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        return resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DFS--递归方式</span><br><span class="line">    public void checkFun01(TreeNode node, Integer deep) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        if (resList.size() &lt; deep) &#123;</span><br><span class="line">            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span><br><span class="line">            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - 1).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BFS--迭代方式--借助队列</span><br><span class="line">    public void checkFun02(TreeNode node) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        while (!que.isEmpty()) &#123;</span><br><span class="line">        // new level</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            int len = que.size();</span><br><span class="line"></span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                if (tmpNode.left != null) que.offer(tmpNode.left);</span><br><span class="line">                if (tmpNode.right != null) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>my version: </p><ol start="102"><li>Binary Tree Level Order Traversal</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        trav(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void trav(TreeNode node)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); // LinkedList</span><br><span class="line">        que.offer(node);</span><br><span class="line">        while(!que.isEmpty())&#123; //que != null</span><br><span class="line">            int num = que.size(); // not length num用来记录每一排有几个元素</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">            //itemList 用来记录que里面马上要出来的一排的nodes</span><br><span class="line">            while(num != 0)&#123;</span><br><span class="line">                TreeNode popNode = que.poll(); </span><br><span class="line">                itemList.add(popNode.val); //准备好itemlist</span><br><span class="line">                num--;</span><br><span class="line">                if(popNode.left != null)&#123; //把poll出去的节点的子节点offer进来</span><br><span class="line">                    que.offer(popNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(popNode.right != null)&#123;</span><br><span class="line">                    que.offer(popNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //把itemList给加到res里面</span><br><span class="line">            res.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="que-x3D-x3D-null-VS-que-isEmpty"><a href="#que-x3D-x3D-null-VS-que-isEmpty" class="headerlink" title="que&#x3D;&#x3D;null VS. que.isEmpty()"></a>que&#x3D;&#x3D;null VS. que.isEmpty()</h4><ol><li><code>que.isEmpty()</code>: This is a method used to check if the queue is empty or not. The <code>isEmpty()</code> method is available in the <code>java.util.Queue</code> interface and is implemented by classes like <code>LinkedList</code> or <code>PriorityQueue</code>. It returns <code>true</code> if the queue has no elements, and <code>false</code> otherwise.</li></ol><p>Here’s an example of how to use <code>isEmpty()</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class QueueExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // Adding elements to the queue</span><br><span class="line">        queue.offer(&quot;Element 1&quot;);</span><br><span class="line">        queue.offer(&quot;Element 2&quot;);</span><br><span class="line"></span><br><span class="line">        // Check if the queue is empty</span><br><span class="line">        if (queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;Queue is empty.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Queue is not empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>que == null</code>: This is a comparison that checks whether the reference <code>que</code> points to a valid queue object (i.e., not null). If <code>que</code> is a valid reference to a queue object, the comparison <code>que == null</code> will return <code>false</code>. If <code>que</code> is not pointing to any object (i.e., it is null), then the comparison will return <code>true</code>.</li></ol><p>Here’s an example of how to use the <code>que == null</code> comparison:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class QueueExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue&lt;String&gt; queue = null;</span><br><span class="line"></span><br><span class="line">        // Check if the queue reference is null</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            System.out.println(&quot;Queue reference is null.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Queue reference is not null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this example, we initialize the <code>queue</code> variable to <code>null</code> and then use the <code>que == null</code> comparison to check if the reference is null.</p><p>Remember that <code>isEmpty()</code> is used to check if the queue has no elements, while <code>que == null</code> is used to check if the reference to the queue object is null.</p><h3 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h3><h3 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">       if( root == null) return res;</span><br><span class="line">       Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">       que.offer(root);</span><br><span class="line"></span><br><span class="line">       while(!que.isEmpty())&#123;</span><br><span class="line">           int num = que.size();</span><br><span class="line">           while(num!=0)&#123;</span><br><span class="line">               TreeNode temp = que.poll();</span><br><span class="line">               </span><br><span class="line">               if(temp.left != null)</span><br><span class="line">                que.offer(temp.left);</span><br><span class="line">               if(temp.right != null)</span><br><span class="line">                que.offer(temp.right);</span><br><span class="line">            </span><br><span class="line">                if(num == 1)&#123;</span><br><span class="line">                    res.add(temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                num--;  // need to put num-1 after num ==1</span><br><span class="line">           &#125;</span><br><span class="line">       </span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class="line">        List&lt;Double&gt; res = new ArrayList&lt;Double&gt;();</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            double mark = num;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            while ( num != 0)&#123;</span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                sum += temp.val;</span><br><span class="line">                num--;</span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sum/mark);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></h3><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes’ values.</p><p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                Node temp = que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                for(Node child: temp.children)&#123;  //!!!</span><br><span class="line">                    que.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></h3><p>Given the <code>root</code> of a binary tree, return <em>an array of the largest value in each row</em> of the tree <strong>(0-indexed)</strong>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,3,2,5,3,null,9]</span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            </span><br><span class="line">            int big = Integer.MIN_VALUE;</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                </span><br><span class="line">                big = Math.max(big, temp.val);</span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(big);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h3><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            Queue&lt;Node&gt; Itemlist = new LinkedList&lt;Node&gt;();</span><br><span class="line">            while(num != 0)&#123;</span><br><span class="line">                Node temp = que.poll();  </span><br><span class="line">                Itemlist.add(temp);       </span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">                </span><br><span class="line">                num--; </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            while(Itemlist.size() &gt; 1)&#123; // &gt;1 not &gt;0</span><br><span class="line"></span><br><span class="line">                Node temp = Itemlist.poll();</span><br><span class="line">                Node tempnext = Itemlist.peek(); // cant poll, only peek.</span><br><span class="line">                </span><br><span class="line">                temp.next = tempnext;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return root;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h3><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3,6,9]</span><br><span class="line">Output: [4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p>我们来看一下递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p><p>返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为<code>TreeNode*</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root)</span><br></pre></td></tr></table></figure><p>2.确定终止条件</p><p>当前节点为空的时候，就返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) return root;</span><br></pre></td></tr></table></figure><p>3.确定单层递归的逻辑</p><p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swap(root-&gt;left, root-&gt;right);</span><br><span class="line">invertTree(root-&gt;left);</span><br><span class="line">invertTree(root-&gt;right);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        if(root == null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        swapChildren(root); //preorder</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        // cant put swapChildren in the middle</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        // swapChildren(root); postorder</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swapChildren(TreeNode node)&#123;</span><br><span class="line">        TreeNode temp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h3><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> compare(root.left,root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) || (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outside&amp;&amp;inside;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md</a></p><ol><li>确定递归函数的参数和返回值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool compare(TreeNode* left, TreeNode* right)</span><br></pre></td></tr></table></figure><ol start="2"><li>确定终止条件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if((left != null &amp;&amp; right == null) || (left == null &amp;&amp; right != null) )&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">if(left == null &amp;&amp; right == null)&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">if(left != null &amp;&amp; right != null)&#123;</span><br><span class="line">    if(left.val != right.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>确定单层递归的逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean outside = compare(left.left, right.right);</span><br><span class="line">boolean inside = compare(left.right, right.left);</span><br><span class="line">return outside&amp;&amp;inside;</span><br></pre></td></tr></table></figure></li></ol><h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h3><p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p = [1,2,3], q = [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(p, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span> &amp;&amp; left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right.val != left.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftc</span> <span class="operator">=</span> compare(left.left, right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightc</span> <span class="operator">=</span> compare(left.right, right.right);</span><br><span class="line">        <span class="keyword">return</span> leftc&amp;&amp;rightc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tree’s-height-VS-tree’s-depth"><a href="#tree’s-height-VS-tree’s-depth" class="headerlink" title="tree’s height VS. tree’s depth:"></a>tree’s height VS. tree’s depth:</h2><p>tutorial： <a href="https://www.bilibili.com/video/BV1Gd4y1V75u/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1Gd4y1V75u/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p><p>In summary, the “tree” is a data structure composed of nodes connected by edges. The “height” of a tree refers to the length of the longest path from the root node to any leaf node, while the “depth” of a node refers to the length of the path from the root node to that particular node.</p><p><strong>高度（👆）： 后序遍历</strong>  (easier)</p><p><strong>深度（👇）： 前序遍历</strong></p><h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h3><p><strong><span style="color: red">根节点的高度就是二叉树的最大深度</span></strong></p><p>WAY1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        左<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        右<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        中<span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;  <span class="comment">// 注意要+1， 这是当前节点的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li></ol><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getdepth(TreeNode* node)</span><br></pre></td></tr></table></figure><ol start="2"><li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li></ol><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (node == NULL) return 0;</span><br></pre></td></tr></table></figure><ol start="3"><li>确定单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int left = maxDepth(root.left);</span><br><span class="line">int right = maxDepth(root.right);</span><br><span class="line">return Math.max(left, right) + 1;</span><br></pre></td></tr></table></figure><p>WAY2: 层序遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int layer = 0;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            layer++;</span><br><span class="line">            while(num != 0)&#123;</span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                num --;</span><br><span class="line">                if(temp.left!=null)que.add(temp.left);</span><br><span class="line">                if(temp.right!=null)que.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return layer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(Node root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for(Node child: root.children)&#123;</span><br><span class="line">            max = Math.max(max, maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        return max+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h3><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        int left = minDepth(root.left);</span><br><span class="line">        int right = minDepth(root.right);</span><br><span class="line">        //如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。</span><br><span class="line">//反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1</span><br><span class="line">        if(root.left == null )   !!!!!!!!!!!!</span><br><span class="line">            return right + 1;    !!!!!!!!!!!!</span><br><span class="line">        if(root.right == null )  !!!!!!!!!!!!</span><br><span class="line">            return  left + 1;    !!!!!!!!!!!!</span><br><span class="line">        return Math.min(left, right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a href="https://leetcode.com/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h3><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p><p>According to <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2h</code> nodes inclusive at the last level <code>h</code>.</p><p>Design an algorithm that runs in less than <code>O(n)</code> time complexity.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        if(root.left != null) left = countNodes(root.left) ; </span><br><span class="line">        //注意不+1</span><br><span class="line">        if(root.right != null) right = countNodes(root.right) ;</span><br><span class="line">         //注意不+1</span><br><span class="line">        return left + right + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    if(root.left != null) left = countNodes(root.left)+1 ;       if(root.right != null) right = countNodes(root.right)+1 ;         return left + right;        这样的话，相当于上一层的那个节点被加了两次。</code></pre><h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h3><p>Given a binary tree, determine if it is <strong>height-balanced</strong></p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>A balanced binary tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the <strong>height</strong> of <strong>the left and right subtree of  <span style = "color : red">any node</span></strong> differ by not more than 1.</p><p>wrong version:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> min(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> max(root);</span><br><span class="line">        <span class="keyword">if</span>(max - min &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> min(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> min(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> max(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> max(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, there are a few issues with the provided code:</p><ol><li>The recursive calls to <code>isBalanced</code> inside the if condition are not returning the result. Instead, they are being called, but the result is not being used or returned.</li><li>The calculation of height in the methods <code>countLef</code> and <code>countRig</code> seems incorrect, as it simply returns the count of nodes in the left and right subtrees, respectively, rather than the height of the subtrees.</li></ol><p>right version:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// class Solution &#123;</span><br><span class="line">//     public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">//         if(root == null) return true;</span><br><span class="line"></span><br><span class="line">//         if(countLef(root) - countRig(root) &lt;= 1) &#123;</span><br><span class="line">//             isBalanced(root.left);</span><br><span class="line">//             isBalanced(root.right);</span><br><span class="line">//         &#125;else&#123;</span><br><span class="line">//             return false;</span><br><span class="line">//         &#125;</span><br><span class="line">//         return true;</span><br><span class="line">        </span><br><span class="line">//     &#125;</span><br><span class="line">//     public int countLef(TreeNode node)&#123;</span><br><span class="line">//         if(node == null) return 0;</span><br><span class="line">//         int left = countLef(node.left);</span><br><span class="line">//         return left + 1;</span><br><span class="line">//     &#125;</span><br><span class="line">//     public int countRig(TreeNode node)&#123;</span><br><span class="line">//         if(node == null) return 0;</span><br><span class="line">//         int right = countRig(node.right);</span><br><span class="line">//         return right + 1;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftHeight = height(root.left);</span><br><span class="line">        int rightHeight = height(root.right);</span><br><span class="line"></span><br><span class="line">        if (Math.abs(leftHeight - rightHeight) &lt;= 1) &#123;</span><br><span class="line">            // Check if both left and right subtrees are balanced</span><br><span class="line">            return isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Compute the height of the left and right subtrees</span><br><span class="line">        int leftHeight = height(node.left);</span><br><span class="line">        int rightHeight = height(node.right);</span><br><span class="line"></span><br><span class="line">        // Return the maximum height plus 1 (to account for the current node)</span><br><span class="line">        return Math.max(leftHeight, rightHeight) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths</a></h3><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        deal(root, &quot;&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deal(TreeNode node, String s) &#123;</span><br><span class="line">        if(node == null ) return ;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line">            res.add(s + Integer.toString(node.val));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String tmp = s + Integer.toString(node.val)+&quot;-&gt;&quot;;</span><br><span class="line">        deal(node.left,tmp);</span><br><span class="line">        deal(node.right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        deal(root, &quot;&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deal(TreeNode node, String s) &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">            return;</span><br><span class="line">        if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">            result.add(new StringBuilder(s).append(node.val).toString()); </span><br><span class="line">            //toString method converts StringBuider into String type.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String tmp = new StringBuilder(s).append(node.val).append(&quot;-&gt;&quot;).toString();</span><br><span class="line">        deal(node.left, tmp);</span><br><span class="line">        deal(node.right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//回溯算法（原始算法，精简之前的代码）较难</span><br><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 递归法</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();// 存最终的结果</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();// 作为结果中的路径</span><br><span class="line">        traversal(root, paths, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) &#123;</span><br><span class="line">        paths.add(root.val);// 前序遍历，中</span><br><span class="line">        // 遇到叶子结点</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            // 输出</span><br><span class="line">            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快</span><br><span class="line">            for (int i = 0; i &lt; paths.size() - 1; i++) &#123;</span><br><span class="line">                sb.append(paths.get(i)).append(&quot;-&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点</span><br><span class="line">            res.add(sb.toString());// 收集一个路径</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递归和回溯是同时进行，所以要放在同一个花括号里</span><br><span class="line">        if (root.left != null) &#123; // 左</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - 1);// 回溯</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right != null) &#123; // 右</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - 1);// 回溯</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h3><p><strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p><p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;    !!!!!!!!!!!!!!!!!!!</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Return if the current node is null</span></span><br><span class="line">        &#125;                      !!!!!!!!!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            res += node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sum(node.left);</span><br><span class="line">        sum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归三部曲：</p><ol><li>确定递归函数的参数和返回值</li></ol><p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int</p><p>使用题目中给出的函数就可以了。</p><ol><li>确定终止条件</li></ol><p>如果遍历到空节点，那么左叶子值一定是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) return 0;</span><br></pre></td></tr></table></figure><p>注意，只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) return 0;</span><br><span class="line">if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; //其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。</span><br></pre></td></tr></table></figure><ol><li>确定单层递归的逻辑</li></ol><p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p><h3 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h3><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">recursive method :</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int res = 0;</span><br><span class="line">    public int maxDep = 0;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        findLeft(root, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void findLeft(TreeNode node, int depth)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line"></span><br><span class="line">            if(depth &gt; maxDep)&#123;</span><br><span class="line">                maxDep = depth;</span><br><span class="line">                res = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        if (node.left != null)findLeft(node.left,depth ++);</span><br><span class="line">        if (node.right != null)findLeft(node.right,depth ++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iterative method:  (my cersion)</span><br><span class="line">// find the first node in the last row of the tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int res;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(! que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            for(int i = 0; i &lt; num; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                if(i == 0) res = temp.val;</span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a href="https://leetcode.com/problems/path-sum/">112. Path Sum</a></h3><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p><p>A <strong>leaf</strong> is a node with no children.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The root-to-leaf path with the target sum is shown.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean res = false;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        check(root, targetSum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void check(TreeNode node, int targetSum, int sum)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        sum += node.val;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line">            if(targetSum == sum) res = true;</span><br><span class="line">        &#125;else&#123; </span><br><span class="line">             check(node.left, targetSum, sum);</span><br><span class="line">             check(node.right, targetSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.确定终止条件</p><p>首先计数器如何统计这一条路径的和呢？</p><p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p><p>如果最后count &#x3D;&#x3D; 0，同时到了叶子节点的话，说明找到了目标和。</p><p>如果遍历到了叶子节点，count不为0，就是没找到。</p><p>递归终止条件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) return true; // 遇到叶子节点，并且计数为0</span><br><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; // 遇到叶子节点而没有找到合适的边，直接返回</span><br></pre></td></tr></table></figure><p>3.确定单层递归的逻辑</p><p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p><p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (cur-&gt;left) &#123; // 左 （空节点不遍历）</span><br><span class="line">    // 遇到叶子节点返回true，则直接返回true</span><br><span class="line">    if (traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)) return true; // 注意这里有回溯的逻辑</span><br><span class="line">&#125;</span><br><span class="line">if (cur-&gt;right) &#123; // 右 （空节点不遍历）</span><br><span class="line">    // 遇到叶子节点返回true，则直接返回true</span><br><span class="line">    if (traversal(cur-&gt;right, count - cur-&gt;right-&gt;val)) return true; // 注意这里有回溯的逻辑</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure><p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p><p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p><p>为了把回溯的过程体现出来，可以改为如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (cur-&gt;left) &#123; // 左</span><br><span class="line">    count -= cur-&gt;left-&gt;val; // 递归，处理节点;</span><br><span class="line">    if (traversal(cur-&gt;left, count)) return true;</span><br><span class="line">    count += cur-&gt;left-&gt;val; // 回溯，撤销处理结果</span><br><span class="line">&#125;</span><br><span class="line">if (cur-&gt;right) &#123; // 右</span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    if (traversal(cur-&gt;right, count)) return true;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure><h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h3><p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md</a></p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private TreeNode traversal(int[] inorder, int inorderBegin, int inorderEnd, int[] postorder, int postorderBegin, int postorderEnd) &#123;</span><br><span class="line">        if (postorderBegin == postorderEnd) return null;</span><br><span class="line">// find middle node in postorder 后序遍历数组最后一个元素，就是当前的中间节点</span><br><span class="line">        int rootValue = postorder[postorderEnd - 1];</span><br><span class="line">        TreeNode root = new TreeNode(rootValue);</span><br><span class="line">    // leaf node</span><br><span class="line">        if (postorderEnd - postorderBegin == 0) return root;</span><br><span class="line">// fine middle node in the inorder</span><br><span class="line">        int delimiterIndex;</span><br><span class="line">        for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;</span><br><span class="line">            if (inorder[delimiterIndex] == rootValue) break;</span><br><span class="line">        &#125;</span><br><span class="line">// 递归处理左区间和右区间</span><br><span class="line">//用中序中左区间的大小可以去切后续的左区间</span><br><span class="line"></span><br><span class="line">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br><span class="line">        int leftInorderBegin = inorderBegin;</span><br><span class="line">        int leftInorderEnd = delimiterIndex;</span><br><span class="line">        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br><span class="line">        int rightInorderBegin = delimiterIndex + 1;</span><br><span class="line">        int rightInorderEnd = inorderEnd;</span><br><span class="line">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br><span class="line">        int leftPostorderBegin = postorderBegin;</span><br><span class="line">        int leftPostorderEnd = postorderBegin + (delimiterIndex - inorderBegin);</span><br><span class="line">        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br><span class="line">        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);</span><br><span class="line">        int rightPostorderEnd = postorderEnd - 1;</span><br><span class="line"></span><br><span class="line">        root.left = traversal(inorder, leftInorderBegin, leftInorderEnd, postorder, leftPostorderBegin, leftPostorderEnd);</span><br><span class="line">        root.right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        if (inorder.length == 0 || postorder.length == 0) return null;</span><br><span class="line">        // 左闭右开的原则</span><br><span class="line">        return traversal(inorder, 0, inorder.length, postorder, 0, postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if(preorder.length == 0 || inorder.length ==0) return null;</span><br><span class="line">        return construct(preorder, 0, preorder.length, inorder, 0, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode construct(int[] pre, int pres, int pree, int[]in, int ins, int ine)&#123;</span><br><span class="line">        if (pres == pree) return null; // Base case</span><br><span class="line"></span><br><span class="line">        int midValue = pre[pres];</span><br><span class="line">        TreeNode mid = new TreeNode(midValue);</span><br><span class="line">        //mid.val = pre[pres];</span><br><span class="line">        if(pres - pree == 0) return mid;</span><br><span class="line">        </span><br><span class="line">        int index;</span><br><span class="line"></span><br><span class="line">        for(index = ins; index &lt; ine; index++ )&#123;</span><br><span class="line">            if(in[index] == midValue) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftPreStart = pres + 1;</span><br><span class="line">        int leftPreEnd = pres + 1 + index - ins ;</span><br><span class="line">        int rightPreStart = pres + 1 + index - ins;</span><br><span class="line">        int rightPreEnd = pree;</span><br><span class="line"></span><br><span class="line">        int leftInStart = ins;</span><br><span class="line">        int leftInEnd = index;</span><br><span class="line">        int rightInStart = index + 1;</span><br><span class="line">        int rightInEnd = ine;</span><br><span class="line">        mid.left = construct(pre, leftPreStart, leftPreEnd, in, leftInStart, leftInEnd);</span><br><span class="line">        mid.right = construct(pre, rightPreStart, rightPreEnd, in, rightInStart, rightInEnd);</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></h3><p>Medium</p><p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p><ol><li>Create a root node whose value is the maximum value in <code>nums</code>.</li><li>Recursively build the left subtree on the <strong>subarray <span style="color: red">prefix</span></strong> to the <strong>left</strong> of the maximum value.</li><li>Recursively build the right subtree on the **subarray <span style="color: red">suffix</span> ** to the <strong>right</strong> of the maximum value.</li></ol><p>Return <em>the <strong>maximum binary tree</strong> built from</em> <code>nums</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,1,6,0,5]</span><br><span class="line">Output: [6,3,5,null,2,0,null,null,1]</span><br><span class="line">Explanation: The recursive calls are as follow:</span><br><span class="line">- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].</span><br><span class="line">    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].</span><br><span class="line">        - Empty array, so no child.</span><br><span class="line">        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].</span><br><span class="line">            - Empty array, so no child.</span><br><span class="line">            - Only one element, so child is a node with value 1.</span><br><span class="line">    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].</span><br><span class="line">        - Only one element, so child is a node with value 0.</span><br><span class="line">        - Empty array, so no child.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cons(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">cons</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(end - start &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 没元素了！！！</span></span><br><span class="line">         <span class="keyword">if</span>(end - start == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[start]); <span class="comment">//只有一个元素(左闭右开)！！！</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; nums[i])&#123;</span><br><span class="line">                 max = nums[i];</span><br><span class="line">                 index = i;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        root.val = max;</span><br><span class="line">        root.left = cons(nums, start, index);</span><br><span class="line">        root.right =  cons(nums, index+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wrong version:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;</span><br><span class="line">        //if(nums.length == 0) return null;</span><br><span class="line">        return cons(nums, 0, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode cons(int[] nums, int start, int end)&#123;</span><br><span class="line">        // if(end - start &lt; 1) return null; // 没元素了</span><br><span class="line">        // if(end - start == 1) return new TreeNode(nums[start]); //只有一个元素 leaf node</span><br><span class="line">        TreeNode root = new TreeNode();</span><br><span class="line">        if(end == start ) return root;</span><br><span class="line">        int max = nums[start];</span><br><span class="line">        int index = start;</span><br><span class="line">        for( int i = start; i &lt; end; i++)&#123;</span><br><span class="line">            if (max &lt; nums[i])&#123;</span><br><span class="line">                 max = nums[i];</span><br><span class="line">                 index = i;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        root.val = max;</span><br><span class="line">        root.left = cons(nums, start, index);</span><br><span class="line">        root.right =  cons(nums, index+1, end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h3><p>Easy</p><p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p><p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p><p>Return <em>the merged tree</em>.</p><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">Output: [3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root1 == null &amp;&amp; root2 == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = new TreeNode();</span><br><span class="line">        </span><br><span class="line">        if (root1 == null) &#123;</span><br><span class="line">            root.val = root2.val;</span><br><span class="line">        &#125; else if (root2 == null) &#123;</span><br><span class="line">            root.val = root1.val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.val = root1.val + root2.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = mergeTrees(root1 != null ? root1.left : null, root2 != null ? root2.left : null);</span><br><span class="line">        root.right = mergeTrees(root1 != null ? root1.right : null, root2 != null ? root2.right : null);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//leetcoke:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 递归</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root1 == null) return root2;</span><br><span class="line">        if (root2 == null) return root1;</span><br><span class="line"></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></h3><p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p><p>Find the node in the BST that the node’s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3], val = 2</span><br><span class="line">Output: [2,1,3]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        if(root.val == val) return root;</span><br><span class="line">        TreeNode result = new TreeNode();</span><br><span class="line">        result = searchBST(root.left, val);</span><br><span class="line">        if(result != null ) return result;</span><br><span class="line">        result = searchBST(root.right, val);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WRONG: </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        if(root.val == val) return root;</span><br><span class="line">        </span><br><span class="line">        searchBST(root.left, val);</span><br><span class="line">        searchBST(root.right, val);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h3><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li><p>The left subtree</p><p> of a node contains only nodes with keys</p><p>less than</p><p>the node’s key.</p></li><li><p>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</p></li><li><p>Both the left and right subtrees must also be binary search trees.</p></li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">实质上就是中序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode max;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return true;</span><br><span class="line">        </span><br><span class="line">            boolean left = isValidBST(root.left); //左</span><br><span class="line">            if(!left) return false;</span><br><span class="line"></span><br><span class="line">            if (max != null &amp;&amp; root.val &lt;= max.val) &#123; //中 比较节点的逻辑 </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">            max = root; //记录当前节点的上一个节点，因为按照中序遍历，当前节点都应该比上一个节点大。</span><br><span class="line"></span><br><span class="line">            boolean right = isValidBST(root.right);//右</span><br><span class="line">            if(!right) return false;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public  List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        see(root);</span><br><span class="line">        return check(res);</span><br><span class="line">    &#125;</span><br><span class="line">    public void see(TreeNode node)&#123;</span><br><span class="line">       if(node == null) return;</span><br><span class="line">       see(node.left);</span><br><span class="line">       res.add(node.val);</span><br><span class="line">       see(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean check(List&lt;Integer&gt; res)&#123;</span><br><span class="line">        for(int i = 0; i &lt; res.size() - 1; i++)&#123;</span><br><span class="line">            if(res.get(i) &gt;=  res.get(i+1)) return false; </span><br><span class="line">            //!!!! &gt;= not &gt;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST</a></h3><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,6,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mine:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public int min = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        inorder(root);</span><br><span class="line">        check(res);</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">    public void inorder(TreeNode node)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        inorder(node.left);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public void check(List&lt;Integer&gt; res)&#123;</span><br><span class="line">        for(int i = 0; i &lt; res.size() - 1; i++)&#123;</span><br><span class="line">            int temp = res.get(i+1) - res.get(i);</span><br><span class="line">            if(temp &lt; min)&#123;</span><br><span class="line">                min = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">leetcode:</span><br><span class="line">// 双指针</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode pre;// 记录上一个遍历的结点</span><br><span class="line">    int result = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">       if(root==null)return 0;</span><br><span class="line">       traversal(root);</span><br><span class="line">       return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public void traversal(TreeNode root)&#123;</span><br><span class="line">        if(root==null)return;</span><br><span class="line">        //左</span><br><span class="line">        traversal(root.left);</span><br><span class="line">        //中</span><br><span class="line">        if(pre!=null)&#123;</span><br><span class="line">            result = Math.min(result,root.val-pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        //右</span><br><span class="line">        traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree</a></h3><p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p><p>If the tree has more than one mode, return them in <strong>any order</strong>.</p><p>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">MY VERSION:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123; !!!!!!!!!!!!!!!!!!</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (count &lt; temp) &#123;</span><br><span class="line">                count = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;  !!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() == count) &#123;</span><br><span class="line">                res.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray(); !!!!!!!!!!!!!!!!!!!</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        find(node.left);</span><br><span class="line">        map.put(node.val, map.getOrDefault(node.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        find(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">双指针：</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resList;</span><br><span class="line">    <span class="type">int</span> maxCount;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    TreeNode pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        findMode1(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()]; !!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resList.size(); i++) &#123;</span><br><span class="line">            res[i] = resList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findMode1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findMode1(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="comment">// 计数</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span> || rootValue != pre.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新结果以及maxCount</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            resList.clear();</span><br><span class="line">            resList.add(rootValue);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            resList.add(rootValue);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        findMode1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">哈希表：</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line"><span class="comment">// 获得频率 Map</span></span><br><span class="line">searchBST(root, map);</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">.sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">list.add(mapList.get(<span class="number">0</span>).getKey());</span><br><span class="line"><span class="comment">// 把频率最高的加入 list</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; mapList.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mapList.get(i).getValue() == mapList.get(i - <span class="number">1</span>).getValue()) &#123;</span><br><span class="line">list.add(mapList.get(i).getKey());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">searchBST</span><span class="params">(TreeNode curr, Map&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (curr == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">map.put(curr.val, map.getOrDefault(curr.val, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">searchBST(curr.left, map);</span><br><span class="line">searchBST(curr.right, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h3><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md</a></p><p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p><ul><li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li><li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li><li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li></ul><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root == p || root == q) return root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left , p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right , p, q);</span><br><span class="line">        if(left == null &amp;&amp; right == null) return null;</span><br><span class="line">        if(left == null &amp;&amp; right != null) return right;</span><br><span class="line">        if(left != null &amp;&amp; right == null) return left;</span><br><span class="line">        if(left != null &amp;&amp; right != null) return root;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong> 即情况一：</p><p><a href="https://camo.githubusercontent.com/6367d6efb943d22cf2c56eff5b51a61acaa0be871f516c7e212392fc13fda234/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303232303932323137333530322e706e67"><img src="https://camo.githubusercontent.com/6367d6efb943d22cf2c56eff5b51a61acaa0be871f516c7e212392fc13fda234/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303232303932323137333530322e706e67" alt="img"></a></p><p>判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</p><p>那么有录友可能疑惑，会不会左子树 遇到q 返回，右子树也遇到q返回，这样并没有找到 q 和p的最近祖先。</p><p>这么想的录友，要审题了，题目强调：<strong>二叉树节点数值是不重复的，而且一定存在 q 和 p</strong>。</p><p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong> 情况二：</p><p>其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。</p><p>因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。</p><p>这一点是很多录友容易忽略的</p><p>if dont understand here, check the video.</p><p><a href="https://camo.githubusercontent.com/a7f086d812abae6ade94b964eca77c57de3f527cdc90403dc6d52fb7761efebd/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303230343135313132353834342e706e67"><img src="https://camo.githubusercontent.com/a7f086d812abae6ade94b964eca77c57de3f527cdc90403dc6d52fb7761efebd/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303230343135313132353834342e706e67" alt="236.二叉树的最近公共祖先1"></a></p><p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p><p>这里也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p><p>那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空</p><p><strong>那么我给大家归纳如下三点</strong>：</p><ol><li>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。</li><li>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</li><li>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</li></ol><p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p><p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p><h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root == null ) return null;</span><br><span class="line">        if(root.val &gt; p .val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">            if(left != null) return left;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val &lt; p .val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">            if(right != null) return right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>you can also use the method in 236 as well.</p><p>在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p><p>搜索一条边的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (递归函数(root-&gt;left)) return ;</span><br><span class="line">if (递归函数(root-&gt;right)) return ;</span><br></pre></td></tr></table></figure><p>搜索整个树写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure><p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p><h3 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></h3><p>Medium</p><p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p><p><strong>Notice</strong> that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3], val = 5</span><br><span class="line">Output: [4,2,7,1,3,5]</span><br><span class="line">Explanation: Another accepted tree is:</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">rep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://camo.githubusercontent.com/17ca42400b7f5cc14a6e75b8ba9208163418dbf0f740bc126a78754ce745054a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3730312e2545342542412538432545352538462538392545362539302539432545372542342541322545362541302539312545342542382541442545372539412538342545362538462539322545352538352541352545362539332538442545342542442539432e676966"><img src="https://camo.githubusercontent.com/17ca42400b7f5cc14a6e75b8ba9208163418dbf0f740bc126a78754ce745054a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3730312e2545342542412538432545352538462538392545362539302539432545372542342541322545362541302539312545342542382541442545372539412538342545362538462539322545352538352541352545362539332538442545342542442539432e676966" alt="701.二叉搜索树中的插入操作"></a></p><p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p><p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p><p>接下来就是遍历二叉搜索树的过程了。</p></li><li><p>确定终止条件</p></li></ul><p>终止条件就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) &#123;</span><br><span class="line">    TreeNode* node = new TreeNode(val);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p><ul><li>确定单层递归的逻辑</li></ul><p>此时要明确，需要遍历整棵树么？</p><p>别忘了这是搜索树，遍历整棵搜索树简直是对搜索树的侮辱，哈哈。</p><p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">return root;</span><br></pre></td></tr></table></figure><p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</strong>。</p><h3 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">Output: [5,4,6,2,null,null,7]</span><br><span class="line">Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the above BST.</span><br><span class="line">Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#x27;s also accepted.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root.val == key)&#123;</span><br><span class="line">            </span><br><span class="line">            if(root.left == null &amp;&amp; root.right == null)&#123;</span><br><span class="line">                return null;   // not return </span><br><span class="line">            &#125;</span><br><span class="line">            if(root.right != null &amp;&amp; root.left == null )&#123;</span><br><span class="line">                return root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(root.left != null &amp;&amp; root.right == null )&#123;</span><br><span class="line">                return root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if(root.left != null &amp;&amp; root.right != null)&#123;</span><br><span class="line">                // !!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">                TreeNode temp = root.right;</span><br><span class="line">                while(temp.left != null)&#123;</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.left = root.left;</span><br><span class="line">                return root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            if(key &lt; root.val)</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">            if(key &gt; root.val)</span><br><span class="line">            root.right = deleteNode(root.right, key); //右子树接住删除完节点的子树 </span><br><span class="line">            return root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a><a href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a></h3><p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p><p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,0,2], low = 1, high = 2</span><br><span class="line">Output: [1,null,2]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root.val &lt; low)&#123; // abandone left tree</span><br><span class="line">            TreeNode right = trimBST(root.right, low, high);</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val &gt; high)&#123; // abandone right tree</span><br><span class="line">            TreeNode left = trimBST(root.left, low, high);</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a></h3><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a</em> </p><p>*<strong>height-balanced*</strong></p><p> <em>binary search tree</em>. </p><p><strong>Example:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> create(nums, <span class="number">0</span> , nums.length  ); <span class="comment">// 左闭右开 Closed on the left, open on the right</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">create</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;   <span class="comment">// it&#x27;s &gt;= not &gt;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = create(nums, left, mid );</span><br><span class="line">        root.right = create(nums, mid + <span class="number">1</span>, right  );</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h3><p>Medium</p><p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p><p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p>​                                                                          <strong>!!! right mid left !!!</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode pre = new TreeNode(0);</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        root.val += pre.val;</span><br><span class="line">        </span><br><span class="line">        pre.val = root.val;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrong version:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode pre = new TreeNode(0);</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        root.val += pre.val;</span><br><span class="line">        convertBST(root.left); //</span><br><span class="line">        pre.val = root.val;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="/2023/07/21/LeetCode/DP/"/>
      <url>/2023/07/21/LeetCode/DP/</url>
      
        <content type="html"><![CDATA[<h1 id="DP🌼"><a href="#DP🌼" class="headerlink" title="DP🌼"></a>DP🌼</h1><h2 id="steps"><a href="#steps" class="headerlink" title="steps:"></a>steps:</h2><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>我在这里做一个总结：</p><p>求组合数：<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a> 求排列数：<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a> 求最小数：<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p><h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode:"></a>Leetcode:</h2><h3 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a><a href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a></h3><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2), for n &gt; 1.</span><br></pre></td></tr></table></figure><p>Given <code>n</code>, calculate <code>F(n)</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fib(int n) &#123;</span><br><span class="line">        if( n &lt; 2)</span><br><span class="line">            return n;</span><br><span class="line">        int[] dp = new int[ n + 1];  </span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt; dp.length;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><a href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></h2><p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure><p>这道题的推导公式是这样得来的：<br>在到达第n层的上一步，我们只有两个选择，走一步，或者走两步。<br>如果是走一步，我们需要先通过 f(n-1)种方式到达 n-1 层<br>如果是走两步， 我们需要通过 f(n-2)种方式到达第 n - 2 层<br>所以综上有 f(n) &#x3D; f(n-2) + f(n-1)</p><p>it’s actually Fibonacci Number</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">    if(n &lt;= 2 )&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">     int[] dp = new int[n];</span><br><span class="line">     dp[0] = 1;</span><br><span class="line">     dp[1] = 2;</span><br><span class="line">     for(int i = 2; i &lt; dp.length; i++)&#123;</span><br><span class="line">         dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">     &#125;</span><br><span class="line">     return dp[n - 1];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0-1 unbounded knapsack </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        int[] nums = &#123;1, 2&#125;;</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for(int j = 0; j &lt; n+1; j++)&#123;</span><br><span class="line">            for(int i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">                if(j &gt;= nums[i])</span><br><span class="line">                    dp[j] = dp[j]+dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746. Min Cost Climbing Stairs"></a><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">746. Min Cost Climbing Stairs</a></h3><p>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>ith</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p><p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p><p>Return <em>the minimum cost to reach the top of the floor</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [10,15,20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: You will start at index 1.</span><br><span class="line">- Pay 15 and climb two steps to reach the top.</span><br><span class="line">The total cost is 15.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        if(cost.length == 1)&#123;</span><br><span class="line">            return cost[0];</span><br><span class="line">        &#125;else if(cost.length == 2)&#123;</span><br><span class="line">            return Math.min(cost[0],cost[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[cost.length + 1];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for(int i = 2; i &lt; dp.length; i ++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2]+cost[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[dp.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h3><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// mine: </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] d = new int[m][n];</span><br><span class="line">        for(int x= 0; x &lt; m; x++)&#123;</span><br><span class="line">            for(int y = 0; y &lt; n; y++)&#123;</span><br><span class="line">            ----------</span><br><span class="line">                if( y == 0)&#123;</span><br><span class="line">                    if(x==0)&#123;</span><br><span class="line">                        d[x][y] = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        d[x][y] = d[x-1][y];</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;else if(x == 0)&#123;</span><br><span class="line">                     if(y==0)&#123;</span><br><span class="line">                        d[x][y] = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        d[x][y] = d[x][y-1];</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    d[x][y] = d[x][y-1]+d[x-1][y];</span><br><span class="line">                &#125;</span><br><span class="line">            ---------    </span><br><span class="line">                </span><br><span class="line">                =========&gt; optimize:</span><br><span class="line">                if( y == 0)&#123;</span><br><span class="line">                    d[x][y] = 1;</span><br><span class="line">                &#125;else if(x == 0)&#123;</span><br><span class="line">                     d[x][y] = 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    d[x][y] = d[x][y-1]+d[x-1][y];</span><br><span class="line">                &#125;</span><br><span class="line">                ==========    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return d[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63.Unique Paths II"></a>63.Unique Paths II</h3><p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p><p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p><p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p>The testcases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// mine:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];</span><br><span class="line">        if(obstacleGrid[0][0] ==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; obstacleGrid.length; i++)&#123;</span><br><span class="line">            if(obstacleGrid[i][0] == 1)&#123;</span><br><span class="line">                 while( i &lt; obstacleGrid.length)&#123;</span><br><span class="line">                    dp[i][0] = 0;</span><br><span class="line">                    i++;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; obstacleGrid[0].length; i++)&#123;</span><br><span class="line">            if(obstacleGrid[0][i] == 1)&#123;</span><br><span class="line">                while( i &lt; obstacleGrid[0].length)&#123;</span><br><span class="line">                    dp[0][i] = 0;</span><br><span class="line">                    i++;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[0][i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int x = 1; x &lt; obstacleGrid.length; x++)&#123;</span><br><span class="line">            for(int y = 1; y &lt; obstacleGrid[x].length; y++)&#123;</span><br><span class="line">                if(obstacleGrid[x][y] == 1)&#123;</span><br><span class="line">                    dp[x][y] = 0;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[x][y] = dp[x-1][y] +dp[x][y-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//leetcodemaster:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.length;</span><br><span class="line">        int n = obstacleGrid[0].length;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">        //如果在起点或终点出现了障碍，直接返回0</span><br><span class="line">        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) &#123;  // ！！！这样写非常neat</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) &#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In Java, when you create a new array of certain data type (e.g., int[], double[], char[], etc.), the elements in the array are initialized to default values based on the data type. For numeric data types (e.g., int, double, float, etc.), the default value is 0. </p><p>so actually </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; obstacleGrid.length; i++)&#123;</span><br><span class="line">    if(obstacleGrid[i][0] == 1)&#123;</span><br><span class="line">         while( i &lt; obstacleGrid.length)&#123;</span><br><span class="line">            dp[i][0] = 0;    // this is unecessary</span><br><span class="line">            i++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a><a href="https://leetcode.com/problems/integer-break/">343. Integer Break</a></h3><p>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p><p>Return <em>the maximum product you can get</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 2 = 1 + 1, 1 × 1 = 1.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[2] =  1;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int j = 1; j &lt; i; j++)&#123;</span><br><span class="line">            </span><br><span class="line">            /*   </span><br><span class="line">        ======= optimize: ========</span><br><span class="line">             for(int j = 1; j &lt;= i-j; j++) &#123;</span><br><span class="line">             // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，</span><br><span class="line">        */</span><br><span class="line">            </span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(dp[i-j]*j,j*(i-j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this is important :</strong><br>dp[i] &#x3D; Math.max(dp[i], Math.max(dp[i-j]<em>j,</em> j*(i-j)  ));</p><p>dp[i-j]*j -&gt; 至少是三个integer相乘</p><p>j*(i-j) -&gt; 两个integer相乘</p><h3 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></h3><p>Given an integer <code>n</code>, return *the number of structurally unique **BST’*<em>s (binary search trees) which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        if(n &lt; 3)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2 ; i &lt; dp.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i-j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md</a></p><p>dp[0] &#x3D; 1;</p><p>dp[1] &#x3D;1,</p><p>dp[2] &#x3D; 2;</p><p>dp[3] &#x3D; dp[0] ( Case -&gt; left tree has 0 node) * dp[2] (right tree has two nodes)+ dp[1] * dp[1] +  dp[2] * dp[0] </p><h2 id="0-x2F-1-Knapsack-problem"><a href="#0-x2F-1-Knapsack-problem" class="headerlink" title="0&#x2F;1 Knapsack problem:"></a>0&#x2F;1 Knapsack problem:</h2><ol><li><p>装满背包的最大价值是多少</p></li><li><p>能不能装满一个背包</p></li><li><p>多少种方式能把背包装满</p></li></ol><h3 id="0-x2F-1-Knapsack-Problem-two-dimenstion-array"><a href="#0-x2F-1-Knapsack-Problem-two-dimenstion-array" class="headerlink" title="0&#x2F;1 Knapsack Problem ( two dimenstion array)"></a>0&#x2F;1 Knapsack Problem ( two dimenstion array)</h3><p>确定递推公式:</p><p>dp [i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>代码初始化如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0 ; j &lt; weight[0]; j++) &#123;  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br><span class="line">    dp[0][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">// 正序遍历</span><br><span class="line">for (int j = weight[0]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[0][j] = value[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class BagProblem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] weight = &#123;1,3,4&#125;;</span><br><span class="line">        int[] value = &#123;15,20,30&#125;;</span><br><span class="line">        int bagSize = 4;</span><br><span class="line">        testWeightBagProblem(weight,value,bagSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize)&#123;</span><br><span class="line"></span><br><span class="line">        // 创建dp数组</span><br><span class="line">        int goods = weight.length;  // 获取物品的数量</span><br><span class="line">        int[][] dp = new int[goods][bagSize + 1];</span><br><span class="line"></span><br><span class="line">        // 初始化dp数组</span><br><span class="line">        // 创建数组后，其中默认的值就是0</span><br><span class="line">        for (int j = weight[0]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[0][j] = value[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 填充dp数组  两层for循环是可以颠倒的</span><br><span class="line">        for (int i = 1; i &lt; weight.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                if (j &lt; weight[i]) &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的</span><br><span class="line">                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值</span><br><span class="line">                     */</span><br><span class="line">                    dp[i][j] = dp[i-1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 当前背包的容量可以放下物品i</span><br><span class="line">                     * 那么此时分两种情况：</span><br><span class="line">                     *    1、不放物品i</span><br><span class="line">                     *    2、放物品i</span><br><span class="line">                     * 比较这两种情况下，哪种背包中物品的最大价值最大</span><br><span class="line">                     */</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 打印dp数组</span><br><span class="line">        for (int i = 0; i &lt; goods; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/3e93e2608c9e09b34e969e34ef7cf52def30f02923b91576c7c5599843361412/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f3230323130313130313033323132342e706e67" alt="动态规划-背包问题5"></p><p><strong>because dp[i ] [j] is caculated from dp [i- 1 ] [ j ],dp[i-1 ]  [j-1 ], so 两层for循环是可以颠倒的</strong></p><h3 id="0-x2F-1-Knapsack-Problem-one-dimenstion-array"><a href="#0-x2F-1-Knapsack-Problem-one-dimenstion-array" class="headerlink" title="0&#x2F;1 Knapsack Problem ( one dimenstion array)"></a>0&#x2F;1 Knapsack Problem ( one dimenstion array)</h3><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><ol><li>一维dp数组的递推公式</li></ol><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p><ol><li><h4 id="一维dp数组如何初始化"><a href="#一维dp数组如何初始化" class="headerlink" title="一维dp数组如何初始化"></a><strong>一维dp数组如何初始化</strong></h4></li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: red"><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">************ one dimension: ********* </span><br><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ********* two  dimention: *********</span><br><span class="line"> for (int i = 1; i &lt; weight.length; i++) &#123;</span><br><span class="line"> for (int j = 1; j &lt;= bagSize; j++) &#123;</span><br><span class="line"> if (j &lt; weight[i]) &#123;</span><br><span class="line"> dp[i][j] = dp[i-1][j];</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p><p>如果正序遍历</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>所以从后往前循环，<span style="color: red">每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</span></p><p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p><p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！所以倒叙正序都可以。</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p><p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p><p>不可以！</p><p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p><p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p><p>（这里如果读不懂，就再回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p><p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">    int bagWight = 4;</span><br><span class="line">    testWeightBagProblem(weight, value, bagWight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight)&#123;</span><br><span class="line">    int wLen = weight.length;</span><br><span class="line">    //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span><br><span class="line">    int[] dp = new int[bagWeight + 1];</span><br><span class="line">    //遍历顺序：先遍历物品，再遍历背包容量</span><br><span class="line">    for (int i = 0; i &lt; wLen; i++)&#123;</span><br><span class="line">        for (int j = bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //打印dp数组</span><br><span class="line">    for (int j = 0; j &lt;= bagWeight; j++)&#123;</span><br><span class="line">        System.out.print(dp[j] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></h3><p>Given an integer array <code>nums</code>, return <code>true</code> <em>if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure><p>my version(one dimension array):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum % 2 != 0) return false;</span><br><span class="line">        int half = sum/2;</span><br><span class="line">        int[] dp = new int[half+1]; // notice here is half+1 not half</span><br><span class="line">        for(int i = 0 ; i &lt; nums.length; i++ )&#123;</span><br><span class="line">            for(int j = half; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(dp[half] == half)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组版本（易于理解）leetmaster：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num[] = &#123;1,5,11,5&#125;;</span><br><span class="line">        canPartition(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        // 题目已经说非空数组，可以不做非空判断</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        // 特判：如果是奇数，就不符合要求</span><br><span class="line">        if ((sum %2 ) != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int target = sum / 2; //目标背包容量</span><br><span class="line">        // 创建二维状态数组，行：物品索引，列：容量（包括 0）</span><br><span class="line">        /*</span><br><span class="line">        dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数</span><br><span class="line">          每个数只能用一次，使得这些数的和恰好等于 j。</span><br><span class="line">        */</span><br><span class="line">        boolean[][] dp = new boolean[len][target + 1];</span><br><span class="line"></span><br><span class="line">        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满  （这里的dp[][]数组的含义就是“恰好”，所以就算容积比它大的也不要）</span><br><span class="line">        if (nums[0] &lt;= target) &#123;</span><br><span class="line">            dp[0][nums[0]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 再填表格后面几行</span><br><span class="line">        //外层遍历物品</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            //内层遍历背包</span><br><span class="line">            for (int j = 0; j &lt;= target; j++) &#123;</span><br><span class="line">                // 直接从上一行先把结果抄下来，然后再修正</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line"></span><br><span class="line">                //如果某个物品单独的重量恰好就等于背包的重量，那么也是满足dp数组的定义的</span><br><span class="line">                if (nums[i] == j) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果某个物品的重量小于j，那就可以看该物品是否放入背包</span><br><span class="line">                //dp[i - 1][j]表示该物品不放入背包，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；</span><br><span class="line">                //dp[i - 1][j - nums[i]]表示该物品放入背包。如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。</span><br><span class="line">                if (nums[i] &lt; j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= target; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//dp数组的打印结果</span><br><span class="line">false true false false false false false false false false false false </span><br><span class="line">false true false false false true true false false false false false </span><br><span class="line">false true false false false true true false false false false true </span><br><span class="line">false true false false false true true false false false true true </span><br></pre></td></tr></table></figure><p>my try:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum % 2 != 0) return false;</span><br><span class="line">        int half = sum/2;</span><br><span class="line">        int[][] dp = new int[half+1][nums.length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int j = nums[0]; j &lt;= half; j++) &#123;</span><br><span class="line">            dp[j][0] = nums[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1 ; i &lt; nums.length; i++ )&#123;</span><br><span class="line">            for(int j = 1; j &lt;= half; j++)&#123;</span><br><span class="line">                if(j &gt; nums[i])&#123;</span><br><span class="line">                dp[j][i] = Math.max(dp[j][i-1], dp[j - nums[i]][i-1] + nums[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[j][i] = dp[j][i-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(dp[half][nums.length -1] == half)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1049-Last-Stone-Weight-II"><a href="#1049-Last-Stone-Weight-II" class="headerlink" title="1049. Last Stone Weight II"></a><a href="https://leetcode.com/problems/last-stone-weight-ii/">1049. Last Stone Weight II</a></h3><p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>ith</code> stone.</p><p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p><ul><li>If <code>x == y</code>, both stones are destroyed, and</li><li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.</li></ul><p>At the end of the game, there is <strong>at most one</strong> stone left.</p><p>Return <em>the smallest possible weight of the left stone</em>. If there are no stones left, return <code>0</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,</span><br><span class="line">we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,</span><br><span class="line">we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,</span><br><span class="line">we can combine 1 and 1 to get 0, so the array converts to [1], then that&#x27;s the optimal value.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [31,26,33,21,40]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++)&#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[half+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> half; j &gt;= stones[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j - stones[i]]+stones[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> dp[half] ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span>  sum - dp[half];</span><br><span class="line">        <span class="keyword">return</span> Math.abs(part1 - part2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a href="https://leetcode.com/problems/target-sum/">494. Target Sum</a></h3><ul><li><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">纯 0 - 1 背包</a> 是求 给定背包容量 装满背包 的最大价值是多少。</li><li><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">416. 分割等和子集</a> 是求 给定背包容量，能不能装满这个背包。</li><li><a href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">1049. 最后一块石头的重量 II</a> 是求 给定背包容量，尽可能装，最多能装多少</li><li><a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">494. 目标和</a> 是求 给定背包容量，装满背包有多少种方法。</li><li>本题是求 给定背包容量，装满背包最多有多少个物品。</li></ul><p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p><p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p><ul><li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li></ul><p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,1,1], target = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p>dp[j] ：装满容量为j的背包有dp[j]种方法</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p><ol><li>含义：dp【i】【j】：从下标为【0…i】的物品里任取，填满j这么⼤容积的包，有dp【i】【j】种⽅法</li><li>递推式：dp【i】【j】 &#x3D; dp【i-1】【j】 + dp【i-1】[j-nums【i】]<br>           dp【i-1】【j】是不将物品i放入背包的方式数，dp【i-1】[j-nums【i】]是将物品i放入背包的方式数</li><li>初始化：dp【0】【0】 &#x3D; 1 表示装满容量为0的背包，有1种⽅法，就是装0件物品。（区别于原始的背包问题，它求的是最大价值，所以dp[0 】[0]&#x3D;0因为没有东西所以总价值是0）<br>          如果nums【0】在范围内的话，dp【0】[nums【0】] &#x3D; 1<br>           其他全为0</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target)&#123;       </span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i=0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if((target + sum)%2 != 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; Math.abs(target))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int plus = (target + sum)/2;</span><br><span class="line"></span><br><span class="line">        int[][] dp = new int[plus + 1][nums.length];</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt;= plus; j++) &#123;</span><br><span class="line">            if(nums[0] == j) &#123;</span><br><span class="line">                dp[j][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int numZeros = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(nums[i] == 0) &#123;</span><br><span class="line">                numZeros++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[0][i] = (int) Math.pow(2, numZeros);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         for(int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">             for(int j = 1; j &lt;= plus; j++)&#123;</span><br><span class="line">                if(nums[i] &lt;= j)&#123;</span><br><span class="line">                 dp[j][i] = dp[j - nums[i]][i-1] + dp[j][i-1];&#125;else&#123;</span><br><span class="line">                dp[j][i] = dp[j][i-1];</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return dp[plus][nums.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a>474. Ones and Zeroes</h3><p>Medium</p><p>Companies</p><p>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p><p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong></em> <code>m</code> <code>0</code><em>‘s and</em> <code>n</code> <code>1</code><em>‘s in the subset</em>.</p><p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The largest subset with at most 5 0&#x27;s and 3 1&#x27;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.</span><br><span class="line">Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.</span><br><span class="line">&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#x27;s, greater than the maximum of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The largest subset is &#123;&quot;0&quot;, &quot;1&quot;&#125;, so the answer is 2.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// it&#x27;s actually one dimmension solution</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line">        </span><br><span class="line">        int[][] dp= new int[m+1][n+1]; // notice here, [m+1][n+1]</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line"></span><br><span class="line">        for( String str: strs)&#123;</span><br><span class="line">            int one = 0;</span><br><span class="line">            int zero = 0;</span><br><span class="line">            for(char ch: str.toCharArray())&#123;</span><br><span class="line">                if(ch == &#x27;0&#x27;) zero++;</span><br><span class="line">                if(ch == &#x27;1&#x27;) one++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = m; i &gt;= zero; i--)&#123;</span><br><span class="line">                for(int j = n; j &gt;= one; j--)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[i-zero][j-one]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unbounded-knapsack-problem"><a href="#unbounded-knapsack-problem" class="headerlink" title="unbounded knapsack problem"></a>unbounded knapsack problem</h2><p>遍历顺序从小到大就可以无限次选同一个物品</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//先遍历物品，再遍历背包</span><br><span class="line">private static void testCompletePack()&#123;</span><br><span class="line">    int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">    int bagWeight = 4;</span><br><span class="line">    int[] dp = new int[bagWeight + 1];</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i++)&#123; // 遍历物品</span><br><span class="line">        for (int j = weight[i]; j &lt;= bagWeight; j++)&#123; // 遍历背包容量</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int maxValue : dp)&#123;</span><br><span class="line">        System.out.println(maxValue + &quot;   &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//先遍历背包，再遍历物品</span><br><span class="line">private static void testCompletePackAnotherWay()&#123;</span><br><span class="line">    int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">    int bagWeight = 4;</span><br><span class="line">    int[] dp = new int[bagWeight + 1];</span><br><span class="line">    for (int i = 1; i &lt;= bagWeight; i++)&#123; // 遍历背包容量</span><br><span class="line">        for (int j = 0; j &lt; weight.length; j++)&#123; // 遍历物品</span><br><span class="line">            if (i - weight[j] &gt;= 0)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int maxValue : dp)&#123;</span><br><span class="line">        System.out.println(maxValue + &quot;   &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="518-Coin-Change-II"><a href="#518-Coin-Change-II" class="headerlink" title="518. Coin Change II"></a><a href="https://leetcode.com/problems/coin-change-ii/">518. Coin Change II</a></h3><ol><li>dp数组如何初始化</li></ol><p>首先dp[0]一定要为1，dp[0] &#x3D; 1是 递归公式的基础。如果dp[0] &#x3D; 0 的话，后面所有推导出来的值都是0了。</p><p>那么 dp[0] &#x3D; 1 有没有含义，其实既可以说 凑成总金额0的货币组合数为1，也可以说 凑成总金额0的货币组合数为0，好像都没有毛病。</p><p>但题目描述中，也没明确说 amount &#x3D; 0 的情况，结果应该是多少。</p><p>这里我认为题目描述还是要说明一下，因为后台测试数据是默认，amount &#x3D; 0 的情况，组合数为1的。</p><p>下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]</p><p>dp[0]&#x3D;1还说明了一种情况：如果正好选了coins[i]后，也就是j-coins[i] &#x3D;&#x3D; 0的情况表示这个硬币刚好能选，此时dp[0]为1表示只选coins[i]存在这样的一种选法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp = new int[amount+1];</span><br><span class="line">        dp[0] =1;</span><br><span class="line">        for(int i = 0; i &lt; coins.length; i++)&#123;</span><br><span class="line">            for(int j = coins[i]; j &lt;= amount; j++)&#123;</span><br><span class="line">                dp[j] = dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a></h3><p>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em> <code>target</code>.</p><p>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3], target = 4</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">Note that different sequences are counted as different combinations.</span><br></pre></td></tr></table></figure><p><span style=" color: red"><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</span></p><p><span style=" color: red"><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</span></p><p>logic one: <span style=" color: brown">就是说先遍历物品的时候相当于是先把这个物品放进去了然后再看其他的能不能放进去，所以不会出现逆序，先遍历背包相当于是用每个大小的背包看看把每一个物品都放进去一次再看别的物品能不能放进去，所以可以有逆序</span></p><p>logic 2:  <span style=" color: brown">关于组合和排列的问题还是有些不解。以下仅为自己的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins【1】，在内层循环遍历背包时，随着背包不断增加，coins【1】可以重复被添加进来，而由于外层循环固定了，因此coins【2】只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins【i+1】只能在coins【i】之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins【2】的基础上还能再添加coins【1】的情况，那么就有了coins【1】在coins【2】之后的情况了。</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[] dp = new int[target + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for(int j = 0; j &lt;= target; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i = 0; i &lt; nums.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] &lt;= j)&#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j-nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></h3><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p>You may assume that you have an infinite number of each kind of coin.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1,2,5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>The check <code>if(dp[j-coins[i]]!= Integer.MAX_VALUE)</code> is necessary to ensure that we only consider valid subproblem solutions. If <code>dp[j - coins[i]]</code> is equal to <code>Integer.MAX_VALUE</code>, it means that there is no valid solution for the amount <code>j - coins[i]</code>, and hence, we cannot use the current coin denomination to make up the amount <code>j</code>.</p><p>Without this check, the algorithm might end up considering invalid solutions and could produce incorrect results. This check ensures that we only consider valid intermediate solutions to compute the fewest number of coins for the given <code>amount</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int coinChange(int[] coins, int amount)&#123; </span><br><span class="line"></span><br><span class="line">        int[] dp = new int[amount + 1];</span><br><span class="line">        for(int j = 0; j &lt;= amount; j++)&#123;</span><br><span class="line">            dp[j] = Integer.MAX_VALUE; //important!</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for(int i =0; i &lt; coins.length; i++)&#123;</span><br><span class="line">            for(int j = coins[i]; j &lt; amount+1; j++)&#123;</span><br><span class="line">                if(dp[j-coins[i]]!= Integer.MAX_VALUE) //important!!</span><br><span class="line">                //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[amount]&lt;0 || dp[amount] == Integer.MAX_VALUE)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139.Word Break"></a>139.Word Break</h3><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure><ol><li>确定遍历顺序</li></ol><p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p><p>还要讨论两层for循环的前后顺序。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>我在这里做一个总结：</p><p>求组合数：<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a> 求排列数：<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a> 求最小数：<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p><p>而本题其实我们求的是排列数，为什么呢。 拿 s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] 举例。</p><p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p><p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是强调物品之间顺序。</p><p>所以说，<span style="color: red">本题一定是 先遍历 背包，再遍历物品。</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        int bagSize =  s.length() + 1;</span><br><span class="line">        boolean[] dp = new boolean[bagSize];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">       </span><br><span class="line">            for(int j = 0; j &lt; bagSize; j++)&#123; // bag</span><br><span class="line">                 for( String word : wordDict)&#123; // thing</span><br><span class="line">                    if(j &gt;= word.length() &amp;&amp; dp[j - word.length()] &amp;&amp; word.equals(s.substring(j-word.length(),j)))&#123;//important</span><br><span class="line">                        dp[j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1)  return nums[0];</span><br><span class="line"></span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = Math.max(nums[0], nums[1]);  //important</span><br><span class="line">        </span><br><span class="line">        for(int i = 2; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-1], dp[i-2]+ nums[i]); //important</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[nums.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a><a href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure><p>这道题目和<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>是差不多的，唯一区别就是成环了。</p><p>对于一个数组，成环的话主要有如下三种情况：</p><ul><li><p>情况一：考虑不包含首尾元素</p></li><li><p>情况二：考虑包含首元素，不包含尾元素</p></li></ul><p><a href="https://camo.githubusercontent.com/7b9cd836f98b01ea8a146920e53015d909783ef8c4ceb066657e2f90f00915bf/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303832313337342d32303233303331303133343030333936312e6a7067"><img src="https://camo.githubusercontent.com/7b9cd836f98b01ea8a146920e53015d909783ef8c4ceb066657e2f90f00915bf/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303832313337342d32303233303331303133343030333936312e6a7067" alt="213.打家劫舍II1"></a></p><ul><li>情况三：考虑包含尾元素，不包含首元素</li></ul><p><a href="https://camo.githubusercontent.com/3a5cfd80c966a0c512d8b4b57c51403b8982c7a4be89e5e994fb08d17fa19c94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303834323439312d32303233303331303133343030383133332e6a7067"><img src="https://camo.githubusercontent.com/3a5cfd80c966a0c512d8b4b57c51403b8982c7a4be89e5e994fb08d17fa19c94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303834323439312d32303233303331303133343030383133332e6a7067" alt="213.打家劫舍II2"></a></p><p>**注意我这里用的是”考虑”**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。</p><p><strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p><p>分析到这里，本题其实比较简单了。 剩下的和<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>就是一样的了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int robRange(int[] nums, int start, int end)&#123;</span><br><span class="line">        int[] dp = new int[end - start + 1];</span><br><span class="line">        dp[0] = nums[start];</span><br><span class="line">        dp[1] = Math.max(nums[start] , nums[start+1]);</span><br><span class="line">        for(int i = 2; i &lt;= end - start ; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i+start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[end - start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1) return nums[0];</span><br><span class="line">        if(nums.length == 2) return Math.max(nums[0] , nums[1]);</span><br><span class="line">        int a = robRange(nums, 1 , nums.length - 1);</span><br><span class="line">        int b = robRange(nums, 0 , nums.length - 2);</span><br><span class="line"></span><br><span class="line">        return Math.max(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a href="https://leetcode.com/problems/house-robber-iii/">337. House Robber III</a></h3><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p><p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p><p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,2,3,null,3,null,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AWS</title>
      <link href="/2023/07/19/SoftwareDevelopment/AWS/"/>
      <url>/2023/07/19/SoftwareDevelopment/AWS/</url>
      
        <content type="html"><![CDATA[<h1 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h1><p>deploy(elastic beanstalk):</p><p><a href="https://www.freecodecamp.org/news/how-to-use-elastic-beanstalk-to-deploy-node-js-app/">https://www.freecodecamp.org/news/how-to-use-elastic-beanstalk-to-deploy-node-js-app/</a></p><p>RDS:</p><p><a href="https://aws.amazon.com/getting-started/hands-on/create-mysql-db/">https://aws.amazon.com/getting-started/hands-on/create-mysql-db/</a></p><p>downald mysql on ec2:</p><p><a href="https://www.youtube.com/watch?v=0Teg0Kv8Gak">https://www.youtube.com/watch?v=0Teg0Kv8Gak</a></p><p><a href="https://awswithatiq.com/how-to-install-mysql-on-amazon-linux-2023-fedora-version/">https://awswithatiq.com/how-to-install-mysql-on-amazon-linux-2023-fedora-version/</a></p><p>open phpmyadmin on ec2: (didn’t actually do this)</p><p><a href="https://www.youtube.com/watch?v=HSmu7kmv_ng">https://www.youtube.com/watch?v=HSmu7kmv_ng</a></p><p><a href="https://docs.phpmyadmin.net/en/latest/setup.html#manually-creating-the-file">https://docs.phpmyadmin.net/en/latest/setup.html#manually-creating-the-file</a></p><p><a href="https://www.mysql.com/products/workbench/">https://www.mysql.com/products/workbench/</a></p>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stack &amp; Queuew</title>
      <link href="/2023/07/07/LeetCode/stack_queue/"/>
      <url>/2023/07/07/LeetCode/stack_queue/</url>
      
        <content type="html"><![CDATA[<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><p><img src="https://camo.githubusercontent.com/8131417f29220f0009747906e7aeb4db4670072a83d21e05bcecb42dd6fd196e/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303130343233353334363536332e706e67" alt="栈与队列理论1"></p><p>The <strong>queue</strong> data structure follows the <strong>FIFO</strong> (First In First Out) principle.</p><p>A <strong>stack</strong> follows the <strong>LIFO</strong> (Last In First Out) principle, i.e., the element inserted at the last is the first element to come out.</p><h2 id="stack"><a href="#stack" class="headerlink" title="stack:"></a>stack:</h2><p>* </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);</span><br><span class="line">stack.peek();  // 返回 1</span><br><span class="line">stack.pop();   // 返回 1</span><br><span class="line">stack.empty(); // 返回 false</span><br></pre></td></tr></table></figure><ul><li>stack.push()     stack.peek()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])</span><br><span class="line">   &#123;</span><br><span class="line">       // Creating an empty Stack</span><br><span class="line">       Stack&lt;String&gt; stack = new Stack&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">       // Use push() to add elements into the Stack</span><br><span class="line">       stack.push(&quot;Welcome&quot;);</span><br><span class="line">       stack.push(&quot;To&quot;);</span><br><span class="line">       stack.push(&quot;Geeks&quot;);</span><br><span class="line">       stack.push(&quot;For&quot;);</span><br><span class="line">       stack.push(&quot;Geeks&quot;);</span><br><span class="line"></span><br><span class="line">       // Displaying the Stack</span><br><span class="line">       System.out.println(&quot;Initial Stack: &quot; + stack);</span><br><span class="line"></span><br><span class="line">       // Fetching the element at the head of the Stack</span><br><span class="line">       System.out.println(&quot;The element at the top of the&quot;</span><br><span class="line">                          + &quot; stack is: &quot; + stack.peek());</span><br><span class="line"></span><br><span class="line">       // Displaying the Stack after the Operation</span><br><span class="line">       System.out.println(&quot;Final Stack: &quot; + stack);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Initial Stack: [Welcome, To, Geeks, For, Geeks]</span><br><span class="line">The element at the top of the stack is: Geeks</span><br><span class="line">Final Stack: [Welcome, To, Geeks, For, Geeks]</span><br></pre></td></tr></table></figure><ul><li>stack.pop()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class StackDemo &#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        // Creating an empty Stack</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">        // Use add() method to add elements</span><br><span class="line">        stack.push(10);</span><br><span class="line">        stack.push(15);</span><br><span class="line">        stack.push(30);</span><br><span class="line">        stack.push(20);</span><br><span class="line">        stack.push(5);</span><br><span class="line"> </span><br><span class="line">        // Displaying the Stack</span><br><span class="line">        System.out.println(&quot;Initial Stack: &quot; + stack);</span><br><span class="line"> </span><br><span class="line">        // Removing elements using pop() method</span><br><span class="line">        System.out.println(&quot;Popped element: &quot;</span><br><span class="line">                           + stack.pop());</span><br><span class="line">        System.out.println(&quot;Popped element: &quot;</span><br><span class="line">                           + stack.pop());</span><br><span class="line"> </span><br><span class="line">        // Displaying the Stack after pop operation</span><br><span class="line">        System.out.println(&quot;Stack after pop operation &quot;</span><br><span class="line">                           + stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initial Stack: [10, 15, 30, 20, 5]</span><br><span class="line">Popped element: 5</span><br><span class="line">Popped element: 20</span><br><span class="line">Stack after pop operation [10, 15, 30]</span><br></pre></td></tr></table></figure><ul><li>stack.isEmpty()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"> </span><br><span class="line">public class StackExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // Create a new stack</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        // Push elements onto the stack</span><br><span class="line">        stack.push(1);</span><br><span class="line">        stack.push(2);</span><br><span class="line">        stack.push(3);</span><br><span class="line">        stack.push(4);</span><br><span class="line"> </span><br><span class="line">        // Pop elements from the stack</span><br><span class="line">        while(!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue:"></a>Queue:</h2><p><a href="https://www.programiz.com/java-programming/queue">https://www.programiz.com/java-programming/queue</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; animal1 = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">add() - Inserts the specified element into the queue. If the task is successful, add() returns true, if not it throws an exception.</span><br><span class="line"></span><br><span class="line">offer() - Inserts the specified element into the queue. If the task is successful, offer() returns true, if not it returns false.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">element() - Returns the head of the queue. Throws an exception if the queue is empty.</span><br><span class="line"></span><br><span class="line">peek() - Returns the head of the queue. Returns null if the queue is empty.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">remove() - Returns and removes the head of the queue. Throws an exception if the queue is empty.</span><br><span class="line">poll() - Returns and removes the head of the queue. Returns null if the queue is empty.</span><br></pre></td></tr></table></figure><h1 id="Deque"><a href="#Deque" class="headerlink" title="Deque:"></a>Deque:</h1><p>Deque<Integer> deque &#x3D; new LinkedList&lt;&gt;();</p><p>addFirest addLast </p><p>removeFirst removeLast  </p><p>getFirst getLast</p><p> deque.size( ) deque.isEmpty()</p><p>In Java, a <code>Deque</code> (Double-Ended Queue) is an interface that provides various methods to perform basic operations on a double-ended queue, which allows you to add and remove elements from both ends (front and rear) of the queue. The <code>LinkedList</code> class is a commonly used implementation of the <code>Deque</code> interface. Here are some basic operations you can perform with a <code>Deque</code> in Java:</p><ol><li><strong>Adding Elements:</strong><ul><li><code>addFirst(E e)</code> or <code>offerFirst(E e)</code>: Adds an element to the front of the deque.</li><li><code>addLast(E e)</code> or <code>offerLast(E e)</code>: Adds an element to the end (rear) of the deque.</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">deque.addFirst(1);</span><br><span class="line">deque.addLast(2);</span><br></pre></td></tr></table></figure><ol><li><strong>Removing Elements:</strong> !!!!<ul><li><code>removeFirst()</code> or <code>pollFirst()</code>: Removes and returns the element at the front of the deque. Returns <code>null</code> if the deque is empty (for <code>pollFirst</code>).</li><li><code>removeLast()</code> or <code>pollLast()</code>: Removes and returns the element at the end (rear) of the deque. Returns <code>null</code> if the deque is empty (for <code>pollLast</code>).</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int front = deque.removeFirst();</span><br><span class="line">int rear = deque.pollLast();</span><br></pre></td></tr></table></figure><ol><li>**Accessing Elements: **!!!<ul><li><code>getFirst()</code> or <code>peekFirst()</code>: Returns the element at the front of the deque without removing it. Returns <code>null</code> if the deque is empty (for <code>peekFirst</code>).</li><li><code>getLast()</code> or <code>peekLast()</code>: Returns the element at the end (rear) of the deque without removing it. Returns <code>null</code> if the deque is empty (for <code>peekLast</code>).</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int front = deque.getFirst();</span><br><span class="line">int rear = deque.peekLast();</span><br></pre></td></tr></table></figure><ol><li><strong>Size and Empty Checks:</strong><ul><li><code>size()</code>: Returns the number of elements in the deque.</li><li><code>isEmpty()</code>: Checks if the deque is empty.</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int size = deque.size();</span><br><span class="line">boolean isEmpty = deque.isEmpty();</span><br></pre></td></tr></table></figure><ol><li><p><strong>Iteration:</strong></p><p>You can iterate over the elements in a deque using an enhanced for loop or an iterator.</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (Integer element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = deque.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    Integer element = iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>These are some of the basic operations you can perform on a <code>Deque</code> in Java. Depending on your needs, you can choose the appropriate methods to manipulate the double-ended queue as a stack, queue, or both.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to demonstrate the working</span></span><br><span class="line"><span class="comment">// of a Deque in Java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DequeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Deque&lt;String&gt; deque</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// We can add elements to the queue</span></span><br><span class="line">        <span class="comment">// in various ways</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Add at the last</span></span><br><span class="line">        deque.add(<span class="string">&quot;Element 1 (Tail)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Add at the first</span></span><br><span class="line">        deque.addFirst(<span class="string">&quot;Element 2 (Head)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Add at the last</span></span><br><span class="line">        deque.addLast(<span class="string">&quot;Element 3 (Tail)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Add at the first</span></span><br><span class="line">        deque.push(<span class="string">&quot;Element 4 (Head)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Add at the last</span></span><br><span class="line">        deque.offer(<span class="string">&quot;Element 5 (Tail)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Add at the first</span></span><br><span class="line">        deque.offerFirst(<span class="string">&quot;Element 6 (Head)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(deque + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// We can remove the first element</span></span><br><span class="line">        <span class="comment">// or the last element.</span></span><br><span class="line">        deque.removeFirst();</span><br><span class="line">        deque.removeLast();</span><br><span class="line">        System.out.println(<span class="string">&quot;Deque after removing &quot;</span></span><br><span class="line">                        + <span class="string">&quot;first and last: &quot;</span></span><br><span class="line">                        + deque);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Element 6 (Head), Element 4 (Head), Element 2 (Head), Element 1 (Tail), Element 3 (Tail), Element 5 (Tail)]</span><br><span class="line"></span><br><span class="line">Deque after removing first and last: [Element 4 (Head), Element 2 (Head), Element 1 (Tail), Element 3 (Tail)]</span><br></pre></td></tr></table></figure><h3 id="232-Implement-Queue-using-Stacks"><a href="#232-Implement-Queue-using-Stacks" class="headerlink" title="232. Implement Queue using Stacks"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;  //！！！！</span><br><span class="line">    Stack&lt;Integer&gt; stackOut; //！！！！</span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        stackIn = new Stack&lt;&gt;();//负责进栈</span><br><span class="line">        stackOut = new Stack&lt;&gt;();//负责出栈</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        clearStack();</span><br><span class="line">        return stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        clearStack();</span><br><span class="line">        return stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//notice！！！！！</span><br><span class="line">    private void clearStack()&#123;  // double stacks, inmotating queue</span><br><span class="line">    //在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</span><br><span class="line">        if(stackOut.isEmpty()) &#123; //important!!! stackout 全部搬空了以后再进数据，不然顺序会乱</span><br><span class="line">            while(!stackIn.isEmpty())&#123; //important</span><br><span class="line">                //make sure stackIn is always emtpy, everytime there&#x27;s new element added to the stack it will be added to stackOut imediately</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="225-Implement-Stack-using-Queues"><a href="#225-Implement-Stack-using-Queues" class="headerlink" title="225. Implement Stack using Queues"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></h2><p>Implement the <code>MyStack</code> class:</p><ul><li><code>void push(int x)</code> Pushes element x to the top of the stack.</li><li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li><li><code>int top()</code> Returns the element on the top of the stack.</li><li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每 offer 一个数（A）进来，都重新排列，把这个数（A）放到队列的队首, notic 每字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que.offer(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">        size = size - <span class="number">1</span>; <span class="comment">//!!!!!</span></span><br><span class="line">        <span class="comment">//移动除了 A 的其它数</span></span><br><span class="line">        <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que.offer(que.poll());</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// use two queues:   i feel like this method is harder to think</span><br><span class="line">class MyStack &#123;</span><br><span class="line">    Queue&lt;Integer&gt; que1;</span><br><span class="line">    Queue&lt;Integer&gt; que2;</span><br><span class="line"></span><br><span class="line">    public MyStack() &#123;</span><br><span class="line">        que1 = new LinkedList&lt;&gt;(); </span><br><span class="line">        que2 = new LinkedList&lt;&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        //que2 would always be empty at the end</span><br><span class="line">        que2.add(x);</span><br><span class="line">        while(!que1.isEmpty())&#123;</span><br><span class="line">            que2.add(que1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp;</span><br><span class="line">        temp = que1;</span><br><span class="line">        que1=que2;</span><br><span class="line">        que2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return que1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return que1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></h3><p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li><li>Every close bracket has a corresponding open bracket of the same type.</li></ol><p>there’s three situations that doesn’t consent to the restricts:</p><ol><li>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 <a href="https://camo.githubusercontent.com/8c0204c66cc3833ea5ba4a3ccab8edaf6142618787cf35331541d17785b12eac/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f323032303038303931353530353338372e706e67"><img src="https://camo.githubusercontent.com/8c0204c66cc3833ea5ba4a3ccab8edaf6142618787cf35331541d17785b12eac/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f323032303038303931353530353338372e706e67" alt="括号匹配1"></a></li><li>第二种情况，括号没有多余，但是 括号的类型没有匹配上。 <a href="https://camo.githubusercontent.com/7329d075e83bd226b626b592f184d95cc66ceece53adac50383cd71d8657ad48/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830393135353130373339372e706e67"><img src="https://camo.githubusercontent.com/7329d075e83bd226b626b592f184d95cc66ceece53adac50383cd71d8657ad48/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830393135353130373339372e706e67" alt="括号匹配2"></a></li><li>第三种情况，字符串里右方向的括号多余了，所以不匹配。 <a href="https://camo.githubusercontent.com/6ac2aabf0df60517ebe26fbed66f5713b45eeea012457b4ee5f42ea7acc0cab2/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830393135353131353737392e706e67"><img src="https://camo.githubusercontent.com/6ac2aabf0df60517ebe26fbed66f5713b45eeea012457b4ee5f42ea7acc0cab2/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830393135353131353737392e706e67" alt="括号匹配3"></a></li></ol><p>我们的代码只要覆盖了这三种不匹配的情况，就不会出问题，可以看出 动手之前分析好题目的重要性。</p><p>动画如下：</p><p><a href="https://camo.githubusercontent.com/9089c55ff04c99bf098437cc3dbc6eff5da9c03cd1fcba671508f9b41132bfd7/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f32302e2545362539432538392545362539352538382545362538422541432545352538462542372e676966"><img src="https://camo.githubusercontent.com/9089c55ff04c99bf098437cc3dbc6eff5da9c03cd1fcba671508f9b41132bfd7/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f32302e2545362539432538392545362539352538382545362538422541432545352538462542372e676966" alt="20.有效括号"></a></p><p>第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false</p><p>第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false</p><p>第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// it&#x27;s a stack here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                que.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                que.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                que.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(que.isEmpty() || que.peek() != ch)&#123;  </span><br><span class="line">                <span class="comment">// notice here, isEmpty -&gt; check this situation &quot;]&quot;, &quot;()&#123;&#125;&#125;&#123;&quot; 避免多了右方向括号</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty(); <span class="comment">// the reasone that here cant say return true is -&gt; &quot;([]&quot;避免多了左方向的括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">1047. Remove All Adjacent Duplicates In String</a></h3><p>Easy</p><p>You are given a string <code>s</code> consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>!adjacent!</strong> and <strong>equal</strong> letters and removing them.</p><p>We repeatedly make <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p><p>Return <em>the final string after all such duplicate removals have been made</em>. It can be proven that the answer is <strong>unique</strong>.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;azxxzy&quot;</span><br><span class="line">Output: &quot;ay&quot;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/681391ce1d10f56f34dff92f08ca2ff4421540016c4462bb7dd9f7493ae65ea8/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f313034372e2545352538382541302545392539392541342545352541442539372545372541432541362545342542382542322545342542382541442545372539412538342545362538392538302545362539432538392545372539422542382545392538322542422545392538372538442545352541342538442545392541312542392e676966"><img src="https://camo.githubusercontent.com/681391ce1d10f56f34dff92f08ca2ff4421540016c4462bb7dd9f7493ae65ea8/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f313034372e2545352538382541302545392539392541342545352541442539372545372541432541362545342542382542322545342542382541442545372539412538342545362538392538302545362539432538392545372539422542382545392538322542422545392538372538442545352541342538442545392541312542392e676966" alt="1047.删除字符串中的所有相邻重复项"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; que= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            c = s.charAt(i);</span><br><span class="line">             <span class="keyword">if</span>(que.isEmpty() || que.peek() != c)&#123; <span class="comment">// notice -&gt; que.isEmpty()</span></span><br><span class="line">                que.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            str = que.pop() + str; </span><br><span class="line">            <span class="comment">// very important here, you cant say str += que.pop(). causeit will reverse the order of the output.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// second try -&gt; use stack: it&#x27;s actually the same with the first approach</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; que = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(que.isEmpty() || que.peek() != c)&#123;</span><br><span class="line">                que.add(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            str =   que.pop() + str ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//拿字符串直接作为栈，省去了栈还要转为字符串的操作。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 res 当做栈</span></span><br><span class="line">        <span class="comment">// 也可以用 StringBuilder 来修改字符串，速度更快</span></span><br><span class="line">        <span class="comment">// StringBuilder res = new StringBuilder();</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">// top为 res 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">// 当 top &gt; 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--</span></span><br><span class="line">            <span class="keyword">if</span> (top &gt;= <span class="number">0</span> &amp;&amp; res.charAt(top) == c) &#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            <span class="comment">// 否则，将该字符 入栈，同时top++</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">拓展：双指针</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="comment">// 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span></span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. Evaluate Reverse Polish Notation</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// everytime i run this version there&#x27;s a bug I dont know why</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">        char c;</span><br><span class="line">        int res =0;</span><br><span class="line">        for(int i = 0; i &lt; tokens.length; i++)&#123;</span><br><span class="line">            c = tokens[i].charAt(0);</span><br><span class="line">            if(Character.isDigit(c))&#123;</span><br><span class="line">                que.push(c - &#x27;0&#x27;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                int a = que.pop();</span><br><span class="line">                int b = que.pop();</span><br><span class="line">                </span><br><span class="line">                if(c == &#x27;+&#x27;)&#123;</span><br><span class="line">                    res = a + b;</span><br><span class="line">                &#125;else if(c == &#x27;-&#x27;)&#123;</span><br><span class="line">                    res = b - a;</span><br><span class="line">                &#125;else if(c == &#x27;*&#x27;)&#123;</span><br><span class="line">                    res = a * b;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    res = b / a;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// right:</span><br><span class="line"></span><br><span class="line">//leetcode</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (&quot;+&quot;.equals(s)) &#123;        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br><span class="line">                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理</span><br><span class="line">            &#125; else if (&quot;-&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; else if (&quot;*&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; else if (&quot;/&quot;.equals(s)) &#123;</span><br><span class="line">                int temp1 = stack.pop();</span><br><span class="line">                int temp2 = stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//my + chatgpt:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        for (String token : tokens) &#123;</span><br><span class="line">            if (isNumeric(token)) &#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;  else &#123;</span><br><span class="line">                int a = stack.pop();</span><br><span class="line">                int b = stack.pop();</span><br><span class="line">                int res = 0;</span><br><span class="line">                if(token.equals(&quot;+&quot;))&#123;</span><br><span class="line">                    res = a+b;</span><br><span class="line">                &#125;</span><br><span class="line">                if(token.equals(&quot;-&quot;))&#123;</span><br><span class="line">                    res = b-a;</span><br><span class="line">                &#125;</span><br><span class="line">                if(token.equals(&quot;*&quot;))&#123;</span><br><span class="line">                    res= a*b;</span><br><span class="line">                &#125;</span><br><span class="line">                if(token.equals(&quot;/&quot;))&#123;</span><br><span class="line">                    res=b/a;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isNumeric(String str) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Integer.parseInt(str);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>second try:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// wrong version:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        Deque&lt;Integer&gt; dq = new LinkedList&lt;&gt;();</span><br><span class="line">        for(String s : tokens)&#123;</span><br><span class="line">            if(s.equals(&quot;+&quot;))&#123;</span><br><span class="line">                int num1 = dq.getLast();</span><br><span class="line">                int num2 = dq.getLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125;else if(s.equals(&quot;-&quot;))&#123;</span><br><span class="line">                int num1 = dq.getLast();</span><br><span class="line">                int num2 = dq.getLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125;else if(s.equals(&quot;*&quot;))&#123;</span><br><span class="line">                int num1 = dq.getLast();</span><br><span class="line">                int num2 = dq.getLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                res = num2 * num1;</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125;else if(s.equals(&quot;/&quot;))&#123;</span><br><span class="line">                int num1 = dq.getLast();</span><br><span class="line">                int num2 = dq.getLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                dq.removeLast();</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                dq.addLast(res);</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dq.addLast(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dq.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// right version:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; dq = new LinkedList&lt;&gt;();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (s.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                int num1 = dq.removeLast();</span><br><span class="line">                int num2 = dq.removeLast();</span><br><span class="line">                int res = num2 + num1;</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125; else if (s.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                int num1 = dq.removeLast();</span><br><span class="line">                int num2 = dq.removeLast();</span><br><span class="line">                int res = num2 - num1; // Corrected the order of operands here</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125; else if (s.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                int num1 = dq.removeLast();</span><br><span class="line">                int num2 = dq.removeLast();</span><br><span class="line">                int res = num2 * num1;</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125; else if (s.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                int num1 = dq.removeLast();</span><br><span class="line">                int num2 = dq.removeLast();</span><br><span class="line">                int res = num2 / num1; // Corrected the order of operands here</span><br><span class="line">                dq.addLast(res);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dq.addLast(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dq.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>In both code blocks, the goal is to perform division on the two most recent elements from the <code>Deque</code> (<code>num1</code> and <code>num2</code>) and then add the result back to the <code>Deque</code>. However, the difference lies in the order of retrieving and removing those elements from the <code>Deque</code>. Here’s a step-by-step explanation:</p><p><strong>Code Block 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeint num1 = dq.getLast();  // Retrieve the last element</span><br><span class="line">int num2 = dq.getLast();  // Retrieve the second-to-last element</span><br><span class="line">dq.removeLast();          // Remove the last element</span><br><span class="line">dq.removeLast();          // Remove the second-to-last element</span><br><span class="line">res = num2 / num1;        // Perform division</span><br><span class="line">dq.addLast(res);          // Add the result back to the Deque</span><br></pre></td></tr></table></figure><p><strong>Code Block 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeint num1 = dq.removeLast();  // Remove and retrieve the last element</span><br><span class="line">int num2 = dq.removeLast();  // Remove and retrieve the second-to-last element</span><br><span class="line">int res = num2 / num1;       // Perform division</span><br><span class="line">dq.addLast(res);             // Add the result back to the Deque</span><br></pre></td></tr></table></figure><p>In both cases, the division operation is the same, but here’s the key difference:</p><ul><li><strong>Code Block 1:</strong> It first retrieves the elements (<code>num1</code> and <code>num2</code>) and then removes them from the <code>Deque</code>. This means that even if an exception occurred during the division (e.g., division by zero), the elements would have already been removed from the <code>Deque</code>, potentially altering its state.</li><li><strong>Code Block 2:</strong> It directly uses <code>removeLast()</code> to both retrieve and remove the elements. This ensures that the elements are removed from the <code>Deque</code> after the division is performed. If an exception occurred during the division, the <code>Deque</code> would remain unchanged.</li></ul><p>In terms of functionality, both code blocks perform the same division operation. However, Code Block 2 is safer because it preserves the integrity of the <code>Deque</code> even in the presence of exceptions during the division operation.</p><h3 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/">347. Top K Frequent Elements</a></h3><p>Medium</p><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// use an array to save numbers into different bucket whose index is the frequency</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int n: nums)&#123;</span><br><span class="line">            map.put(n, map.getOrDefault(n,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // corner case: if there is only one number in nums, we need the bucket has index 1.</span><br><span class="line">        List&lt;Integer&gt;[] bucket = new List[nums.length+1]; //!!!! this is an array</span><br><span class="line">        for(int n:map.keySet())&#123;</span><br><span class="line">            int freq = map.get(n);</span><br><span class="line">            if(bucket[freq]==null)</span><br><span class="line">                bucket[freq] = new LinkedList&lt;&gt;();</span><br><span class="line">            bucket[freq].add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">        for(int i=bucket.length-1; i&gt;0 &amp;&amp; k&gt;0; --i)&#123;</span><br><span class="line">            if(bucket[i]!=null)&#123;</span><br><span class="line">                List&lt;Integer&gt; list = bucket[i]; </span><br><span class="line">                res.addAll(list);</span><br><span class="line">                k-= list.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>List&lt;Integer&gt;[]</code> is an array where each element is of type <code>List&lt;Integer&gt;</code>. Each element in the array can hold a reference to a list of integers (<code>List&lt;Integer&gt;</code>).\javaCopy code</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.addAll vs. add</span><br><span class="line"></span><br><span class="line">LinkedList&lt;Integer&gt; list1 = new LinkedList&lt;&gt;(); list1.add(1); list1.add(2); LinkedList&lt;Integer&gt; list2 = new LinkedList&lt;&gt;(); list2.add(3); list2.add(4); list1.addAll(list2); // Merges list2 into list1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>priority queue:</p><p><a href="https://camo.githubusercontent.com/4f6221eb3c248cb459d8a5b0679b37e71eca7ca999f1c25b0d515a6e09c20535/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3334372e2545352538392538444b2545342542382541412545392541422539382545392541322539312545352538352538332545372542342541302e6a7067"><img src="https://camo.githubusercontent.com/4f6221eb3c248cb459d8a5b0679b37e71eca7ca999f1c25b0d515a6e09c20535/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3334372e2545352538392538444b2545342542382541412545392541422539382545392541322539312545352538352538332545372542342541302e6a7067" alt="347.前K个高频元素"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// use an array to save numbers into different bucket whose index is the frequency</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-decreasing priority queue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">            map.put(n, map.getOrDefault(n,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> key : map.keySet())&#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;key, map.get(key)&#125;) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k; i++)&#123;</span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// decreasing priority queue</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent2(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;<span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll();<span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h1><p>A <code>PriorityQueue</code> in Java is an implementation of a priority queue data structure. It is part of the Java Collections Framework and is used to store elements in a way that allows for efficient retrieval of the element with the highest (or lowest) priority based on a specified comparator or the natural ordering of the elements.</p><p>Here are key points about <code>PriorityQueue</code>:</p><ol><li><p><strong>Priority Ordering</strong>: Elements in a <code>PriorityQueue</code> are stored in a way that maintains a priority order. The element with the highest priority (according to the specified comparator or natural ordering) is always at the front of the queue.</p></li><li><p><strong>Adding Elements</strong>: You can add elements to a <code>PriorityQueue</code> using the <code>add</code> or <code>offer</code> methods. When you add elements, they are placed in their appropriate position based on their priority.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codePriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</span><br><span class="line">pq.add(3);</span><br><span class="line">pq.add(1);</span><br><span class="line">pq.add(2);</span><br></pre></td></tr></table></figure><p>After these operations, the <code>pq</code> will contain <code>[1, 3, 2]</code>, where <code>1</code> has the highest priority.</p></li><li><p><strong>Removing Elements</strong>: You can remove the element with the highest priority using the <code>poll</code> method, which removes and returns the top element.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int highestPriority = pq.poll(); // Removes and returns the highest priority element (1 in this case)</span><br></pre></td></tr></table></figure></li><li><p><strong>Peeking</strong>: You can examine the element with the highest priority without removing it using the <code>peek</code> method.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int highestPriority = pq.peek(); // Returns the highest priority element without removing it (1 in this case)</span><br></pre></td></tr></table></figure></li><li><p><strong>Custom Comparators</strong>: You can define custom comparators to specify how elements are prioritized. Alternatively, if elements implement the <code>Comparable</code> interface, they will be ordered based on their natural ordering.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;String&gt; customPq = new PriorityQueue&lt;&gt;(Comparator.reverseOrder()); // Creates a descending order priority queue</span><br></pre></td></tr></table></figure></li><li><p><strong>Performance</strong>: The <code>PriorityQueue</code> implementation typically provides efficient <code>add</code>, <code>poll</code>, and <code>peek</code> operations. These operations have logarithmic time complexity.</p></li></ol><p><code>PriorityQueue</code> is commonly used in various algorithms and data structures, such as Dijkstra’s algorithm for finding the shortest path in a graph, Prim’s algorithm for minimum spanning trees, and more, where elements need to be processed in a certain order based on their priorities.</p><p>In a <code>PriorityQueue</code> in Java, by default, the first element you remove using the <code>poll()</code> method is the element with the <strong>smallest</strong> priority, not necessarily the largest. The default behavior is to prioritize elements based on their natural ordering (if they implement the <code>Comparable</code> interface) or based on a specified comparator that you can provide when creating the <code>PriorityQueue</code>.</p><p>So, after you remove the first element with <code>poll()</code>, the next element you remove will be the one with the next smallest priority, and so on, until the queue is empty.</p><p>Here’s an example of a <code>PriorityQueue</code> that prioritizes elements in ascending order (smallest element first):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</span><br><span class="line">pq.add(3);</span><br><span class="line">pq.add(1);</span><br><span class="line">pq.add(2);</span><br><span class="line"></span><br><span class="line">int smallest = pq.poll(); // Removes and returns the smallest element (1)</span><br><span class="line">int nextSmallest = pq.poll(); // Removes and returns the next smallest element (2)</span><br><span class="line">int last = pq.poll(); // Removes and returns the last element (3)</span><br></pre></td></tr></table></figure><p>If you want to prioritize elements in descending order (largest element first), you can create a <code>PriorityQueue</code> with a custom comparator:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; descendingPq = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">descendingPq.add(3);</span><br><span class="line">descendingPq.add(1);</span><br><span class="line">descendingPq.add(2);</span><br><span class="line"></span><br><span class="line">int largest = descendingPq.poll(); // Removes and returns the largest element (3)</span><br><span class="line">int nextLargest = descendingPq.poll(); // Removes and returns the next largest element (2)</span><br><span class="line">int smallest = descendingPq.poll(); // Removes and returns the smallest element (1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; descendingPq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">descendingPq.add(3);</span><br><span class="line">descendingPq.add(1);</span><br><span class="line">descendingPq.add(2);</span><br><span class="line"></span><br><span class="line">int largest = descendingPq.poll(); // Removes and returns the largest element (3)</span><br><span class="line">int nextLargest = descendingPq.poll(); // Removes and returns the next largest element (2)</span><br><span class="line">int smallest = descendingPq.poll(); // Removes and returns the smallest element (1)</span><br></pre></td></tr></table></figure><p>In this case, with the <code>Collections.reverseOrder()</code> comparator, the <code>PriorityQueue</code> prioritizes elements in descending order.</p><h1 id="java-List"><a href="#java-List" class="headerlink" title="java List"></a>java List</h1><p>When it comes to using the common methods provided by the <code>List</code> interface, such as <code>add</code>, <code>remove</code>, <code>get</code>, and others, the syntax for <code>ArrayList</code> and <code>LinkedList</code> is the same. This is because both <code>ArrayList</code> and <code>LinkedList</code> are implementations of the <code>List</code> interface, so they share the same method signatures.</p><p>Here’s an example of some common methods with the same syntax for both <code>ArrayList</code> and <code>LinkedList</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// Adding elements to the list</span><br><span class="line">arrayList.add(1);</span><br><span class="line">linkedList.add(2);</span><br><span class="line"></span><br><span class="line">// Removing elements from the list</span><br><span class="line">arrayList.remove(0);</span><br><span class="line">linkedList.remove(0);</span><br><span class="line"></span><br><span class="line">// Accessing elements by index</span><br><span class="line">int element1 = arrayList.get(0);</span><br><span class="line">int element2 = linkedList.get(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ListExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; myList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // Adding elements</span><br><span class="line">        myList.add(&quot;Apple&quot;);</span><br><span class="line">        myList.add(&quot;Banana&quot;);</span><br><span class="line">        myList.add(&quot;Cherry&quot;);</span><br><span class="line"></span><br><span class="line">        // Accessing elements</span><br><span class="line">        String fruit = myList.get(1); // Retrieves &quot;Banana&quot;</span><br><span class="line"></span><br><span class="line">        // Removing elements</span><br><span class="line">        myList.remove(0); // Removes &quot;Apple&quot;</span><br><span class="line"></span><br><span class="line">        // Checking list properties</span><br><span class="line">        int size = myList.size(); // Returns 2</span><br><span class="line">        boolean isEmpty = myList.isEmpty(); // Returns false</span><br><span class="line">        boolean containsCherry = myList.contains(&quot;Cherry&quot;); // Returns true</span><br><span class="line"></span><br><span class="line">        // Iterating through elements</span><br><span class="line">        for (String item : myList) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2023/07/02/SoftwareDevelopment/react/"/>
      <url>/2023/07/02/SoftwareDevelopment/react/</url>
      
        <content type="html"><![CDATA[<h1 id="REACT"><a href="#REACT" class="headerlink" title="REACT"></a>REACT</h1><p><strong>JSX</strong>  (JavaScript XML) is an extension to JavaScript syntax used in React. It allows you to write HTML-like code within JavaScript, making it easier to create and manipulate the structure of user interfaces.</p><p>JS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from&quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">//ReactDOM.render(WHAT TO SHOW, WHERE TO SHOW)</span><br><span class="line">ReactDOM.render(&lt;h1&gt;helloworld&lt;/h1&gt;, document.getElementById(&quot;root&quot;));</span><br><span class="line">// render method can only take one html element</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from&quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;haha&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;bacon&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;potato&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;noodles&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">,document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure><p>HTML:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;JSX&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;../src/index.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tags like image or link are self closing</p><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>here you gonna learn how to put javascript into html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">const name = &quot;Dan&quot;;</span><br><span class="line"></span><br><span class="line">const num = 12 ;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;Hello &#123;name&#125;!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;my lucky number is&#123; Math.floor( Math.random() * 10 )&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">, document.getElementById(&quot;root&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="expression-vs-statement"><a href="#expression-vs-statement" class="headerlink" title="expression vs. statement"></a><strong>expression vs. statement</strong></h3><p><strong>Expressions</strong> in JavaScript produce values. They can be simple, like variables or numbers, or more complex, involving operators or function calls.</p><p><strong>Statements</strong> in JavaScript perform actions or control the flow of execution. They don’t produce values and consist of keywords, operators, and expressions.</p><p>Expressions give you values, while statements do something or control how your code runs.</p><h3 id="ES6-template-literal"><a href="#ES6-template-literal" class="headerlink" title="ES6: template literal"></a><strong>ES6: template literal</strong></h3><ol><li><strong>{} (Curly Braces)</strong>: Curly braces are used in JSX (JavaScript XML) syntax to embed JavaScript expressions within JSX. They allow you to include dynamic values or JavaScript code inside JSX elements. You can use curly braces to interpolate variables, call functions, perform calculations, and more. Here’s an example:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsxCopy codeconst name = &quot;John&quot;;</span><br><span class="line">const greeting = &lt;h1&gt;Hello, &#123;name&#125;!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>In the above code, the variable <code>name</code> is interpolated within the JSX element using curly braces. The value of <code>name</code> is dynamically inserted into the rendered output.</p><ol start="2"><li><strong>${} (Template Literal Syntax)</strong>: The <code>$&#123;&#125;</code> syntax is not specific to React but is a feature of JavaScript called template literals (or template strings). Template literals allow for string interpolation, where you can embed expressions or variables within a string. It is typically used outside of JSX syntax when dealing with regular JavaScript strings. Here’s an example:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jsxCopy codeconst name = &quot;John&quot;;</span><br><span class="line">const greeting = `Hello, $&#123;name&#125;!`;</span><br></pre></td></tr></table></figure><p>In the above code, the variable <code>name</code> is interpolated within the template literal using <code>$&#123;&#125;</code>. The value of <code>name</code> is inserted into the resulting string.</p><p>To summarize, <code>&#123;&#125;</code> is used in JSX to embed JavaScript expressions within JSX elements, whereas <code>$&#123;&#125;</code> is used in regular JavaScript as part of template literals to interpolate expressions or variables within strings</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">const name = &quot;Dan&quot;;</span><br><span class="line">const f = &quot;xiang&quot;;</span><br><span class="line">const num = 12 ;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;Hello &#123;`$&#123;name&#125; $&#123;f&#125;`&#125;!&lt;/h1&gt;  // </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">, document.getElementById(&quot;root&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">const YOURNAME = &quot;Dan&quot;</span><br><span class="line">const CURRENTYEAR = new Date().getFullYear();</span><br><span class="line">ReactDOM.render( </span><br><span class="line">&lt;p&gt;&#123;`$&#123;YOURNAME&#125; $&#123;CURRENTYEAR&#125;`&#125; &lt;/p&gt;</span><br><span class="line">  , document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="JSX-Attributes-amp-Styling-React-Elements"><a href="#JSX-Attributes-amp-Styling-React-Elements" class="headerlink" title="JSX Attributes &amp; Styling React Elements"></a>JSX Attributes &amp; Styling React Elements</h2><p><a href="https://codesandbox.io/s/jsx-attributes-and-styling-kkycr?fontsize=14">https://codesandbox.io/s/jsx-attributes-and-styling-kkycr?fontsize=14</a></p><h3 id="inline-styling"><a href="#inline-styling" class="headerlink" title="inline styling:"></a>inline styling:</h3><p><a href="https://codesandbox.io/s/inline-styling-in-jsx-159y7?fontsize=14">https://codesandbox.io/s/inline-styling-in-jsx-159y7?fontsize=14</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 style=&#123;&#123;color: &quot;red&quot;&#125;&#125;&gt;</span><br><span class="line">      My Favourite Foods</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const customStyle = &#123;</span><br><span class="line">  color: &quot;red&quot;,</span><br><span class="line">  fontSize: &quot;20px&quot;,</span><br><span class="line">  border:&quot;1px solid black&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customStyle.color = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 style=&#123;customStyle&#125;&gt;</span><br><span class="line">      My Favourite Foods</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="https://codesandbox.io/s/react-styling-practice-xpn8u?fontsize=14">https://codesandbox.io/s/react-styling-practice-xpn8u?fontsize=14</a>  (time greeting application)</p><h2 id="react-components"><a href="#react-components" class="headerlink" title="react components"></a>react components</h2><p><a href="https://github.com/airbnb/javascript/tree/master/react">Airbnb Style Guide for React</a></p><ul><li>split off coding into a separate file:</li></ul><p><a href="https://codesandbox.io/s/react-components-j66pt?fontsize=14">https://codesandbox.io/s/react-components-j66pt?fontsize=14</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Time.jsx:  //notice: capitalize the first character</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">const date = new Date();</span><br><span class="line">const currentTime = date.getHours();</span><br><span class="line">let greeting;</span><br><span class="line">const customStyle = &#123;</span><br><span class="line">  color: &quot;&quot;</span><br><span class="line">&#125;;</span><br><span class="line">function Time()&#123;</span><br><span class="line">    if (currentTime &lt; 12) &#123;</span><br><span class="line">      greeting = &quot;Good Morning&quot;;</span><br><span class="line">      customStyle.color = &quot;red&quot;;</span><br><span class="line">    &#125; else if (currentTime &lt; 18) &#123;</span><br><span class="line">      greeting = &quot;Good Afternoon&quot;;</span><br><span class="line">      customStyle.color = &quot;green&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      greeting = &quot;Good Night&quot;;</span><br><span class="line">      customStyle.color = &quot;blue&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &lt;h1 style=&#123;customStyle&#125;&gt;&#123;greeting&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">export default Time;  // notice: heres no parenthesis</span><br><span class="line"></span><br><span class="line">////////////////////////////////////////////////////////////////////////</span><br><span class="line">index.js: </span><br><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import Time from &quot;./component/Time&quot;</span><br><span class="line">ReactDOM.render(</span><br><span class="line"> &lt;Time/&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Import-Export-Module"><a href="#Import-Export-Module" class="headerlink" title="Import , Export, Module"></a>Import , Export, Module</h2><p>index.js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import pi, &#123; doublePi, triplePi &#125; from &quot;./math.js&quot;;</span><br><span class="line"></span><br><span class="line">// you can also say: import PI; beasue pi is default export</span><br><span class="line">but doublePi, triplePi need to be the exact name with the export statemenet</span><br><span class="line">// you can also say: import * as pi; (import all) </span><br><span class="line">pi.default       pi.doublePi     pi.tripleOie()</span><br><span class="line">//wild card import in discouraged</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&#123;pi&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&#123;doublePi()&#125;&lt;/li&gt;   // notice: here has parenthesis</span><br><span class="line">    &lt;li&gt;&#123;triplePi()&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;,</span><br><span class="line">  document.getElementById(&quot;root&quot;)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>math.js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const pi = 3.1415962;</span><br><span class="line"></span><br><span class="line">function doublePi() &#123;</span><br><span class="line">  return pi * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function triplePi() &#123;</span><br><span class="line">  return pi * 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default pi;</span><br><span class="line">export &#123; doublePi, triplePi &#125;; // no parenthesis</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Authentication</title>
      <link href="/2023/07/02/SoftwareDevelopment/authentication/"/>
      <url>/2023/07/02/SoftwareDevelopment/authentication/</url>
      
        <content type="html"><![CDATA[<h2 id="mongoose-encrypt"><a href="#mongoose-encrypt" class="headerlink" title="mongoose encrypt"></a>mongoose encrypt</h2><ul><li>the way that mongoose encrypt works is that it will encrypt when you call save and decrypt when you call find.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">const encrypt = require(&quot;mongoose-encryption&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const userSchema= new mongoose.Schema(&#123;</span><br><span class="line">    email: String,</span><br><span class="line">    password: String</span><br><span class="line">&#125;); </span><br><span class="line">// no longer a simple Javascript object but it&#x27;s actually an object that&#x27;s created from the mongoose schema class</span><br><span class="line"></span><br><span class="line">const secret =&quot;Thisisoutlittlesecret.&quot;</span><br><span class="line">userSchema.Schema.plugin(encrypt,&#123;secret: secret, encryptedFields:[&quot;password&quot;]&#125;);</span><br><span class="line"></span><br><span class="line">const User = new mongoose.model(&quot;User&quot;, userSchema);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/register&quot;, function(req,res)&#123;</span><br><span class="line">    const newUser = new User(&#123;</span><br><span class="line">        email: req.body.username,</span><br><span class="line">        password: req.body.password</span><br><span class="line">    &#125;);</span><br><span class="line">    newUser.save().then(() =&gt; &#123;</span><br><span class="line">      res.render(&quot;secrets&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/login&quot;, function(req,res)&#123;</span><br><span class="line">    const username = req.body.username;</span><br><span class="line">    const password = req.body.password;</span><br><span class="line">    </span><br><span class="line">    User.findOne(&#123;email: username&#125;).then((foundUser)=&gt;&#123;</span><br><span class="line">        if(foundUser)&#123;</span><br><span class="line">            if(foundUser.password === password)&#123;</span><br><span class="line">                res.render(&quot;secrets&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="environment-variable-store-sensetive-inf"><a href="#environment-variable-store-sensetive-inf" class="headerlink" title="environment  variable (store sensetive inf)"></a>environment  variable (store sensetive inf)</h2><p>dotenv package</p><ul><li><p>make a .env file in root directory</p></li><li><p>add -&gt;       require(‘dotenv’).config(); &#x2F;&#x2F; put this on top in app.js</p></li><li><p>in .env, the format is like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAME = VALUE   </span><br></pre></td></tr></table></figure><p>NOTICE: no space in between and no quotation marks, NO SEMI COLON !!!!!!!</p></li><li></li></ul><p>.env:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SECRET=Thisisoutlittlesecret.</span><br></pre></td></tr></table></figure><p>app.js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;dotenv&#x27;).config(); // put this on top</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const secret = process.env.SECRET;</span><br></pre></td></tr></table></figure><h2 id="hashing"><a href="#hashing" class="headerlink" title="hashing"></a>hashing</h2><p>hash function:  very fast to encode but almost impossible to go backwards</p><h3 id="md5-Hashes"><a href="#md5-Hashes" class="headerlink" title="md5 Hashes"></a>md5 Hashes</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const md5 = require(&quot;md5&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.post(&quot;/register&quot;, function(req,res)&#123;</span><br><span class="line">    const newUser = new User(&#123;</span><br><span class="line">        email: req.body.username,</span><br><span class="line">        password: md5(req.body.password)</span><br><span class="line">    &#125;);</span><br><span class="line">    newUser.save().then(() =&gt; &#123;</span><br><span class="line">      res.render(&quot;secrets&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="hashing-amp-salting"><a href="#hashing-amp-salting" class="headerlink" title="hashing &amp; salting"></a>hashing &amp; salting</h3><p>The reason why is a hashing algorithm does not inherently produce a unique string for the same password text each time it’s received. In other words, suppose your password looks like the example above (Password@1234)<em>.</em> Each time the algorithm receives the same input string, it will always produce the same hash string (i.e. 0F1BA603C1A843A3D02D6C5038D8E959). This is not ideal because a hacker can launch a rainbow attack on your database to crack the passwords stored inside.</p><p>Our problem with hashing is fixed with a simple solution: using salt. Salt is a randomly generated, fixed-length value that is designed to be unique with each user password. Salt is appended with the current password string and fed into the hashing system to produce a newly hashed result every time a user creates a password. This means that if you and I have the same password, our hashed strings would be different. And since rainbow table attacks heavily depend on finding a match, it would render them useless.</p><p>The bcrypt library, which creates both salt and hashed data with strong cryptography algorithms backing it, is great for this purpose.</p><h4 id="salt-round"><a href="#salt-round" class="headerlink" title="salt round"></a>salt round</h4><p>When we talk about “hashing salt rounds,” we refer to the process of repeatedly applying the hashing and salting operations a specific number of times. Each iteration is known as a round. The purpose of using multiple rounds is to slow down the hashing process, making it more time-consuming and resource-intensive for an attacker attempting to crack the hashed passwords.</p><h3 id="bcrypt-Hashes"><a href="#bcrypt-Hashes" class="headerlink" title="bcrypt Hashes"></a>bcrypt Hashes</h3><ul><li><p>You can use nvm to upgrade or downgrade your node version.</p><p>go to nvm github, install the script with the command in github</p><p>go to terminal type -&gt;    nvm install 10.15.0</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">npm i bcrypt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const bcrypt = require(&quot;bcrypt&quot;);</span><br><span class="line">app.post(&quot;/register&quot;, function(req,res)&#123;</span><br><span class="line">    const saltRounds = 10;</span><br><span class="line">    bcrypt.hash(req.body.password , saltRounds, function(err, hash)&#123; </span><br><span class="line">        const newUser = new User(&#123;</span><br><span class="line">            email: req.body.username,</span><br><span class="line">            password: hash</span><br><span class="line">        &#125;);</span><br><span class="line">        newUser.save().then(() =&gt; &#123;</span><br><span class="line">          res.render(&quot;secrets&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch((err) =&gt; &#123;</span><br><span class="line">          console.log(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/login&quot;, function(req,res)&#123;</span><br><span class="line">    const username = req.body.username;</span><br><span class="line">    const password = req.body.password;</span><br><span class="line">    </span><br><span class="line">    User.findOne(&#123;email: username&#125;).then((foundUser)=&gt;&#123;</span><br><span class="line">        if(foundUser)&#123;</span><br><span class="line">            // if(foundUser.password === password)&#123;</span><br><span class="line">            //     res.render(&quot;secrets&quot;);</span><br><span class="line">            // &#125;</span><br><span class="line">            bcrypt.compare(password, foundUser.password, function(err, result)&#123;</span><br><span class="line">                if(result === true)&#123;</span><br><span class="line">                    res.render(&quot;secrets&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>watch Angela37节. 359 for how cookie works.</p><h3 id="passport"><a href="#passport" class="headerlink" title="passport"></a>passport</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">//jshint esversion:6</span><br><span class="line">require(&#x27;dotenv&#x27;).config(); // put this on top</span><br><span class="line">const express =  require(&quot;express&quot;);</span><br><span class="line">const bodyParser = require(&quot;body-parser&quot;);</span><br><span class="line">const ejs = require(&quot;ejs&quot;);</span><br><span class="line">const mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">const encrypt = require(&quot;mongoose-encryption&quot;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">// 1. REQUIRE MODULES</span><br><span class="line">const session = require(&quot;express-session&quot;);</span><br><span class="line">const passport = require(&quot;passport&quot;);</span><br><span class="line">const passportLocalMongoose = require(&quot;passport-local-mongoose&quot;);</span><br><span class="line">//dont need to require passport-local, cause passport-local-mongoose will need passport-local. but our code wont urefer to passport-local</span><br><span class="line"></span><br><span class="line">app.use(express.static(&quot;public&quot;));</span><br><span class="line">app.set(&quot;view engine&quot;, &quot;ejs&quot;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123;extended:true&#125;));</span><br><span class="line">// 2. tell app to use session package and set up initialization</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret:&quot;Our little secret.&quot;,</span><br><span class="line">    resave: false,</span><br><span class="line">    saveUnitialized: false</span><br><span class="line">    </span><br><span class="line">&#125;)); </span><br><span class="line">//3. initialize passport</span><br><span class="line">app.use(passport.initialize()); </span><br><span class="line">//4.use passport to manage our session</span><br><span class="line">app.use(passport.session());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mongoose.connect(&quot;mongodb+srv://dxexperiments-user:DrEuMg7KfFImh774@dxvignettes.vtnenqy.mongodb.net/test&quot;);</span><br><span class="line"></span><br><span class="line">const userSchema= new mongoose.Schema(&#123;</span><br><span class="line">    email: String,</span><br><span class="line">    password: String</span><br><span class="line">&#125;); </span><br><span class="line">//5. setup userSchema to use passport local mongoose as a plugin</span><br><span class="line">userSchema.plugin(passportLocalMongoose);  //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const User = new mongoose.model(&quot;User&quot;, userSchema);</span><br><span class="line"></span><br><span class="line">//6. use passport local mongoose to create a local log in strategy and set up passport serialize and deserialize</span><br><span class="line">passport.use(User.createStrategy());</span><br><span class="line"></span><br><span class="line">// use static serialize and deserialize of model for passport session support</span><br><span class="line">passport.serializeUser(User.serializeUser()); //serialize</span><br><span class="line">passport.deserializeUser(User.deserializeUser()); //deserialize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&quot;/&quot;, function(req,res)&#123;</span><br><span class="line">    res.render(&quot;home&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&quot;/login&quot;, function(req,res)&#123;</span><br><span class="line">    res.render(&quot;login&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&quot;/register&quot;, function(req,res)&#123;</span><br><span class="line">    res.render(&quot;register&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&quot;/secrets&quot;, function(req,res)&#123;</span><br><span class="line">    if(req.isAuthenticated())&#123;</span><br><span class="line">        res.render(&quot;secrets&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.redirect(&quot;/login&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&quot;/logout&quot;,function(req,res)&#123;</span><br><span class="line">    req.logout(function(err) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          console.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">        res.redirect(&#x27;/&#x27;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.post(&quot;/register&quot;, function(req,res)&#123;</span><br><span class="line">    User.register(&#123;username: req.body.username&#125;, req.body.password, function(err, user)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            res.redirect(&quot;/register&quot;)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            passport.authenticate(&quot;local&quot;)(req,res,function()&#123; //authenticate the user</span><br><span class="line">                res.redirect(&quot;/secrets&quot;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/login&quot;, function(req,res)&#123;</span><br><span class="line">    </span><br><span class="line">    const user = new User(&#123;</span><br><span class="line">        username: req.body.username,</span><br><span class="line">        password: req.body.password</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    req.login(user, function(err)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            passport.authenticate(&quot;local&quot;)(req,res,function()&#123; //authenticate the user</span><br><span class="line">                res.redirect(&quot;/secrets&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(&quot;3000&quot;,function()&#123;</span><br><span class="line">    console.log(&quot;listening on port 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h3><h2 id="useful-websites"><a href="#useful-websites" class="headerlink" title="useful websites:"></a>useful websites:</h2><p>check if you has been pwned: <a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a></p><p>password-checker: <a href="http://password-checker.online-domain-tools.com/">http://password-checker.online-domain-tools.com/</a></p><p><a href="https://plaintextoffenders.com/">https://plaintextoffenders.com/</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API</title>
      <link href="/2023/06/30/SoftwareDevelopment/API/"/>
      <url>/2023/06/30/SoftwareDevelopment/API/</url>
      
        <content type="html"><![CDATA[<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&quot;body-parser&quot;);</span><br><span class="line">const https = require(&quot;https&quot;); // it&#x27;s a native node module so we dont need to use npm install</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line"></span><br><span class="line">app.get(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  res.sendFile(__dirname + &quot;/index.html&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  const query = req.body.cityName;</span><br><span class="line">  // console.log(query);</span><br><span class="line">  const apikey = &quot;dd57eaafc59a1e465a30342da21d56dc&quot;;</span><br><span class="line">  const unit = &quot;metric&quot;;</span><br><span class="line">  const url =</span><br><span class="line">    &quot;https://api.openweathermap.org/data/2.5/weather?q=&quot; +</span><br><span class="line">    query +</span><br><span class="line">    &quot;&amp;appid=&quot; +</span><br><span class="line">    apikey +</span><br><span class="line">    &quot;&amp;units=&quot; +</span><br><span class="line">    unit;</span><br><span class="line"></span><br><span class="line">  // it need to have this strict formatting with the &quot;https://&quot;</span><br><span class="line"></span><br><span class="line">  // make a http get request to get data</span><br><span class="line">  https.get(url, function (response) &#123;</span><br><span class="line">    // console.log(response);</span><br><span class="line">    response.on(&quot;data&quot;, function (data) &#123;</span><br><span class="line">      const weatherData = JSON.parse(data); // convert data into a json object</span><br><span class="line">      const temp = weatherData.main.temp;</span><br><span class="line">      const description = weatherData.weather[0].description;</span><br><span class="line">      const img = weatherData.weather[0].icon;</span><br><span class="line">      const urlImg = &quot;https://openweathermap.org/img/wn/&quot; + img + &quot;@2x.png&quot;;</span><br><span class="line">      // res.write(&quot;&lt;img src=&quot; + urlImg + &quot;&gt;&quot;);</span><br><span class="line">      res.write(&quot;&lt;h1&gt;the temp in &quot; + query + &quot; is &quot; + temp + &quot;degrees&lt;/h1&gt;&quot;);</span><br><span class="line">      res.write(&quot;&lt;p&gt;the weather is like: &quot; + description + &quot;&lt;p&gt;&quot;);</span><br><span class="line">      res.write(&quot;&lt;img src=&quot; + urlImg + &quot;&gt;&quot;);</span><br><span class="line">      res.send(); // can only have one res.send method in one app dot method</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // const object = &#123;</span><br><span class="line">    //   name: &quot;dan&quot;,</span><br><span class="line">    //   food: &quot;potato&quot;,</span><br><span class="line">    // &#125;;</span><br><span class="line">    // console.log(JSON.stringify(object)); // turn a javascript object into a string</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on port 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Overview</title>
      <link href="/2023/06/21/SoftwareDevelopment/MySql/"/>
      <url>/2023/06/21/SoftwareDevelopment/MySql/</url>
      
        <content type="html"><![CDATA[<ul><li><p>npm i -y</p><p>npm i dotenv express hbs mysql</p><p>npm i –save nodemon</p></li><li><p>Double-check that your package.json file has the “scripts” section defined with the “start” script. It should look like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;nodemon app.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>you run npm start in terminal.</p><h3 id="cannot-start-mysql-in-xampp"><a href="#cannot-start-mysql-in-xampp" class="headerlink" title="cannot start mysql in xampp"></a>cannot start mysql in xampp</h3><p>The most likely reason that XAMPP’s MySQL service is unable to start is because <strong>port 3306 is already used by a different program that is currently running on your computer</strong>. By default, XAMPP’s MySQL service binds to port 3306 when started, and it can only do so if another program is not already using it.</p><p>To ascertain whether this is the case, you can click on the <strong>Netstat</strong> button to open up a window with a list of all the ports that are being used on your computer currently. <strong>If port 3306 is in the list when you haven’t started MySQL on XAMPP, this means that another program is using it.</strong></p><p><img src="https://blog.terresquall.com/wp-content/uploads/2023/04/xampp-netstat-window.gif" alt="XAMPP&#39;s Netstat window">Use the <strong>Netstat</strong> window to check if port 3306 has already been occupied.</p><p>To remedy this, you will need to find the process that is using port 3306 and end the process. In the example above, a process called <strong>mysqld.exe</strong> is using port 3306. To stop it, I will have to use Ctrl + Alt + Delete to open up the <strong>Task Manager</strong>, then find and end the <strong>mysqld.exe</strong> process.</p><p><img src="https://blog.terresquall.com/wp-content/uploads/2023/04/task-manager.jpg" alt="Task Manager">If your <strong>Task Manager</strong> doesn’t show all the processes, click on <strong>More details</strong> at the bottom of the window to get the full <strong>Task Manager</strong> window.</p><h2 id="“-x2F-“-vs-“-x2F-“"><a href="#“-x2F-“-vs-“-x2F-“" class="headerlink" title="“&#x2F;“ vs. “.&#x2F;“"></a>“&#x2F;“ vs. “.&#x2F;“</h2><p>“&#x2F;“ means it will look into the public static file to look for a certain file</p><p>“.&#x2F;“ means it will go to the current path </p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EJS</title>
      <link href="/2023/06/13/SoftwareDevelopment/EJS/"/>
      <url>/2023/06/13/SoftwareDevelopment/EJS/</url>
      
        <content type="html"><![CDATA[<h1 id="EJS-Embedded-JavaScript-templates"><a href="#EJS-Embedded-JavaScript-templates" class="headerlink" title="EJS(Embedded JavaScript templates)"></a>EJS(<a href="https://ejs.co/">Embedded JavaScript templates</a>)</h1><h3 id="GET-STARTED"><a href="#GET-STARTED" class="headerlink" title="GET STARTED"></a>GET STARTED</h3><p>1. </p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs</span><br></pre></td></tr></table></figure><p>2. </p><p><a href="https://github.com/mde/ejs/wiki/Using-EJS-with-Express">https://github.com/mde/ejs/wiki/Using-EJS-with-Express</a></p><p>In Express v4, a very basic setup using EJS would look like the following. (This assumes a <code>views</code> directory containing an <code>index.ejs</code> page.)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&#x27;express&#x27;);</span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); // TELL APP TO USE EJS</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;</span><br><span class="line">  res.render(&#x27;index&#x27;, &#123;foo: &#x27;FOO&#x27;&#125;); // rendering a page called index</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(4000, () =&gt; console.log(&#x27;Example app listening on port 4000!&#x27;));</span><br></pre></td></tr></table></figure><ol start="3"><li><p>create views&#x2F;list.ejs directory</p><p>list.ejs is used to hold html content</p><p>like:</p><p>list.ejs:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;To do list&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;%= kindOfDay %&gt; List&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>app.js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&quot;body-parser&quot;);</span><br><span class="line"></span><br><span class="line">app.set(&quot;view engine&quot;, &quot;ejs&quot;);</span><br><span class="line"></span><br><span class="line">app.get(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  var today = new Date();</span><br><span class="line">  var currentDay = today.getDay();</span><br><span class="line">  var day = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  switch (currentDay) &#123;</span><br><span class="line">    case 0:</span><br><span class="line">      day = &quot;Sunday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 1:</span><br><span class="line">      day = &quot;Monday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      day = &quot;Tuesday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 3:</span><br><span class="line">      day = &quot;Wednesday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 4:</span><br><span class="line">      day = &quot;Thursday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 5:</span><br><span class="line">      day = &quot;Friday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    case 6:</span><br><span class="line">      day = &quot;Thursday&quot;;</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      console.log(&quot;Invalid day&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.render(&quot;list&quot;, &#123; kindOfDay: day &#125;); // it will go and find wiews folder and the list.ejs file inside of it, replace kindOfDay with day</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>add js logic in ejs template</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;To do list&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- add &lt;% %&gt; if it&#x27;s javascript --&gt;</span><br><span class="line">    &lt;% if(kindOfDay===&quot;Saturday&quot; || kindOfDay===&quot;Sunday&quot;)&#123; %&gt;</span><br><span class="line">    &lt;h1 style=&quot;color: purple&quot;&gt;&lt;%= kindOfDay %&gt; ToDo List&lt;/h1&gt;</span><br><span class="line">    &lt;% &#125;else&#123; %&gt;</span><br><span class="line">    &lt;h1 style=&quot;color: blue&quot;&gt;&lt;%= kindOfDay %&gt; ToDo List&lt;/h1&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="add-list-Project-todolistV1"><a href="#add-list-Project-todolistV1" class="headerlink" title="add list  (Project_todolistV1)"></a>add list  (Project_todolistV1)</h2></li></ol><ul><li>ejs:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;To do list&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;%= kindOfDay %&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;% for( var i = 0; i &lt;newListItems.length; i++) &#123; %&gt;</span><br><span class="line">      &lt;li&gt;&lt;%= newListItems[i] %&gt;&lt;/li&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;form action=&quot;/&quot; method=&quot;post&quot; class=&quot;&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;newItem&quot; placeholder=&quot;todo...&quot; /&gt;</span><br><span class="line">      &lt;button type=&quot;submit&quot; name=&quot;&quot; button&gt;add&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li><p>app.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&quot;body-parser&quot;);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; extended: true &#125;));</span><br><span class="line">app.set(&quot;view engine&quot;, &quot;ejs&quot;);</span><br><span class="line"></span><br><span class="line">var items = [&quot;buy food&quot;];</span><br><span class="line"></span><br><span class="line">app.get(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  var today = new Date();</span><br><span class="line">  var options = &#123;</span><br><span class="line">    weekday: &quot;long&quot;,</span><br><span class="line">    day: &quot;numeric&quot;,</span><br><span class="line">    month: &quot;long&quot;,</span><br><span class="line">  &#125;;</span><br><span class="line">  var day = today.toLocaleDateString(&quot;en-US&quot;, options);</span><br><span class="line">  res.render(&quot;list&quot;, &#123; kindOfDay: day, newListItems: items &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  items.push(req.body.newItem); // add new item to the array</span><br><span class="line">  res.redirect(&quot;/&quot;); //redirect to homeroute -&gt; app.get(&quot;/&quot;)</span><br><span class="line">  //   res.render(&quot;list&quot;, &#123; newListItem: item &#125;);  cant put it here, needed to be put in app.get</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Scope"><a href="#Scope" class="headerlink" title="Scope:"></a>Scope:</h1><p>看笔记</p></li></ul><p>for EJS, go to find the Project_todolistV1, i have all the notes in the coding</p><h1 id="Project-Blog"><a href="#Project-Blog" class="headerlink" title="Project_Blog"></a>Project_Blog</h1><h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><p>npm install will go through our package.json and install the dependencies that we’ve already specified.</p><p>this is also the first step you need to do when you pull the coding of a project from github.</p><h3 id="1-render-home-ejs"><a href="#1-render-home-ejs" class="headerlink" title="1. render home.ejs"></a>1. render home.ejs</h3><ul><li>for ejs template, the page we want to render has to be something.ejs and it has to be inside a folder called views, in the root of our main project folder.</li></ul><h3 id="2-pass-the-data-from-app-js-to-home-ejs-template"><a href="#2-pass-the-data-from-app-js-to-home-ejs-template" class="headerlink" title="2. pass the data from app.js to home.ejs template"></a>2. pass the data from app.js to home.ejs template</h3><h3 id="3-add-layout-partails-the-header-ejs-and-the-footer-ejs-to-home-ejs"><a href="#3-add-layout-partails-the-header-ejs-and-the-footer-ejs-to-home-ejs" class="headerlink" title="3. add layout partails, the header.ejs and the footer.ejs to home.ejs"></a>3. add layout partails, the header.ejs and the footer.ejs to home.ejs</h3><p>after this step, we’ll have css style applied to this web page.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you would like to retain vscodes html formatter for html files, but leverage prettier for other files you can set the following in settings.json. ctrl+shift+p</span><br><span class="line"></span><br><span class="line">&quot;editor.formatOnSave&quot;: true,</span><br><span class="line">&quot;[html]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;vscode.html-language-features&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-create-a-partial-folderin-the-views-folder-so-that-we-can-keep-partially-complete-HTML-files-in-it-like-header-and-footer"><a href="#4-create-a-partial-folderin-the-views-folder-so-that-we-can-keep-partially-complete-HTML-files-in-it-like-header-and-footer" class="headerlink" title="4. create a partial folderin the views folder so that we can keep partially complete HTML files in it(like header and footer)"></a>4. create a partial folderin the views folder so that we can keep partially complete HTML files in it(like header and footer)</h3><p>and need to modify  &lt;%- include(“partials&#x2F;header”) -%&gt;</p><h3 id="5-create-other-pages-and-pass-data-into-the-corresponding-pages"><a href="#5-create-other-pages-and-pass-data-into-the-corresponding-pages" class="headerlink" title="5.  create other pages and pass data into the corresponding pages"></a>5.  create other pages and pass data into the corresponding pages</h3><h3 id="6-add-link-to-the-botton"><a href="#6-add-link-to-the-botton" class="headerlink" title="6. add link to the botton"></a>6. add link to the botton</h3><h3 id="7-render-post-page"><a href="#7-render-post-page" class="headerlink" title="7.  render post page"></a>7.  render post page</h3><h3 id="8-get-input-data-of-post-page-in-console"><a href="#8-get-input-data-of-post-page-in-console" class="headerlink" title="8. get input data of post page in console"></a>8. get input data of post page in console</h3><h3 id="9-create-a-javascript-object-that’s-simply-called-post-and-it-store-both-the-title-and-the-postContent"><a href="#9-create-a-javascript-object-that’s-simply-called-post-and-it-store-both-the-title-and-the-postContent" class="headerlink" title="9. create a javascript object that’s simply called post and it store both the title and the postContent"></a>9. create a javascript object that’s simply called post and it store both the title and the postContent</h3><h3 id="10-add-that-post-object-into-an-array"><a href="#10-add-that-post-object-into-an-array" class="headerlink" title="10. add that post object into an array"></a>10. add that post object into an array</h3><h3 id="11-log-the-postContent-into-home-ejs"><a href="#11-log-the-postContent-into-home-ejs" class="headerlink" title="11.  log the postContent into home.ejs"></a>11.  log the postContent into home.ejs</h3><h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p>loop through the array</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(letter)&#123;</span><br><span class="line"></span><br><span class="line">console.log(letter);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="route-parameter"><a href="#route-parameter" class="headerlink" title="route parameter"></a>route parameter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const e = require(&#x27;express&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line">const PORT = 3000;</span><br><span class="line"> </span><br><span class="line">const student = express.Router();</span><br><span class="line">app.use(&#x27;/student&#x27;, student);</span><br><span class="line"> </span><br><span class="line">student.get(&#x27;/profile/:start/:end&#x27;, function (req, res) &#123;</span><br><span class="line">    console.log(&quot;Starting Page: &quot;, req.params.start);</span><br><span class="line">    console.log(&quot;Ending Page: &quot;, req.params.end);</span><br><span class="line">    res.send();</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">app.listen(PORT, function (err) &#123;</span><br><span class="line">    if (err) console.log(err);</span><br><span class="line">    console.log(&quot;Server listening on PORT&quot;, PORT);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>using colon and then we’re going to give our parameter a name.</li></ul><p>if there’s a colon then it’s a parameter. if no colon then it’s just a string</p><p><strong>Output:</strong> Now open your browser and make a GET request to <strong><a href="http://localhost:3000/student/profile/12/17">http://localhost:3000/student/profile/12/17</a></strong>, now you can see the following output on your console:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server listening on PORT 3000</span><br><span class="line">Starting Page:  12</span><br><span class="line">Ending Page:  17</span><br></pre></td></tr></table></figure><h2 id="Lodash-lib"><a href="#Lodash-lib" class="headerlink" title="Lodash lib"></a>Lodash lib</h2><h3 id="12-deal-with-url"><a href="#12-deal-with-url" class="headerlink" title="12. deal with url"></a>12. deal with url</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/post/:title&quot;, function (req, res) &#123;</span><br><span class="line">  const urlTitle = _.lowerCase(req.params.title);</span><br><span class="line">  postList.forEach(function (post) &#123;</span><br><span class="line">    const postTitle = _.lowerCase(post.title);</span><br><span class="line">    if (postTitle === urlTitle) &#123;</span><br><span class="line">      console.log(&quot;match!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="13-when-you-type-x2F-title1-in-url-tab-you-can-open-title1-page-on-web"><a href="#13-when-you-type-x2F-title1-in-url-tab-you-can-open-title1-page-on-web" class="headerlink" title="13. when you type &#x2F;title1 in url tab you can open title1 page on web"></a>13. when you type &#x2F;title1 in url tab you can open title1 page on web</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/post/:title&quot;, function (req, res) &#123;</span><br><span class="line">  const urlTitle = _.lowerCase(req.params.title);</span><br><span class="line">  postList.forEach(function (post) &#123;</span><br><span class="line">    const postTitle = _.lowerCase(post.title);</span><br><span class="line">    if (postTitle === urlTitle) &#123;</span><br><span class="line">      console.log(&quot;match!&quot;);</span><br><span class="line">      res.render(&quot;post&quot;, &#123;</span><br><span class="line">        title: post.title,</span><br><span class="line">        content: post.content,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap</title>
      <link href="/2023/06/06/SoftwareDevelopment/Bootstrap/"/>
      <url>/2023/06/06/SoftwareDevelopment/Bootstrap/</url>
      
        <content type="html"><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><ul><li><p>using bootstrap will make you have a lot of classes in tags which is called class bloat</p></li><li><p>On pc, two columns, on  mobile, 1 colum</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;col-xl-6 col-sm-12&quot;&gt;50% desktop, 100% mobile&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xl-6 col-sm-12&quot;&gt;50% desktop, 100% mobile&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>actually you can delete col-sm-12 ,cause  everything else is defaulted to 100 percent.</p><p>xl-&gt; pc</p><p>sm-&gt; phone</p><ul><li><a href="https://appbrewery.github.io/bootstrap-layout/">https://appbrewery.github.io/bootstrap-layout/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Modify the HTML below to make the blue boxes behave like the red ones. --&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;col-xl-6 col-sm-12 col-8&quot;&gt;Column 1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xl-3 col-sm-6 col-8&quot;&gt;Column 2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xl-3 col-sm-6 col-8&quot;&gt;Column 3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">          &lt;div class=&quot; col-lg-3 col-sm-12&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;images/bizinsider.png&quot; height=&quot;30&quot;&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot;col-lg-3 col-sm-12 &quot;&gt;</span><br><span class="line">            &lt;img src=&quot;images/mashable.png&quot; height=&quot;30&quot;&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot; col-lg-3 col-sm-12&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;img src=&quot;images/techcrunch.png&quot; height=&quot;30&quot;&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot; col-lg-3 col-sm-12&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;images/tnw.png&quot; height=&quot;30&quot;&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>notice:<ol><li>must have <div class="row"></li></ol></li></ul><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><ul><li><p>css:</p><p>utilities.scss -&gt; custom styling</p><p>features.css -&gt; custom css</p></li></ul><h2 id="Spacing"><a href="#Spacing" class="headerlink" title="Spacing:"></a>Spacing:</h2><p>mt-5 : margin-top  5</p><p>my-3: margin- top and bottom</p><p>mb-2: margin-bottom -size 2</p><h2 id="Dark-Mode"><a href="#Dark-Mode" class="headerlink" title="Dark Mode"></a>Dark Mode</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">data-bs-theme</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/06/06/SoftwareDevelopment/Git/"/>
      <url>/2023/06/06/SoftwareDevelopment/Git/</url>
      
        <content type="html"><![CDATA[<h3 id="Local-Git-Repository"><a href="#Local-Git-Repository" class="headerlink" title="Local Git Repository"></a>Local Git Repository</h3><ul><li>remember to run in git bash</li></ul><p>mkdir foldername</p><p>touch filename</p><p>code filename (open the file)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// intialize a git repository</span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line">// see what&#x27;s in staging area</span><br><span class="line">// it can also help to see which file has been modified after last commit</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">// add file to staging area</span><br><span class="line">git add chapter1.txt</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">// remove from staging area</span><br><span class="line">git rm --cached -r filename</span><br><span class="line"></span><br><span class="line">// commit the files</span><br><span class="line">git commit -m &quot;test&quot;</span><br><span class="line"></span><br><span class="line">// see what&#x27;s been commited</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">// compare the difference between working area and local repostory</span><br><span class="line">git diff filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// roll back to the previous version that was committed in our local repository</span><br><span class="line">git checkout chapter3.txt</span><br></pre></td></tr></table></figure><h3 id="Remote-Repository"><a href="#Remote-Repository" class="headerlink" title="Remote Repository"></a>Remote Repository</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// create the remote</span><br><span class="line">git remote add origin https://github.com/DanLovPotato/Test.git </span><br><span class="line"></span><br><span class="line">//push local repository to remote repository</span><br><span class="line">// u option is to link up your remote and local repositories</span><br><span class="line">// origin is the name of remote and master is the name of branch</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="Git-Ignore-do-this-before-git-add"><a href="#Git-Ignore-do-this-before-git-add" class="headerlink" title="Git Ignore(do this before git add)"></a>Git Ignore(do this before git add)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore// you put the file names that you dont want to upload in here</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in gitignore:</span><br><span class="line"></span><br><span class="line">secrets.txt (filename)</span><br><span class="line"># comment (comment)</span><br><span class="line">*.txt (all the txt file wont be uploaded)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> here’s some templates of gitignore templates for different types of projects.</p><p>you usually want to ignore those user related files that are not going to be useful to your collaborators.</p><h3 id="Git-Clone"><a href="#Git-Clone" class="headerlink" title="Git Clone"></a>Git Clone</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/austinzheng/swift-2048.git</span><br></pre></td></tr></table></figure><h3 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// create new branch</span><br><span class="line">git branch name</span><br><span class="line"></span><br><span class="line">//  see what branches you have, and what branch you are on</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">//  switch to the branch</span><br><span class="line">git checkout name</span><br><span class="line"></span><br><span class="line">git merge branchname</span><br><span class="line"></span><br><span class="line">git push origin master -u</span><br></pre></td></tr></table></figure><p>in git log:</p><p>(HEAD -&gt; master) is local repository</p><p>(origin&#x2F;master) is remote repository</p>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="/2023/06/06/SoftwareDevelopment/jQuery/"/>
      <url>/2023/06/06/SoftwareDevelopment/jQuery/</url>
      
        <content type="html"><![CDATA[<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>a library. make js a lot easier.  jQuery takes a lot of common tasks that require many lines of JavaScript code to accomplish, and wraps them into methods that you can call with a single line of code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. document.querySelector(&quot;h1&quot;)  = $(&quot;h1&quot;)</span><br></pre></td></tr></table></figure><h3 id="Incorporate-jQuery"><a href="#Incorporate-jQuery" class="headerlink" title="Incorporate jQuery"></a>Incorporate jQuery</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.7.0/jquery.min.js&quot;&gt;&lt;/script&gt;  //this one is from the website, copy the link</span><br><span class="line">  &lt;script src=&quot;index.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><strong>Place the script tag above the index.js</strong></p><h3 id="Ready-Function"><a href="#Ready-Function" class="headerlink" title="Ready Function"></a>Ready Function</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>if you put the jQuery tag in the head tag instead of the end of the body tag, then you need to use this ready function in js file.  It means that, once our ducument is ready and then we gonna call the call back function.</p><h3 id="Minify"><a href="#Minify" class="headerlink" title="Minify"></a>Minify</h3><p>Minification refers to <strong>the process of removing unnecessary or redundant data without affecting how the resource is processed by the browser</strong> - e.g. code comments and formatting, removing unused code, using shorter variable and function names, and so on.</p><h3 id="Manipulating-Styles"><a href="#Manipulating-Styles" class="headerlink" title="Manipulating Styles"></a>Manipulating Styles</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;h1&quot;).css(&quot;color&quot;, &quot;green&quot;); // setting the value</span><br><span class="line"></span><br><span class="line">console.log($(&quot;h1&quot;).css(&quot;color&quot;)); // getting the value</span><br><span class="line"></span><br><span class="line">$(&quot;h1&quot;).addClass(&quot;big&quot;); //addclass</span><br><span class="line"></span><br><span class="line">$(&quot;h1&quot;).removeClass(&quot;big&quot;);</span><br><span class="line"></span><br><span class="line">$(&quot;h1&quot;).addClass(&quot;big margin&quot;); //add multiple classes</span><br><span class="line"></span><br><span class="line">$(&quot;h1&quot;).hasClass(&quot;big&quot;); // return true</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Manipulating-Text"><a href="#Manipulating-Text" class="headerlink" title="Manipulating Text"></a>Manipulating Text</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;h1&quot;).text(&quot;bye&quot;);  // change text</span><br><span class="line">$(&quot;button&quot;).text(&quot;change&quot;);</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).html(&quot;&lt;em&gt;haha&lt;/em&gt;&quot;); // change HTML</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Manipulating-Attributes"><a href="#Manipulating-Attributes" class="headerlink" title="Manipulating Attributes"></a>Manipulating Attributes</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;drum.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;h1 class=&quot;big margin&quot;&gt;title&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">console.log($(&quot;img&quot;).attr(&quot;src&quot;)); </span><br><span class="line">console.log($(&quot;h1&quot;).attr(&quot;class&quot;)); //get attribute</span><br><span class="line">$(&quot;img&quot;).attr(&quot;src&quot;,&quot;guitar,png&quot;); //set attribute</span><br></pre></td></tr></table></figure><h3 id="Event-Listener"><a href="#Event-Listener" class="headerlink" title="Event Listener"></a>Event Listener</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;h1&quot;).click(function () &#123;</span><br><span class="line">  $(&quot;h1&quot;).css(&quot;color&quot;, &quot;green&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;button&quot;).click(function () &#123;</span><br><span class="line">  $(&quot;h1&quot;).css(&quot;color&quot;, &quot;red&quot;);</span><br><span class="line">&#125;); //jQuery will select all the buttons, don&#x27;t need to use loop</span><br><span class="line"></span><br><span class="line">//keyboard listener</span><br><span class="line">$(&quot;input&quot;).keypress(function (e) &#123;</span><br><span class="line">  console.log(e.key);</span><br><span class="line">&#125;);  // listen to input box</span><br><span class="line"></span><br><span class="line">// listen to the whole web page</span><br><span class="line">$(&quot;body&quot;).keypress(function (e) &#123;</span><br><span class="line">  console.log(e.key);</span><br><span class="line">&#125;);</span><br><span class="line">$(&quot;&quot;).keypress(function (e) &#123;</span><br><span class="line">  console.log(e.key);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(&quot;body&quot;).keypress(function (event) &#123;</span><br><span class="line">  $(&quot;h1&quot;).text(event.key);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="method-On"><a href="#method-On" class="headerlink" title="method On"></a>method On</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;h1&quot;).on(&quot;mouseover&quot;, function () &#123;</span><br><span class="line">  $(&quot;h1&quot;).css(&quot;color&quot;, &quot;green&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">$(&quot;h1&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class="line">  $(&quot;h1&quot;).css(&quot;color&quot;, &quot;green&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="adding-and-removing"><a href="#adding-and-removing" class="headerlink" title="adding and removing"></a>adding and removing</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//before, after -&gt;  add the new element beofre the opening tag of the selected element</span><br><span class="line">$(&quot;h1&quot;).before(&quot;&lt;button&gt;new&lt;/button&gt;&quot;); // create the element before the element we selected</span><br><span class="line">$(&quot;h1&quot;).after(&quot;&lt;button&gt;new&lt;/button&gt;&quot;);</span><br><span class="line"></span><br><span class="line">//prepend -&gt; add the new element just before the content of the h1 and right after the opening tag</span><br><span class="line">$(&quot;h1&quot;).prepend(&quot;&lt;button&gt;new&lt;/button&gt;&quot;);</span><br><span class="line">// added right after the content of h1</span><br><span class="line">$(&quot;h1&quot;).append(&quot;&lt;button&gt;new&lt;/button&gt;&quot;);</span><br><span class="line"></span><br><span class="line">//remove all buttons</span><br><span class="line">$(&quot;button&quot;).remove();</span><br></pre></td></tr></table></figure><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// hide  show</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;,function()&#123;</span><br><span class="line">$(&quot;h1&quot;).hide();</span><br><span class="line">&#125;)</span><br><span class="line">$(&quot;h1&quot;).show();</span><br><span class="line">// click then hide, click again then show again</span><br><span class="line">$(&quot;h1&quot;).toggle();</span><br><span class="line"></span><br><span class="line">// hide slowly</span><br><span class="line">$(&quot;h1&quot;).fadeOut();</span><br><span class="line">$(&quot;h1&quot;).fadeIn();</span><br><span class="line">$(&quot;h1&quot;).fadeToggle();</span><br><span class="line"></span><br><span class="line">//slideupdown</span><br><span class="line">$(&quot;h1&quot;).slideUp();</span><br><span class="line">$(&quot;h1&quot;).slideDown();</span><br><span class="line">$(&quot;h1&quot;).slideToggle();</span><br><span class="line"></span><br><span class="line">//customize</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;,function()&#123;</span><br><span class="line">$(&quot;h1&quot;).animate(&#123;opacity: 0.5&#125;); // this method can only change a numeric value</span><br><span class="line">$(&quot;h1&quot;).slideUp().slideDown().animate(&#123;opacity: 0.5&#125;); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Overview</title>
      <link href="/2023/05/21/SoftwareDevelopment/Overview/"/>
      <url>/2023/05/21/SoftwareDevelopment/Overview/</url>
      
        <content type="html"><![CDATA[<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>Node.js is a server-side runtime environment for running JavaScript code outside the browser, while React.js is a client-side JavaScript library for building user interfaces. Node.js is used for server-side development, while React.js is used for creating interactive UI components in web applications. They can be used together to build full-stack web applications.</p><p>Node.js is perfect for building fast and scalable data intensive apps.</p><p><strong>use</strong>: API with database behind(preferably NoSQL)</p><p><strong>don’t use</strong>: application with heavy server-side processing(CPU-intensive)</p><h3 id="V8-Engine"><a href="#V8-Engine" class="headerlink" title="V8 Engine"></a>V8 Engine</h3><p>V8 is an open-source JavaScript engine developed by Google. It is the engine that powers both the Chrome browser and the Node.js runtime environment. V8 is responsible for executing JavaScript code and translating it into machine code that can be understood and executed by the underlying hardware. It provides high-performance and efficient execution of JavaScript, making it suitable for running JavaScript applications on both the client-side and the server-side.</p><p>That’s where JavaScript will be parsed and run in NodeJS.</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS</title>
      <link href="/2023/05/21/SoftwareDevelopment/NodeJS/"/>
      <url>/2023/05/21/SoftwareDevelopment/NodeJS/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>It’s an asynchronous event driven JavaScript Runtime. it’s designed to build scalable network applications.</p><ul><li>it’s actually not a framework, instead it’s a runtime environment. it enables us to use javescript on a computer and not just limited to wihtin the browser.</li></ul><h2 id="fs-module"><a href="#fs-module" class="headerlink" title="fs module"></a>fs module</h2><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>In JavaScript, the term “fs” typically refers to the “File System” module. The “fs” module is a built-in module in Node.js, which is a JavaScript runtime environment used for server-side applications.</p><p>The “fs” module provides methods and functionality to interact with the file system, allowing you to read from and write to files, create directories, modify file permissions, and perform other file-related operations. It enables you to work with files and directories on your computer or server.</p><p>Here’s an example of how you can use the “fs” module in Node.js to read the contents of a file:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy codeconst fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>In the above example, <code>fs.readFile</code> is used to read the contents of the file named “file.txt” in the current directory. The callback function receives any potential error (<code>err</code>) and the file contents (<code>data</code>). If no error occurs, the contents of the file are printed to the console.</p><p>Note that the “fs” module is specific to Node.js and is not available in web browsers, as JavaScript running in a browser has limited access to the local file system for security reasons.</p><h2 id="Synchronous-vs-Asynchronous"><a href="#Synchronous-vs-Asynchronous" class="headerlink" title="Synchronous vs. Asynchronous"></a>Synchronous vs. Asynchronous</h2><p>Node.JS only has one thread and all the users accessing your application are using this thread.</p><ul><li><p>Synchronous code is also called blocking code because a certain operation can only be executed after the one before has finished.</p><p>eg. readFileSync</p></li><li><p>Asynchronous code is non-blocking code. Asynchronous code is a programming paradigm that allows multiple tasks to be executed concurrently without blocking the execution of the program. While one task is being processed asynchronously, the program can execute other tasks or respond to user input, improving responsiveness and overall performance.</p></li></ul><p>  eg.readFile</p><p>in synchronous, if one user locks the single thread, all the other users need to wait.</p><p>in asynchronous, it does the heavy work in the background, and once the data is available, the call back function will get called in the single thread to access the single data.  At the same time all the users can perform their tasks one after another in the single thread.</p><h3 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h3><p>Callback hell is a situation that arises in asynchronous programming when multiple nested callbacks are used, leading to complex and unreadable code. It occurs when one asynchronous operation depends on the result of another, resulting in deeply nested callback functions.</p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>install npm command: npm init  (type in the terminal opened in the project)</p><p>after installing successfully, there will be a file called package.json</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line"></span><br><span class="line">npm install nodemon --save-dev</span><br><span class="line">// it will automatically restart the server when there&#x27;s a change</span><br></pre></td></tr></table></figure><p>when we ran this command, we install the package locally so it mean it can only work in this project.</p><p>But if you install a package globally then you don’t need to install that package each time you have a new project.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// install globally:</span><br><span class="line"> npm i nodemon --global</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>use nodemon ( globally):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure><h4 id="require-3rd-party-module"><a href="#require-3rd-party-module" class="headerlink" title="require 3rd party module"></a>require 3rd party module</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const slugify = require(&#x27;slugify&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(slugify(&#x27;Fresh Avocado&#x27;, &#123;lower:true&#125;)); //fresh-avocado</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="package-version"><a href="#package-version" class="headerlink" title="package version"></a>package version</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;nodemon&quot;: &quot;^2.0.22&quot;  </span><br><span class="line">&#125;</span><br><span class="line">// ^ means we accept patch and minor fixes  </span><br><span class="line">and ~ means we only accept path releases (safest)</span><br><span class="line">* means we accept all releases (not recommend)</span><br><span class="line">this will affect the outcome when we run npm outdated command</span><br><span class="line">// 2 is major version (the chagne of this number might affect the code we already have )</span><br><span class="line">// 0 is minor version (introduce some new features into the packes, but not including breaking changes, the increase of this number will not break our code )</span><br><span class="line">//22 is the patch version ( is for bug fixs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//update package</span><br><span class="line">npm outdated //will give us a list of packages that are outdated</span><br><span class="line">npm update slugify // will update the version of slugify according to whther it&#x27;s ^ or ~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//delete package</span><br><span class="line">npm uninstall express</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="node-modules-folder"><a href="#node-modules-folder" class="headerlink" title="node_modules folder:"></a>node_modules folder:</h4><p>it has all the dependencies.</p><p>there’s no need to share this folder when you share your code with other people because it’s very big.</p><p><em>when we download someone’s node without this folder, how do we install those dependencies ourselfves</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">// it will read packages.json file read those dependencies and downlaod them all</span><br></pre></td></tr></table></figure><p>package-lock.json file:  it has all the versions and names and details of the packages that we are using.</p><p>when you share your code or you use other people’s code, you want all the versions of those packages to be the same so the code works the same for the everyone.  So make sure you always share both package.json file and package-lock.json</p><h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><ul><li>enter node repo:</li></ul><p>XIANGDANTONG@EGG ~ ❯❯❯ node<br>Welcome to Node.js v16.15.0.<br>Type “.help” for more information.</p><h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p>file system</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//require module</span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">//write a file and save it </span><br><span class="line">fs.writeFile(&quot;messgae.txt&quot;, &quot;hello from nodejs&quot;, (err) =&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(&quot;the file has been saved!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//read a file</span><br><span class="line">fs.readFile(&quot;message.txt&quot;, &quot;utf-8&quot;, (err, data) =&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="npm-node-pacakge-manager"><a href="#npm-node-pacakge-manager" class="headerlink" title="npm (node pacakge manager"></a>npm (node pacakge manager</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> // it brings up the initialization utility, create configuration file which is called the package.json</span><br><span class="line">❯ npm init</span><br></pre></td></tr></table></figure><ul><li>install npm package:</li></ul><p>npm i packagename1 name2 name3 &#x2F;&#x2F; i is short for install</p><ul><li>string interpolation:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var generateName = require(&quot;sillyname&quot;);</span><br><span class="line">var sillyName = generateName();</span><br><span class="line"></span><br><span class="line">console.log(&quot;my name is &quot; + sillyName);</span><br><span class="line">---&gt;console.log(`my name is $&#123;sillyName&#125;`);</span><br></pre></td></tr></table></figure><ul><li><p>CJS -&gt;common JS</p><p>ESM -&gt;ecmascript module</p></li></ul><p><b>another way to require module </b></p><p>CJS or ESM you can only choose one in the project</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package.json:</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">--&gt;&quot;type&quot;: &quot;module&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">... ini</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">js:</span><br><span class="line">//var generateName = require(&quot;sillyname&quot;);</span><br><span class="line"></span><br><span class="line">--&gt;import generateName from &quot;sillyname&quot;;</span><br><span class="line">var sillyName = generateName();</span><br><span class="line">console.log(`my name is $&#123;sillyName&#125;`);</span><br></pre></td></tr></table></figure><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>a javascript framework.</p><ul><li>add module:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure><ul><li><p>creating a server:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//require express module</span><br><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line">// listeing on port 3000</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on port 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>routes:</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//require express module</span><br><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">//what should happen when someone make a get request to the home route</span><br><span class="line">// &quot;/&quot; means home root</span><br><span class="line">// when that request gets made at that home location, then this callback gets triggered and we send the browser a response</span><br><span class="line">app.get(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  res.send(&quot;&lt;h1&gt;hello12&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&quot;/contact&quot;, function (req, res) &#123;</span><br><span class="line">  res.send(&quot;&lt;h1&gt;contact&lt;/h1&gt;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&quot;/about&quot;, function (req, res) &#123;</span><br><span class="line">  res.send(&quot;call me maybe&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// listeing on port 3000</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on port 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="TEMPLATE"><a href="#TEMPLATE" class="headerlink" title="TEMPLATE"></a>TEMPLATE</h1><ul><li><p>Make a new folder </p></li><li><p>Inside the folder, create a new file called <strong>sth.js</strong></p></li><li><p>Set up a new NPM package  npm init -y</p></li><li><p>Using NPM install the <strong>express</strong> module</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br><span class="line"></span><br><span class="line">//require express module</span><br><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.get(&quot;/about&quot;, function (req, res) &#123;</span><br><span class="line">  res.send(&quot;call me maybe&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// listeing on port 3000</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on port 3000&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Require express in your calculator.js </p></li><li><p>Setup express</p></li><li><p>Create a root route get method with app.get()</p></li></ul><h1 id="Body-Parser"><a href="#Body-Parser" class="headerlink" title="Body Parser:"></a>Body Parser:</h1><p>allow us to pass the information that we  get sent from post request.</p><ul><li>install:</li></ul><p>npm i body-parser</p><h1 id="caculator-project"><a href="#caculator-project" class="headerlink" title="caculator project:"></a>caculator project:</h1><p>js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">const app = express();</span><br><span class="line">const bodyParser = require(&quot;body-parser&quot;);</span><br><span class="line"></span><br><span class="line">// trying to grab the information that gets posted to your server from an HTML form</span><br><span class="line">// extended: true -&gt; allow us to post nested objects</span><br><span class="line">app.use(express.urlencoded(&#123; extended: true &#125;)); // it allows us to go to any of our routs and req.body</span><br><span class="line"></span><br><span class="line">app.get(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  //   res.sendFile(&quot;index.html&quot;);</span><br><span class="line">  res.sendFile(__dirname + &quot;/index.html&quot;); // __dirname is a constant that allows us to grab hold of the current file location at any give time</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(&quot;/&quot;, function (req, res) &#123;</span><br><span class="line">  var n1 = Number(req.body.num1);</span><br><span class="line">  var n2 = Number(req.body.num2);</span><br><span class="line">  var ans = n1 + n2;</span><br><span class="line">  //   res.send(&quot;result&quot; + res);</span><br><span class="line">  //   console.log(req.body); //parsed version of http request</span><br><span class="line">  res.send(&quot;result is &quot; + ans);</span><br><span class="line">&#125;);</span><br><span class="line">// listeing on port 3000</span><br><span class="line">app.listen(3000, function () &#123;</span><br><span class="line">  console.log(&quot;listening on port 3000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>html:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;calculator&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;num1&quot; placeholder=&quot;First Number&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; name=&quot;num2&quot; placeholder=&quot;Second Number&quot;&gt;</span><br><span class="line">      &lt;button type=&quot;submit&quot; name=&quot;submit&quot;&gt;Calculate&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="BMI-Caculator"><a href="#BMI-Caculator" class="headerlink" title="BMI Caculator"></a>BMI Caculator</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/bmicalculator&quot;, function (req, res) &#123;</span><br><span class="line">  res.sendFile(__dirname + &quot;/bmiCalculator.html&quot;); </span><br><span class="line">&#125;);</span><br><span class="line">app.post(&quot;/bmicalculator&quot;, function (req, res) &#123;</span><br><span class="line">  var w = parseFloat(req.body.weight);</span><br><span class="line">  var h = parseFloat(req.body.height);</span><br><span class="line">  res.send(w + &quot; &quot; + h);</span><br><span class="line">  res.send(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>frontend</title>
      <link href="/2023/04/03/SoftwareDevelopment/Frontend/"/>
      <url>/2023/04/03/SoftwareDevelopment/Frontend/</url>
      
        <content type="html"><![CDATA[<h3 id="ctrl-tilde-character"><a href="#ctrl-tilde-character" class="headerlink" title="ctrl + tilde character"></a>ctrl + tilde character</h3><p> –&gt; launch the terminal window from within VS Code.</p><h4 id="npx-create-react-app-lt-NAME-gt"><a href="#npx-create-react-app-lt-NAME-gt" class="headerlink" title="npx create-react-app &lt;NAME&gt;"></a>npx create-react-app &lt;NAME&gt;</h4><p>–&gt; When you run the <code>npx create-react-app &lt;NAME&gt;</code> command, it will create a new directory with the name <code>&lt;NAME&gt;</code> in the current directory and set up the basic structure of a React project inside that directory. The resulting project will include all the necessary files and dependencies to start building a React application.</p><h3 id="code"><a href="#code" class="headerlink" title="code ."></a>code .</h3><p>—&gt;is a command that opens the current directory in Visual Studio Code, a popular code editor.</p><p>When you run the <code>code .</code> command in a terminal or command prompt, it will launch Visual Studio Code and open the current directory in a new window. This allows you to easily navigate and edit files in that directory using the features of Visual Studio Code.</p><h3 id="JSON-and-JavaScript"><a href="#JSON-and-JavaScript" class="headerlink" title="JSON and JavaScript"></a>JSON and JavaScript</h3><p>JavaScript is one of the core technologies of the World Wide Web alongside HTML and CSS. <strong>JavaScript</strong> <strong>brings web pages to life</strong>. Without it, modern <a href="https://www.koombea.com/blog/keys-to-ultimate-web-design/">web design</a> would be static and boring. JavaScript is a programming language. It is probably the most important programming language because every aspect of web development is built off of it. This is why it is a core technology of the World Wide Web.</p><p>JSON is short for JavaScript Object Notation. So is JSON JavaScript? Not exactly. <strong>JSON is a data format that is independent of any</strong> <a href="https://www.koombea.com/blog/best-back-end-languages-how-to-choose-the-perfect-one/"><strong>programming language</strong></a><strong>, although it is derived from</strong> <strong>JavaScript</strong>. The bulk of modern programming languages contain code that can generate and parse JSON data. </p><p>A few notes on JSON:</p><ul><li><p>It is a lightweight format for storing and transporting data</p></li><li><p>The syntax is self-describing, making it easy for humans to read and understand</p></li><li><p>Typically, JSON is used when data is sent from a server to a web page</p></li></ul><p> JavaScript and JSON are two completely different things. While JSON is derived from JavaScript, the two are not exactly comparable in any way. However, we can compare JSON to JavaScript objects. These two are more closely related, and they offer us a better comparison. </p>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hash 🌺</title>
      <link href="/2023/03/18/LeetCode/Hash/"/>
      <url>/2023/03/18/LeetCode/Hash/</url>
      
        <content type="html"><![CDATA[<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><ol><li><font color = 'ligreen'> <strong>pros&#x2F;cons</strong></font></li></ol><p><strong>Advantages of Hash:</strong></p><ul><li>Hash provides better <strong>synchronization</strong> than other data structures.</li><li>Hash tables are more efficient than search trees or other data structures.</li><li>Hash provides constant time for <strong>searching, insertion and deletion operations</strong> on average.</li><li>Hash tables are <strong>space-efficient</strong>.</li><li>Most Hash table implementation can <strong>automatically resize itself</strong>.</li><li>Hash tables are easy to use.</li><li>Hash tables offer a <font color = "red"><strong>high-speed data retrieval and manipulation</strong></font>.</li></ul><p><strong>Disadvantages of Hash:</strong></p><ul><li>Hash is inefficient when there are many collisions.</li><li>Hash collisions are practically not be avoided for large set of possible keys.</li><li>Hash does not allow null values. </li><li>Hash tables have a limited capacity and will eventually fill up.</li><li>Hash tables can be complex to implement.</li><li>Hash tables do not maintain the order of elements, which makes it difficult to retrieve elements in a specific order.</li></ul><ol start="2"><li><font color = 'ligreen'> <strong>difference</strong></font></li></ol><ul><li><strong>HashMap:</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import the HashMap class</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Create a HashMap object called capitalCities</span></span><br><span class="line">    HashMap&lt;String, String&gt; capitalCities = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add keys and values (Country, City)</span></span><br><span class="line">    capitalCities.put(<span class="string">&quot;England&quot;</span>, <span class="string">&quot;London&quot;</span>);</span><br><span class="line">    capitalCities.put(<span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;Berlin&quot;</span>);</span><br><span class="line">    capitalCities.put(<span class="string">&quot;Norway&quot;</span>, <span class="string">&quot;Oslo&quot;</span>);</span><br><span class="line">    capitalCities.put(<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Washington DC&quot;</span>);</span><br><span class="line">    System.out.println(capitalCities);</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    capitalCities.get(<span class="string">&quot;England&quot;</span>);</span><br><span class="line">    capitalCities.remove(<span class="string">&quot;England&quot;</span>);</span><br><span class="line">    capitalCities.clear();  </span><br><span class="line">    capitalCities.size();  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Print keys</span></span><br><span class="line">      <span class="keyword">for</span> (String i : capitalCities.keySet()) &#123;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Print values</span></span><br><span class="line">      <span class="keyword">for</span> (String i : capitalCities.values()) &#123;</span><br><span class="line">          System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>HashSet:</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import the HashSet class</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; cars = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">    cars.add(<span class="string">&quot;Volvo&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;Ford&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;Mazda&quot;</span>);</span><br><span class="line">    System.out.println(cars);</span><br><span class="line">      </span><br><span class="line">    cars.contains(<span class="string">&quot;Mazda&quot;</span>);</span><br><span class="line">    cars.remove(<span class="string">&quot;Volvo&quot;</span>);</span><br><span class="line">    <span class="comment">//To remove all items, use the clear() method:</span></span><br><span class="line">    cars.clear();</span><br><span class="line">    cars.size();</span><br><span class="line">    <span class="comment">//Loop through the items of an HashSet with a for-each loop:</span></span><br><span class="line"><span class="keyword">for</span> (String i : cars) &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>ArrayList:</strong></li></ul><p>a resizable array</p><p>ArrayList allows duplicate values in its collection. On other hand duplicate elements are not allowed in Hashset.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      </span><br><span class="line">    ArrayList&lt;String&gt; cars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">      </span><br><span class="line">    cars.add(<span class="string">&quot;Volvo&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;Ford&quot;</span>);</span><br><span class="line">    cars.add(<span class="string">&quot;Mazda&quot;</span>);</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cars.size(); i++) &#123;</span><br><span class="line">      System.out.println(cars.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cars.size(); i++) &#123;</span><br><span class="line">      System.out.println(cars.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//To modify an element, use the set() method and refer to the index number:</span></span><br><span class="line">cars.set(<span class="number">0</span>, <span class="string">&quot;Opel&quot;</span>); </span><br><span class="line"><span class="comment">//To remove an element, use the remove() method and refer to the index number:</span></span><br><span class="line">cars.remove(<span class="number">0</span>); </span><br><span class="line"><span class="comment">//To remove all the elements in the ArrayList, use the clear() method:</span></span><br><span class="line">cars.clear();</span><br><span class="line"><span class="comment">//To find out how many elements an ArrayList have, use the size method:</span></span><br><span class="line">cars.size();</span><br></pre></td></tr></table></figure><h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242. Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/">242. Valid Anagram</a></h2><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Coding:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] mark = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++ )</span><br><span class="line">            mark[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++ )</span><br><span class="line">            mark[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : mark)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="literal">null</span> &amp;&amp; t==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s==<span class="literal">null</span> || t==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; dict = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) dict.put(c, dict.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> dict.getOrDefault(c, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> dict.put(c, count - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1002-Find-Common-Characters"><a href="#1002-Find-Common-Characters" class="headerlink" title="1002. Find Common Characters"></a><a href="https://leetcode.com/problems/find-common-characters/">1002. Find Common Characters</a></h2><p>easy</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure><p><strong>Coding</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">commonChars</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">numb</span> <span class="operator">=</span> words.length;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words.length == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="type">int</span>[] dict = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// first string in the array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words[<span class="number">0</span>].length(); i++)&#123;</span><br><span class="line">            dict[words[<span class="number">0</span>].charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; words[i].length(); j++)&#123;</span><br><span class="line">                temp[words[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//compare ith string to the first string, take the min</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">26</span>; k++)&#123;               </span><br><span class="line">                dict[k]=Math.min(dict[k],temp[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">26</span>; x++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(dict[x] != <span class="number">0</span>)&#123;     <span class="comment">// notice, here we should use while not if</span></span><br><span class="line">                <span class="type">char</span> <span class="variable">res</span> <span class="operator">=</span> (<span class="type">char</span>)(x + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">re</span> <span class="operator">=</span> Character.toString(res);</span><br><span class="line">                result.add(re);   </span><br><span class="line">                dict[x] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList –&gt;  arraylist.add(re);</p><p>StringBuilder –&gt; str.append(“point”);</p><h2 id="349-Intersection-of-Two-Arrays"><a href="#349-Intersection-of-Two-Arrays" class="headerlink" title="349. Intersection of Two Arrays"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a></h2><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; dict = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;(); <span class="comment">// use HashSet cause we don&#x27;t want repetitive number</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            dict.put(i , dict.getOrDefault(i ,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dict.getOrDefault(j,<span class="number">0</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(j);</span><br><span class="line">                dict.put(j , dict.getOrDefault(j, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// convert hashset into int array</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : ans)&#123;  <span class="comment">// you can write --&gt; int i : ans , it is also right</span></span><br><span class="line">            num[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toArray() function:</p><p>​<a href="https://www.geeksforgeeks.org/arraylist-toarray-method-in-java-with-examples/">https://www.geeksforgeeks.org/arraylist-toarray-method-in-java-with-examples/</a></p><h2 id="202-Happy-Number"><a href="#202-Happy-Number" class="headerlink" title="202. Happy Number"></a><a href="https://leetcode.com/problems/happy-number/">202. Happy Number</a></h2><p>easy</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p><p><font color = "red"> <strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。</strong></font></p><p><font color = "red">这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</font></p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><p>coding:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; rec = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt; ();</span><br><span class="line">        <span class="keyword">while</span>( n != <span class="number">1</span> )&#123;</span><br><span class="line">            n = cal(n);</span><br><span class="line">            <span class="keyword">if</span>(rec.contains(n))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                rec.add(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> m % <span class="number">10</span>;</span><br><span class="line">            res += temp * temp;</span><br><span class="line">            m /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h2><p>easy</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,7,11,15], target = 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123; </span><br><span class="line">        HashMap&lt;Integer, Integer&gt; mark = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - num;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mark.containsKey(diff))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;mark.get(diff),i&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                mark.put(num, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>WRONG:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            int addNum = target - nums[i];</span><br><span class="line">            if(map.containsKey(addNum))&#123;</span><br><span class="line">                int[] res = &#123;i, map.get(addNum)&#125;;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here’s an example to illustrate the problem:</p><p>Input:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">makefileCopy codenums = [3, 2, 4, 4]</span><br><span class="line">target = 8</span><br></pre></td></tr></table></figure><p>With your current code, it would return <code>[2, 2]</code> because the number <code>4</code> appears twice in the array, and the <code>HashMap</code> will only store one of the occurrences.</p><h2 id="454-4Sum-II"><a href="#454-4Sum-II" class="headerlink" title="454. 4Sum II"></a><a href="https://leetcode.com/problems/4sum-ii/">454. 4Sum II</a></h2><p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p><ul><li><code>0 &lt;= i, j, k, l &lt; n</code></li><li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li></ul><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">The two tuples are:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure><p>Coding:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; add1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++)&#123;</span><br><span class="line">                add1.put(nums1[i]+nums2[j], add1.getOrDefault(nums1[i]+nums2[j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums3.length; i++)&#123; </span><br><span class="line">        <span class="comment">// you don&#x27;t need another hashmap here to record the sum of nums3 and nums4</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums4.length; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">add2</span> <span class="operator">=</span> nums3[i]+nums4[j];</span><br><span class="line">                <span class="keyword">if</span>(add1.containsKey( <span class="number">0</span> - add2))&#123;</span><br><span class="line">                    res += add1.get(<span class="number">0</span> - add2); <span class="comment">// important</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383. Ransom Note"></a><a href="https://leetcode.com/problems/ransom-note/">383. Ransom Note</a></h2><p>iven two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> <em>if</em> <code>ransomNote</code> <em>can be constructed by using the letters from</em> <code>magazine</code> <em>and</em> <code>false</code> <em>otherwise</em>.</p><p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p>Coding:</p><p><strong>其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！</strong>if you want to record the number that a certain letter appears in a string you can actually just use Array instead of HashMap, it’s simpler and save more space.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++)&#123;</span><br><span class="line">            map.put(magazine.charAt(i), map.getOrDefault(magazine.charAt(i), <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(ransomNote.charAt(i)) )&#123;</span><br><span class="line">                map.put( ransomNote.charAt(i),map.get(ransomNote.charAt(i)) - <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span>(map.get(ransomNote.charAt(i)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// !!! Array !!!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希映射数组</span></span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : record)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// can check if there&#x27;s negative in the last loop. two loops are enough to solve this question.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.com/problems/3sum/">15. 3Sum</a></h2><p>Medium</p><p><strong>Notice that the solution set must not contain duplicate triplets.</strong></p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><p>coding:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"><span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  <span class="comment">// 去重a  </span></span><br><span class="line">        <span class="comment">//notice这里只能是 i - 1不能是 i + 1， 因为如果是i + 1的话，判断的是结果集里面有没有重复的元素eg:&#123;-1,-1,2&#125;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">/* you can also write like this</span></span><br><span class="line"><span class="comment">             while (i &gt; 0 &amp;&amp; i &lt; nums.length &amp;&amp; nums[i] == nums[i - 1]) &#123;  // 去重a  </span></span><br><span class="line"><span class="comment">               i++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right])); <span class="comment">//!!!</span></span><br><span class="line">    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In Java, <code>Arrays.asList</code> is a method that is used to convert an array into a fixed-size list.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class ArrayToListExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // Create an array</span><br><span class="line">        String[] array = &#123;&quot;Java&quot;, &quot;is&quot;, &quot;awesome&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        // Convert the array to a list</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line">        // Now you can work with the list</span><br><span class="line">        System.out.println(&quot;List elements: &quot; + list);</span><br><span class="line"></span><br><span class="line">        // Note that this list is backed by the original array, so changes to the list</span><br><span class="line">        // will affect the array, and vice versa</span><br><span class="line">        list.set(1, &quot;rocks&quot;);</span><br><span class="line">        System.out.println(&quot;Updated list: &quot; + list);</span><br><span class="line">        System.out.println(&quot;Original array: &quot; + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a><a href="https://leetcode.com/problems/4sum/">18. 4Sum</a></h3><p>Medium</p><p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,2,2,2,2], target = 8</span><br><span class="line">Output: [[2,2,2,2]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">       </span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // nums[i] &gt; target 直接返回, 剪枝操作 !!!!</span><br><span class="line">            //两个条件缺一不可</span><br><span class="line">            if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) &#123;    // 对nums[i]去重</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for (int j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) &#123;  // 对nums[j]去重</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int left = j + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while (right &gt; left) &#123;</span><br><span class="line">    // nums[k] + nums[i] + nums[left] + nums[right] &gt; target int会溢出</span><br><span class="line">                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        // 对nums[left]和nums[right]去重</span><br><span class="line">                        while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                        while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a><a href="https://leetcode.com/problems/integer-to-roman/">12. Integer to Roman</a></h3><p>Medium</p><p>Roman numerals are represented by seven different symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>For example, <code>2</code> is written as <code>II</code> in Roman numeral, just two one’s added together. <code>12</code> is written as <code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p><ul><li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9. </li><li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90. </li><li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li></ul><p>Given an integer, convert it to a roman numeral.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        String[] symbols = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &gt;= values[i]) &#123;</span><br><span class="line">                num -= values[i];</span><br><span class="line">                res.append(symbols[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/">128. Longest Consecutive Sequence</a></h3><p>Medium</p><p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p><p>You must write an algorithm that runs in <code>O(n)</code> time.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [100,4,200,1,3,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(nums[i]))&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> map.getOrDefault(nums[i] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> map.getOrDefault(nums[i] + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left + right + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//renew the map inf</span></span><br><span class="line">                map.put(nums[i], sum);</span><br><span class="line">                map.put(nums[i] - left, sum);<span class="comment">// notice here you should substract left not substract 1. cause there might be more than one consecutive numbers.</span></span><br><span class="line">                map.put(nums[i] + right, sum);</span><br><span class="line"></span><br><span class="line">                res = Math.max(res, sum);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="187-Repeated-DNA-Sequences"><a href="#187-Repeated-DNA-Sequences" class="headerlink" title="187. Repeated DNA Sequences"></a><a href="https://leetcode.com/problems/repeated-dna-sequences/">187. Repeated DNA Sequences</a></h3><p>Medium</p><p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p><ul><li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li></ul><p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p><p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">Output: [&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;AAAAAAAAAAAAA&quot;</span><br><span class="line">Output: [&quot;AAAAAAAAAA&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        HashSet&lt;String&gt; map = new HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; ress = new HashSet&lt;&gt;(); // to get rid of duplicates</span><br><span class="line">        for(int i = 0; i &lt; s.length() - 9; i++)&#123;</span><br><span class="line">        //!!!! -9  not  - 10</span><br><span class="line">        //think about s.length = 11, it should loop twice</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            for(int j = i; j &lt; i+10; j++)&#123;</span><br><span class="line">                sb.append(s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            String dna = sb.toString();</span><br><span class="line">            if(map.contains(dna))&#123;</span><br><span class="line">                ress.add(dna);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.add(dna);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return new ArrayList&lt;&gt;(ress); //!!!!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">improve:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123;</span><br><span class="line">        HashSet&lt;String&gt; map = new HashSet&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; res = new HashSet&lt;&gt;();</span><br><span class="line">        for(int i = 0; i &lt; s.length() - 9; i++)&#123;</span><br><span class="line">            String dna = s.substring(i, i+10);</span><br><span class="line">            //!!!! not subString</span><br><span class="line">            if(map.contains(dna))&#123;</span><br><span class="line">                res.add(dna);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.add(dna);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        return new ArrayList&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a><a href="https://leetcode.com/problems/bulls-and-cows/">299. Bulls and Cows</a></h3><p>Medium</p><p>You are playing the <strong><a href="https://en.wikipedia.org/wiki/Bulls_and_Cows">Bulls and Cows</a></strong> game with your friend.</p><p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p><ul><li>The number of “bulls”, which are digits in the guess that are in the correct position.</li><li>The number of “cows”, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li></ul><p>Given the secret number <code>secret</code> and your friend’s guess <code>guess</code>, return <em>the hint for your friend’s guess</em>.</p><p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line">Output: &quot;1A3B&quot;</span><br><span class="line">Explanation: Bulls are connected with a &#x27;|&#x27; and cows are underlined:</span><br><span class="line">&quot;1807&quot;</span><br><span class="line">  |</span><br><span class="line">&quot;7810&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line">Output: &quot;1A1B&quot;</span><br><span class="line">Explanation: Bulls are connected with a &#x27;|&#x27; and cows are underlined:</span><br><span class="line">&quot;1123&quot;        &quot;1123&quot;</span><br><span class="line">  |      or     |</span><br><span class="line">&quot;0111&quot;        &quot;0111&quot;</span><br><span class="line">Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHint</span><span class="params">(String secret, String guess)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = secret.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] g = guess.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] sc = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span>[] gc = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == g[i]) &#123;</span><br><span class="line">                A++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sc[s[i] - <span class="string">&#x27;0&#x27;</span>] ++;</span><br><span class="line">                gc[g[i] - <span class="string">&#x27;0&#x27;</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            B += Math.min(sc[i], gc[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Integer.toString(A) + <span class="string">&quot;A&quot;</span> + Integer.toString(B) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//IMPROVE:</span></span><br><span class="line">        <span class="comment">//return A + &quot;A&quot; + B + &quot;B&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="781-Rabbits-in-Forest"><a href="#781-Rabbits-in-Forest" class="headerlink" title="781. Rabbits in Forest"></a><a href="https://leetcode.com/problems/rabbits-in-forest/">781. Rabbits in Forest</a></h3><p>Medium</p><p>There is a forest with an unknown number of rabbits. We asked n rabbits <strong>“How many rabbits have the same color as you?”</strong> and collected the answers in an integer array <code>answers</code> where <code>answers[i]</code> is the answer of the <code>ith</code> rabbit.</p><p>Given the array <code>answers</code>, return <em>the minimum number of rabbits that could be in the forest</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: answers = [1,1,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The two rabbits that answered &quot;1&quot; could both be the same color, say red.</span><br><span class="line">The rabbit that answered &quot;2&quot; can&#x27;t be red or the answers would be inconsistent.</span><br><span class="line">Say the rabbit that answered &quot;2&quot; was blue.</span><br><span class="line">Then there should be 2 other blue rabbits in the forest that didn&#x27;t answer into the array.</span><br><span class="line">The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&#x27;t.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: answers = [10,10,10]</span><br><span class="line">Output: 11</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numRabbits(int[] answers) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0 ; i &lt; answers.length; i++)&#123;</span><br><span class="line">            if(answers[i] == 0) res+= 1;</span><br><span class="line">            else if(!map.containsKey(answers[i]))&#123;</span><br><span class="line">                res += answers[i] + 1;</span><br><span class="line">                 map.put(answers[i],1);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123; </span><br><span class="line">               if(map.get(answers[i])&gt;= 1 + answers[i])&#123;</span><br><span class="line">               //notice here is &gt;= not &gt;</span><br><span class="line">               // this if statement is very important</span><br><span class="line">                   res += answers[i] + 1;</span><br><span class="line">                    map.put(answers[i],1);</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   map.put(answers[i],map.get(answers[i])+1);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.this question is simple but hard to think about the situation like <strong>[0,0,1,1,1]</strong></p><ol start="2"><li>use if elseif else, it easy to get in trouble to use if if if sometimes:</li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//wrong version, spent quite a few mintues to debug, it&#x27;s tricky</span><br><span class="line">public class MyClass &#123;</span><br><span class="line">    public int numRabbits(int[] answers) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; map = new HashSet&lt;&gt;();</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0 ; i &lt; answers.length; i++)&#123;</span><br><span class="line">            if(answers[i] == 0) res+= 1;</span><br><span class="line">            //!!!</span><br><span class="line">            if(!map.contains(answers[i]))&#123;</span><br><span class="line">                res += answers[i] + 1;</span><br><span class="line">                 map.add(answers[i]);</span><br><span class="line">                 System.out.println(&quot;loop&quot; + i + &quot;is&quot;+ answers[i]+&quot;    +1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if(map.contains(answers[i]))&#123;</span><br><span class="line">                System.out.println(&quot;loop&quot; + i + &quot;is&quot;+ answers[i]+&quot;      +0&quot;);</span><br><span class="line">               continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">      </span><br><span class="line">        MyClass myClass = new MyClass();</span><br><span class="line">      System.out.println(myClass.numRabbits(new int[]&#123;1, 0, 1, 0, 0&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>notice this kind of input:</strong></p><p><strong>answers &#x3D;</strong></p><p><strong>[0,0,1,1,1]</strong></p><p><strong>Expected</strong></p><p><strong>6</strong></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hash 🌺</title>
      <link href="/2023/03/18/LeetCode/String/"/>
      <url>/2023/03/18/LeetCode/String/</url>
      
        <content type="html"><![CDATA[<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#string -&gt; char</span><br><span class="line">char[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">#charArray -&gt; string</span><br><span class="line">return new String(ch);</span><br><span class="line"></span><br><span class="line">char[] charArray = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;&#125;;</span><br><span class="line">     String str = new String(charArray);</span><br><span class="line"></span><br><span class="line">#char -&gt; string:</span><br><span class="line">char myChar = &#x27;A&#x27;;</span><br><span class="line">String myString = &quot;&quot; + myChar;</span><br><span class="line">String myString = Character.toString(myChar);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># string -&gt; stringbuilder</span><br><span class="line">String originalString = &quot;Hello, World&quot;;</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder(originalString);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># declare:</span><br><span class="line">String a = &quot;abc&quot;;</span><br><span class="line">char b = &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line"># StringBuilder:</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(&quot;haha&quot;);</span><br><span class="line">return sb.toString();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><h3 id="541-Reverse-String-II"><a href="#541-Reverse-String-II" class="headerlink" title="541. Reverse String II"></a><a href="https://leetcode.com/problems/reverse-string-ii/">541. Reverse String II</a></h3><p>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p><p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code> characters and leave the other as original.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">Output: &quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><p>最开始为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p><p>其实在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i += <span class="number">2</span>*k)&#123; <span class="comment">// notice here it&#x27;s 2*k</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> i; <span class="comment">// !!important, here you need to modify head, cant modify i directly!!!!</span></span><br><span class="line">            <span class="type">int</span> end;</span><br><span class="line">            <span class="keyword">if</span>(i+k-<span class="number">1</span> &lt; s.length() -<span class="number">1</span>)&#123;</span><br><span class="line">                end = i + k - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = s.length() - <span class="number">1</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">            <span class="keyword">while</span>(head &lt; end)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> c[head];</span><br><span class="line">                c[head] = c[end];</span><br><span class="line">                c[end] = temp;</span><br><span class="line">                head++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);  <span class="comment">// notice</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">wrong:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseStr(String s, int k) &#123;</span><br><span class="line">        char[] c = s.toCharArray();</span><br><span class="line">        int start = 0;</span><br><span class="line">        while(start &lt; c.length )&#123;</span><br><span class="line">             int end = Math.min(start + k - 1, c.length - 1);</span><br><span class="line">            while(start &lt;= end)&#123;</span><br><span class="line">                char temp = c[start];</span><br><span class="line">                c[start] = c[end];</span><br><span class="line">                c[end] = temp;</span><br><span class="line">                start ++;</span><br><span class="line">                end --;</span><br><span class="line">            &#125;</span><br><span class="line">            start += 2*k ;</span><br><span class="line">        &#125;</span><br><span class="line">        s = new String(c);</span><br><span class="line">        return s;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">modified:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseStr(String s, int k) &#123;</span><br><span class="line">        char[] c = s.toCharArray();</span><br><span class="line">        int start = 0;</span><br><span class="line">        while(start &lt; c.length )&#123;</span><br><span class="line">             int end = Math.min(start + k - 1, c.length - 1);</span><br><span class="line">            int start1 = start; //!!!!</span><br><span class="line">            int end1 = end;</span><br><span class="line">            while(start1 &lt;= end1)&#123;</span><br><span class="line">                char temp = c[start1];</span><br><span class="line">                c[start1] = c[end1];</span><br><span class="line">                c[end1] = temp;</span><br><span class="line">                start1 ++;</span><br><span class="line">                end1 --;</span><br><span class="line">            &#125;</span><br><span class="line">            start += 2*k ;</span><br><span class="line">        &#125;</span><br><span class="line">        s = new String(c);</span><br><span class="line">        return s;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p>easy</p><p><strong>EXAMPLE：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><p>CODE:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String replaceSpace(String s) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        char[] mid = s.toCharArray();</span><br><span class="line">        for(int i = 0; i &lt; mid.length; i ++)&#123;</span><br><span class="line">            if( mid[i] == &#x27; &#x27;)</span><br><span class="line">                sb.append(&quot;%20&quot;);</span><br><span class="line">            else</span><br><span class="line">                sb.append( mid[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方式二：双指针法</span><br><span class="line">public String replaceSpace(String s) &#123;</span><br><span class="line">    if(s == null || s.length() == 0)&#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //扩充空间，空格数量2倍</span><br><span class="line">    StringBuilder str = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">        if(s.charAt(i) == &#x27; &#x27;)&#123;</span><br><span class="line">            str.append(&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //若是没有空格直接返回</span><br><span class="line">    if(str.length() == 0)&#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    //有空格情况 定义两个指针</span><br><span class="line">    int left = s.length() - 1;//左指针：指向原始字符串最后一个位置</span><br><span class="line">    s += str.toString();</span><br><span class="line">    int right = s.length()-1;//右指针：指向扩展字符串的最后一个位置</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    while(left&gt;=0)&#123;</span><br><span class="line">        if(chars[left] == &#x27; &#x27;)&#123;</span><br><span class="line">            chars[right--] = &#x27;0&#x27;;</span><br><span class="line">            chars[right--] = &#x27;2&#x27;;</span><br><span class="line">            chars[right] = &#x27;%&#x27;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            chars[right] = chars[left];</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    return new String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></h3><p>Medium</p><p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p><p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p><p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p><p><strong>Note</strong> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;  hello world  &quot;</span><br><span class="line">Output: &quot;world hello&quot;</span><br><span class="line">Explanation: Your reversed string should not contain leading or trailing spaces.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static StringBuilder removeSpace(String s)&#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int start = 0 ;</span><br><span class="line">        int end = s.length() - 1;</span><br><span class="line">        while(s.charAt(start) ==(&#x27; &#x27;)) start++;</span><br><span class="line">        while(s.charAt(end) ==(&#x27; &#x27;)) end--;</span><br><span class="line">        for(int i = start ; i &lt;= end; i++)&#123;</span><br><span class="line">            if(s.charAt(i) != &#x27; &#x27;)&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            if(s.charAt(i) == &#x27; &#x27; &amp;&amp; s.charAt(i-1) != &#x27; &#x27;)&#123; //!!!!</span><br><span class="line">                sb.append(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reverse(StringBuilder sb, int start, int end)&#123;</span><br><span class="line"></span><br><span class="line">        while( start &lt; end)&#123;</span><br><span class="line">            char temp = sb.charAt(end);</span><br><span class="line">            sb.setCharAt(end , sb.charAt(start));</span><br><span class="line">            sb.setCharAt(start, temp);</span><br><span class="line">            start ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuilder temp =  removeSpace(s);     </span><br><span class="line">        reverse(temp, 0 , temp.length()-1);</span><br><span class="line">    //reverse each single word</span><br><span class="line">       int start = 0;</span><br><span class="line">       int end = 0;</span><br><span class="line">       for( int i = 0 ; i &lt; temp.length(); i ++)&#123;</span><br><span class="line">           if(temp.charAt(i)!= &#x27; &#x27; )&#123;</span><br><span class="line">               end = i;</span><br><span class="line">           &#125;</span><br><span class="line">           if (temp.charAt(i) == &#x27; &#x27; || i == temp.length() - 1) &#123;  </span><br><span class="line">               reverse(temp, start, end);</span><br><span class="line">               start = i + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        return temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>second attempt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public static String reverseWords(String s)&#123;</span><br><span class="line">       String ss = reverse(s, 0, s.length() - 1);</span><br><span class="line">       for(int i = 0; i &lt; ss.length(); i++)&#123;</span><br><span class="line">           </span><br><span class="line">           if(ss.charAt(i) != &#x27; &#x27;)&#123;</span><br><span class="line">               int start = i;</span><br><span class="line">           </span><br><span class="line">           while(i &lt; ss.length() &amp;&amp; ss.charAt(i) != &#x27; &#x27;)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">            i --;</span><br><span class="line">           ss = reverse(ss, start, Math.min(i, s.length()-1));</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        return removeSpace(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    public static String removeSpace(String s)&#123;</span><br><span class="line">        char[] ss = s.trim().toCharArray(); //!!!!!</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for( int i = 0 ; i &lt; ss.length; i++)&#123;</span><br><span class="line">            if(ss[i] != &#x27; &#x27;) sb.append(ss[i]);</span><br><span class="line">            if(ss[i] == &#x27; &#x27;)&#123;</span><br><span class="line">                sb.append(&#x27; &#x27;);</span><br><span class="line">                while(i &lt; s.length() &amp;&amp; ss[i] == &#x27; &#x27;)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String reverse(String s, int start, int end)&#123;</span><br><span class="line">        char[] ss = s.toCharArray();</span><br><span class="line">        while (start &lt;= end) &#123;</span><br><span class="line">            char temp = ss[start];</span><br><span class="line">            ss[start] = ss[end];</span><br><span class="line">            ss[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="https-github-com-youngyangyang04-leetcode-master-blob-master-problems-E5-89-91-E6-8C-87Offer58-II-E5-B7-A6-E6-97-8B-E8-BD-AC-E5-AD-97-E7-AC-A6-E4-B8-B2-md-旋转字符-gt-善用reverse函数！！！"><a href="#https-github-com-youngyangyang04-leetcode-master-blob-master-problems-E5-89-91-E6-8C-87Offer58-II-E5-B7-A6-E6-97-8B-E8-BD-AC-E5-AD-97-E7-AC-A6-E4-B8-B2-md-旋转字符-gt-善用reverse函数！！！" class="headerlink" title="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md 旋转字符-&gt;善用reverse函数！！！"></a><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.md</a> 旋转字符-&gt;善用reverse函数！！！</h3><h3 id="459-Repeated-Substring-Pattern"><a href="#459-Repeated-Substring-Pattern" class="headerlink" title="459. Repeated Substring Pattern"></a><a href="https://leetcode.com/problems/repeated-substring-pattern/">459. Repeated Substring Pattern</a></h3><p>Easy</p><p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abab&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It is the substring &quot;ab&quot; twice.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;aba&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcabcabcabc&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) &#123;</span><br><span class="line">        //if(s.length() &lt;= 1) return false;</span><br><span class="line">        char start = s.charAt(0);</span><br><span class="line">        char end = s.charAt(s.length() - 1);</span><br><span class="line">        char[] sray = s.toCharArray();</span><br><span class="line">        for(int i = 0; i &lt;= sray.length/2; i++)&#123;</span><br><span class="line">            if(sray[i] == end)&#123;</span><br><span class="line">                int left = 0;</span><br><span class="line">                int right = i;</span><br><span class="line">                int len = i + 1;</span><br><span class="line">                int loop = 0;</span><br><span class="line">                while(right &lt; sray.length)&#123;</span><br><span class="line">                    if(!s.substring(left,right + 1).equals(s.substring(0, i+1)))&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        left += len ;</span><br><span class="line">                        right += len ;</span><br><span class="line">                        loop ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(right &gt; sray.length-1  &amp;&amp; left &gt; sray.length-1 &amp;&amp; loop &gt; 1) return true;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a><a href="https://leetcode.com/problems/count-and-say/">38. Count and Say</a></h3><p>Medium</p><p>The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li><code>countAndSay(1) = &quot;1&quot;</code></li><li><code>countAndSay(n)</code> is the way you would “say” the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p><p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p><p><img src="https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg" alt="img"></p><p>Given a positive integer <code>n</code>, return <em>the</em> <code>nth</code> <em>term of the <strong>count-and-say</strong> sequence</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Input: n = 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = say &quot;1&quot; = one 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = say &quot;11&quot; = two 1&#x27;s = &quot;21&quot;</span><br><span class="line">countAndSay(4) = say &quot;21&quot; = one 2 + one 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> countAndSay(n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; ans.length())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ans.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span> &lt; ans.length() &amp;&amp; ans.charAt(i+<span class="number">1</span>)==temp)&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(count);</span><br><span class="line">            sb.append(temp);</span><br><span class="line">            i++;  <span class="comment">// important </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList</title>
      <link href="/2023/03/08/LeetCode/LinkedList/"/>
      <url>/2023/03/08/LeetCode/LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="Linked-List-🌼"><a href="#Linked-List-🌼" class="headerlink" title="Linked List 🌼"></a>Linked List 🌼</h1><h2 id="203-Remove-Linked-List-Elements"><a href="#203-Remove-Linked-List-Elements" class="headerlink" title="203. Remove Linked List Elements"></a><a href="https://leetcode.com/problems/remove-linked-list-elements/">203. Remove Linked List Elements</a></h2><p>Easy</p><ul><li><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure></li></ul><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *!!! dummy head is always very handy , try to use it as much as possible</span></span><br><span class="line"><span class="comment"> * 添加虚节点方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为删除可能涉及到头节点，所以设置dummy节点，统一操作</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next; <span class="comment">//!!!! notice, here you want to return dummy.next not head</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不添加虚拟节点方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经为null，提前退出</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已确定当前head.val != val</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不添加虚拟节点and pre Node方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度 O(1)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MY WAY:</span></span><br><span class="line">  <span class="comment">//this step is to delete all the val that is in the beginning og the list</span></span><br><span class="line"> <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val) </span><br><span class="line"><span class="comment">/* this step is necessary because when you go through the list</span></span><br><span class="line"><span class="comment">   current list can only delete its next list, can&#x27;t delete itself. */</span></span><br><span class="line">      head = head.next; </span><br><span class="line"> <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line"> <span class="keyword">while</span>(curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span>(curr.next.val == val )</span><br><span class="line">          curr.next = curr.next.next;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">           curr = curr.next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure><h2 id="707-Design-Linked-List"><a href="#707-Design-Linked-List" class="headerlink" title="707. Design Linked List"></a><a href="https://leetcode.com/problems/design-linked-list/">707. Design Linked List</a></h2><p>medium</p><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// dummy head</span></span><br><span class="line">    ListNode head;</span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//initialize linkedlist</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// notice its  &gt;=</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index+<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="comment">// notice its index + 1 not index</span></span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">        <span class="comment">//or</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newHead.next = head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        size++; <span class="comment">//!!!!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// notice its  &gt; not  &gt;=</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span>  <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; index; i++)&#123;</span><br><span class="line">            <span class="comment">// notice its  &lt; index not &lt;= index</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = node;</span><br><span class="line">        node.next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span>  <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">cur</span>  <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; index; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a><a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></h2><p>easy</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/9e604579b33a236aad08d105b68cc2bab10d8b24d5d34a20536a732389f3979b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3230362e2545372542462542422545382542442541432545392539332542452545382541312541382e676966"><img src="https://camo.githubusercontent.com/9e604579b33a236aad08d105b68cc2bab10d8b24d5d34a20536a732389f3979b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3230362e2545372542462542422545382542442541432545392539332542452545382541312541382e676966" alt="img"></a></p><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            temp = cur.next; <span class="comment">//notice: here need a temp to keep track of cur.next</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;  </span><br><span class="line">        <span class="comment">//return pre not cur, cause cur is the null linkedNote after the whole linkedList</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></h2><p>Medium</p><p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4]</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><p><a href="https://camo.githubusercontent.com/5cb49cd4d54b499130cd5de4ac3c58b8bcf273f2185bf4712d29f536f66aa795/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f32342e254534254238254134254534254238254134254534254241254134254536253844254132254539253933254245254538254131254138254534254238254144254537253941253834254538253841253832254537253832254239322e706e67"><img src="https://camo.githubusercontent.com/5cb49cd4d54b499130cd5de4ac3c58b8bcf273f2185bf4712d29f536f66aa795/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f32342e254534254238254134254534254238254134254534254241254134254536253844254132254539253933254245254538254131254138254534254238254144254537253941253834254538253841253832254537253832254239322e706e67" alt="24.两两交换链表中的节点2"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!! Draw a graph then you will see why this method is stupidly wrong.</span></span><br><span class="line"><span class="comment">// Here we have to use a dummy head.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstnode</span> <span class="operator">=</span> head;</span><br><span class="line">        ListNode temp; </span><br><span class="line">        ListNode secondnode; </span><br><span class="line">        <span class="keyword">while</span> (firstnode != <span class="literal">null</span> &amp;&amp; firstnode.next != <span class="literal">null</span> &amp;&amp; firstnode.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = firstnode.next.next;</span><br><span class="line">            secondnode = firstnode.next;</span><br><span class="line">   </span><br><span class="line">            secondnode.next = firstnode; </span><br><span class="line">            firstnode.next = temp.next;      </span><br><span class="line">            firstnode = temp; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Below is the right solution (=</span></span><br><span class="line"><span class="comment">// if you use dummy head then you don&#x27;t need to cosider the special situations like the start of the link and the end of the link. It makes coding more simple</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">firstnode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">secondnode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(); </span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            firstnode = cur.next;</span><br><span class="line">            secondnode = cur.next.next;</span><br><span class="line">            temp = cur.next.next.next;</span><br><span class="line">            cur.next = secondnode;</span><br><span class="line">            secondnode.next = firstnode;</span><br><span class="line">            firstnode.next = temp;</span><br><span class="line">            cur = firstnode;  <span class="comment">//!!!notice here&#x27;s firstnode not secondnode!!!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>second try, even it’s right, but you need to consider a lot of situations which  makes the coding complicated.这个方法每次循环横跨了四个linkedlist.</p><p>therefore, the first approach is way better</p><p>so when you do the  loop, you dont want the 循环跨度太大，不然你得考虑很多特殊情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        // Check if the list is empty or has only one element</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Initialize the result as the second node</span><br><span class="line">        ListNode res = head.next;</span><br><span class="line"></span><br><span class="line">        // Initialize pointers for swapping</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = head.next;</span><br><span class="line">        ListNode third = head.next.next;</span><br><span class="line"></span><br><span class="line">        // Swap pairs while traversing the list</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // Swap the first and second nodes</span><br><span class="line">            second.next = first;</span><br><span class="line"></span><br><span class="line">            // Check if there&#x27;s a third node</span><br><span class="line">            if (third != null) &#123;</span><br><span class="line">                // Check if there&#x27;s a fourth node</span><br><span class="line">                if (third.next != null) &#123;</span><br><span class="line">                    first.next = third.next;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    first.next = third;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                first.next = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If there are no more nodes to swap, return the result</span><br><span class="line">            if (first.next == null) &#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Update pointers for the next pair of nodes</span><br><span class="line">            first = third;</span><br><span class="line">            second = first.next;</span><br><span class="line"></span><br><span class="line">            // Check if there&#x27;s a third node for the next pair</span><br><span class="line">            if (second.next != null) &#123;</span><br><span class="line">                third = second.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                third = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></h2><p>easy</p><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">handler</span> <span class="operator">=</span> head; <span class="comment">// head不动 handler动</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                handler.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            handler = handler.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            handler.next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            handler.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></h2><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], n = 2</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure><p>Coding: </p><p>my method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">count</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// caculate the length of the list</span></span><br><span class="line">        <span class="keyword">while</span>(count.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            count = count.next;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>)&#123; </span><br><span class="line">            <span class="comment">//the lostnode only has one element</span></span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get to the note which is right before the one that is going to be deleted</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">delete</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i  &lt; m - n ; i ++)&#123;</span><br><span class="line">            delete = delete.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//delete the last element</span></span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">1</span> )&#123; </span><br><span class="line">            delete.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// delete the first element</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( n == m)&#123; </span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//delete the element in between</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            delete.next = delete.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Improvement: don’t need to consider the start and the end of the linked list.</p><ul><li>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： <a href="https://camo.githubusercontent.com/e72dccc9875eaf57a33bdf1a36510766d337610fa7ef4275c3ee222ed18378e2/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f31392e2545352538382541302545392539392541342545392539332542452545382541312541382545372539412538342545352538302539322545362539352542302545372541432541434e254534254238254141254538253841253832254537253832254239312e706e67"><img src="https://camo.githubusercontent.com/e72dccc9875eaf57a33bdf1a36510766d337610fa7ef4275c3ee222ed18378e2/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f31392e2545352538382541302545392539392541342545392539332542452545382541312541382545372539412538342545352538302539322545362539352542302545372541432541434e254534254238254141254538253841253832254537253832254239312e706e67" alt="img"></a></li><li>fast和slow同时移动，直到fast指向末尾，如题： <a href="https://camo.githubusercontent.com/a87d8fe4ab540edbabb211120bec75af0950517c76bb7a72018a93f6ef2984cc/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f31392e2545352538382541302545392539392541342545392539332542452545382541312541382545372539412538342545352538302539322545362539352542302545372541432541434e254534254238254141254538253841253832254537253832254239322e706e67"><img src="https://camo.githubusercontent.com/a87d8fe4ab540edbabb211120bec75af0950517c76bb7a72018a93f6ef2984cc/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f31392e2545352538382541302545392539392541342545392539332542452545382541312541382545372539412538342545352538302539322545362539352542302545372541432541434e254534254238254141254538253841253832254537253832254239322e706e67" alt="img"></a></li><li>删除slow指向的下一个节点，如图： <a href="https://camo.githubusercontent.com/149d85b95226a405592b9ba31324980ea183b936aead1617bdd51bb05f23508b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f31392e2545352538382541302545392539392541342545392539332542452545382541312541382545372539412538342545352538302539322545362539352542302545372541432541434e254534254238254141254538253841253832254537253832254239332e706e67"><img src="https://camo.githubusercontent.com/149d85b95226a405592b9ba31324980ea183b936aead1617bdd51bb05f23508b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f31392e2545352538382541302545392539392541342545392539332542452545382541312541382545372539412538342545352538302539322545362539352542302545372541432541434e254534254238254141254538253841253832254537253832254239332e706e67" alt="img"></a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">         </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// notice, here&#x27;s i&lt;n not i&lt;n+t 画图就知道了</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next; <span class="comment">// if wite return head , it&#x27;s wrong (head = [1], 1 can&#x27;t pass)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></h2><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Intersected at &#x27;8&#x27;</span><br><span class="line">Explanation: The intersected node&#x27;s value is 8 (note that this must not be 0 if the two lists intersect).</span><br><span class="line">From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br><span class="line"><span class="bullet">-</span> Note that the intersected node&#x27;s value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">//  length of A</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        curA.next = headA;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( curA.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//  length of B</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        curB.next = headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( curB.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap A and B if a.len &lt; b.len</span></span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp = lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = temp;</span><br><span class="line">            curA = headB;</span><br><span class="line">            curB = headA;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curA = headA;</span><br><span class="line">            curB = headB;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// length gap</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> lenA - lenB;</span><br><span class="line">        <span class="comment">// make cur A and B at the same place of the list</span></span><br><span class="line">        <span class="keyword">while</span>(gap != <span class="number">0</span>)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            gap--;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// find the same element </span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;  <span class="comment">// it&#x27;s curA == curB NOT curA.val == curB.val</span></span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></h2><p><strong>Example :</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md</a></p><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p><p><a href="https://camo.githubusercontent.com/74c0180eec6d7396d787acd1f237765f7852397896c4c431babafe21d655f376/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303232303932353130333433332e706e67"><img src="https://camo.githubusercontent.com/74c0180eec6d7396d787acd1f237765f7852397896c4c431babafe21d655f376/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303232303932353130333433332e706e67" alt="img"></a></p><p>x &#x3D; z, <strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p><p>Coding:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="comment">// here need to check if fast and fast.next is null, can&#x27;t check if fast == slow directly cause there are cases without loops so fast can never equal to slow</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;  <span class="comment">// find where fast and slow meet</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123; <span class="comment">// there&#x27;s a cycle </span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> head; </span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="keyword">while</span>(node1 != node2 )&#123; <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口(x = z)</span></span><br><span class="line">                    node1 = node1.next;</span><br><span class="line">                    node2 = node2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> node1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/03/06/SoftwareDevelopment/SpringBoot/"/>
      <url>/2023/03/06/SoftwareDevelopment/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h3 id="Intellij-IDEA-is-not-recognizing-java-files-as-runnable"><a href="#Intellij-IDEA-is-not-recognizing-java-files-as-runnable" class="headerlink" title="Intellij IDEA is not recognizing  java files as runnable"></a>Intellij IDEA is not recognizing  java files as runnable</h3><ul><li>right-mouse click on your src</li><li>navigate to “Mark Directory As”</li><li>choose “Sources Root” It will now recognize your files correctly and your main classes will be able to run again</li></ul><h3 id="Web-server-failed-to-start-Port-8080-was-already-in-use"><a href="#Web-server-failed-to-start-Port-8080-was-already-in-use" class="headerlink" title="Web server failed to start. Port 8080 was already in use."></a>Web server failed to start. Port 8080 was already in use.</h3><ul><li>First check what processes are using that specific port, then killing it using its process ID:</li></ul><ol><li>Run <code>netstat -ano | findstr &lt; Port Number &gt;</code> This will identify which process is listening on port 8080.</li><li>Take note of the process ID (PID) e.g. 63262</li><li>Run <code>taskkill /F /PID &lt; Process Id &gt;</code>  replace &lt; Process Id &gt; with PID</li></ol><h3 id="Set-the-JDK-for-your-project-and-x2F-or-modules"><a href="#Set-the-JDK-for-your-project-and-x2F-or-modules" class="headerlink" title="Set the JDK for your project and&#x2F;or modules."></a>Set the JDK for your project and&#x2F;or modules.</h3><p>Open the project settings (File-&gt;Project settings…).</p><p>Most of the time you just need to set the project sdk (to your java sdk) and configure the modules to use the project sdk.<br>Probably one of those settings is missing.</p><h3 id="delete-the-push-record-in-git"><a href="#delete-the-push-record-in-git" class="headerlink" title="delete the push record in git"></a>delete the push record in git</h3><p><a href="https://zhuanlan.zhihu.com/p/35078876">https://zhuanlan.zhihu.com/p/35078876</a></p><h3 id="Dependency"><a href="#Dependency" class="headerlink" title="Dependency"></a>Dependency</h3><p>In a Maven-based Java project, a POM (Project Object Model) file is an XML file that contains information about the project and its dependencies. The dependencies section of a POM file lists the external libraries (or other modules within the project) that the project needs in order to compile and run successfully.</p><p>Each dependency in the POM file typically includes the following information:</p><ul><li>Group Id: A unique identifier for the group or organization that created the dependency.</li><li>Artifact Id: The name of the dependency.</li><li>Version: The version of the dependency that the project requires.</li><li>Scope: Indicates the scope of the dependency, such as compile, test, runtime, or provided.</li></ul><p>When Maven builds a project, it reads the POM file and downloads all the necessary dependencies from the Maven Central Repository (or other configured repositories), which it uses to compile and run the project. The POM file therefore plays a crucial role in managing the project’s dependencies and ensuring that the correct versions of libraries are used consistently across the project.</p><p>each dependency listed in the dependencies section of a Maven POM file represents an <strong>external library</strong> or module that the project needs in order to compile and run successfully.</p><p>When a Maven project is built, the dependencies are <strong>downloaded from remote repositories</strong> (such as the Maven Central Repository) and stored locally on the developer’s machine, in a directory called the local repository. These dependencies are typically jar files (Java Archive files) that contain compiled Java code and any required resources, such as configuration files or documentation.</p><p>By including dependencies in the POM file, Maven can automatically download and manage the required libraries for the project, making it easier to build and distribute the project to other developers. This also helps ensure that all developers are using the same versions of the dependencies, which can help prevent compatibility issues and simplify debugging.</p><h3 id="Curl-Command"><a href="#Curl-Command" class="headerlink" title="Curl Command"></a>Curl Command</h3><p><a href="https://www.geeksforgeeks.org/curl-command-in-linux-with-examples/">https://www.geeksforgeeks.org/curl-command-in-linux-with-examples/</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Heap 🌺</title>
      <link href="/2023/03/01/algorithm/Heap/"/>
      <url>/2023/03/01/algorithm/Heap/</url>
      
        <content type="html"><![CDATA[<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><h1 id="Types-of-binary-tree"><a href="#Types-of-binary-tree" class="headerlink" title="Types of binary tree"></a>Types of binary tree</h1><h3 id="1-Full-Binary-Tree"><a href="#1-Full-Binary-Tree" class="headerlink" title="1. Full Binary Tree"></a>1. Full Binary Tree</h3><p>A full Binary tree is a special type of binary tree in which <strong>every parent node&#x2F;internal node has either two or no children</strong>.</p><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/full-binary-tree_0.png" alt="Full binary tree"></p><p>To learn more, please visit <a href="https://www.programiz.com/dsa/full-binary-tree">full binary tree</a>.</p><h3 id="2-Perfect-Binary-Tree"><a href="#2-Perfect-Binary-Tree" class="headerlink" title="2. Perfect Binary Tree"></a>2. Perfect Binary Tree</h3><p>A perfect binary tree is a type of binary tree in which** every internal node has exactly two child nodes and all the leaf nodes are at the same level.**</p><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/perfect-binary-tree_0.png" alt="Perfect binary tree">Perfect Binary Tree</p><p>To learn more, please visit <a href="https://www.programiz.com/dsa/perfect-binary-tree">perfect binary tree</a>.</p><h3 id="3-Complete-Binary-Tree"><a href="#3-Complete-Binary-Tree" class="headerlink" title="3. Complete Binary Tree"></a>3. Complete Binary Tree</h3><p>A complete binary tree is just like a full binary tree, but with two major differences</p><ol><li><strong>Every</strong> level must be completely filled</li><li>All the leaf elements must lean towards the <strong>left</strong>.</li><li>The last leaf element might not have a right sibling i.e. <strong>a complete binary tree doesn’t have to be a full binary tree.</strong></li></ol><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/complete-binary-tree_0.png" alt="Complete Binary Tree">Complete Binary Tree</p><p>To learn more, please visit <a href="https://www.programiz.com/dsa/complete-binary-tree">complete binary tree</a>.</p><h3 id="4-Degenerate-or-Pathological-Tree"><a href="#4-Degenerate-or-Pathological-Tree" class="headerlink" title="4. Degenerate or Pathological Tree"></a>4. Degenerate or Pathological Tree</h3><p>A degenerate or pathological tree is the tree having  <strong>a single child either left or right  .</strong></p><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/degenerate-binary-tree_0.png" alt="Degenerate Binary Tree"></p><h3 id="5-Skewed-Binary-Tree"><a href="#5-Skewed-Binary-Tree" class="headerlink" title="5. Skewed Binary Tree"></a>5. Skewed Binary Tree</h3><p>A skewed binary tree is a pathological&#x2F;degenerate tree in which the tree is either dominated by the left nodes or the right nodes. Thus, there are two types of skewed binary tree: <strong>left-skewed binary tree</strong> and <strong>right-skewed binary tree</strong>.</p><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/skewed-binary-tree_0.png" alt="Skewed Binary Tree">Skewed Binary Tree</p><h3 id="6-Balanced-Binary-Tree"><a href="#6-Balanced-Binary-Tree" class="headerlink" title="6. Balanced Binary Tree"></a>6. Balanced Binary Tree</h3><p>It is a type of binary tree in which the difference between the height of the left and the right subtree for each node is either 0 or 1.</p><p><img src="https://cdn.programiz.com/sites/tutorial2program/files/height-balanced_1.png" alt="Balanced Binary Tree">Balanced Binary Tree</p><p>To learn more, please visit <a href="https://www.programiz.com/dsa/balanced-binary-tree">balanced binary tree</a>.</p><h1 id="Complete-binary-tree"><a href="#Complete-binary-tree" class="headerlink" title="Complete binary tree"></a>Complete binary tree</h1><h2 id="Max-heap-x2F-Min-heap"><a href="#Max-heap-x2F-Min-heap" class="headerlink" title="Max heap &#x2F; Min heap"></a>Max heap &#x2F; Min heap</h2><p>Heap data structure is <a href="https://www.programiz.com/dsa/complete-binary-tree">a complete binary tree</a> that satisfies <strong>the heap property</strong>, where any given node is</p><ul><li>always greater than its child node&#x2F;s and the key of the root node is the largest among all other nodes. This property is also called <strong>max heap property</strong>.</li><li>always smaller than the child node&#x2F;s and the key of the root node is the smallest among all other nodes. This property is also called <strong>min heap property</strong>.</li></ul><p><img src="https://www.programiz.com/sites/tutorial2program/files/maxheap_1.png" alt="Max-heap">Max-heap↓</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/minheap_0.png" alt="Min-heap">Min-heap↓</p><p>This type of data structure is also called a <strong>binary heap</strong>.</p><h2 id="Heap-operation"><a href="#Heap-operation" class="headerlink" title="Heap operation"></a>Heap operation</h2><h3 id="Heapify"><a href="#Heapify" class="headerlink" title="Heapify"></a>Heapify</h3><p>Heapify is the process of creating a heap data structure from a binary tree. It is used to create a Min-Heap or a Max-Heap.</p><ol><li><p>Let the input array be</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/array_1.png" alt="heap initial array"></p></li><li><p>Create a complete binary tree from the array</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/completebt-1_0.png" alt="Complete binary tree"></p></li><li><p>Start from the first index of non-leaf node whose index is given by n&#x2F;2 - 1.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/start_1.png" alt="heapify"> leaf node</p></li><li><p>Set current element <code>i</code> as <code>largest</code>.</p></li><li><p>The index of left child is given by <code>2i + 1</code> and the right child is given by <code>2i + 2</code>.<br>If <code>leftChild</code> is greater than <code>currentElement</code> (i.e. element at <code>ith</code> index), set <code>leftChildIndex</code> as largest.<br>If <code>rightChild</code> is greater than element in <code>largest</code>, set <code>rightChildIndex</code> as <code>largest</code>.</p></li><li><p>Swap largest with currentElement</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/swap_1.png" alt="heapify"></p></li><li><p>Repeat steps 3-7 until the subtrees are also heapified.</p></li></ol><p><strong>Algorithm</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Heapify(array, size, i)</span><br><span class="line">  set i as largest</span><br><span class="line">  leftChild = 2i + 1</span><br><span class="line">  rightChild = 2i + 2</span><br><span class="line">  </span><br><span class="line">  if leftChild &gt; array[largest]</span><br><span class="line">    set leftChildIndex as largest</span><br><span class="line">  if rightChild &gt; array[largest]</span><br><span class="line">    set rightChildIndex as largest</span><br><span class="line"></span><br><span class="line">  swap array[i] and array[largest]</span><br></pre></td></tr></table></figure><p>To create a Max-Heap:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap(array, size)</span><br><span class="line">  loop from the first index of non-leaf node down to zero</span><br><span class="line">    call heapify</span><br></pre></td></tr></table></figure><p>For Min-Heap, both <code>leftChild</code> and <code>rightChild</code> must be larger than the parent for all nodes.</p><h2 id="Insert-Element-into-Heap"><a href="#Insert-Element-into-Heap" class="headerlink" title="Insert Element into Heap"></a>Insert Element into Heap</h2><p>Algorithm for insertion in Max Heap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If there is no node, </span><br><span class="line">  create a newNode.</span><br><span class="line">else (a node is already present)</span><br><span class="line">  insert the newNode at the end (last node from left to right.)</span><br><span class="line">  </span><br><span class="line">heapify the array</span><br></pre></td></tr></table></figure><ol><li><p>Insert the new element at the end of the tree.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/insert-heap-1.png" alt="insertion in heap"></p></li><li><p>Heapify the tree.</p></li></ol><p><img src="https://www.programiz.com/sites/tutorial2program/files/insert-heap-2.png" alt="insertion in heap"></p><p>For Min Heap, the above algorithm is modified so that <code>parentNode</code> is always smaller than <code>newNode</code>.</p><hr><h3 id="Delete-Element-from-Heap"><a href="#Delete-Element-from-Heap" class="headerlink" title="Delete Element from Heap"></a>Delete Element from Heap</h3><p>Algorithm for deletion in Max Heap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If nodeToBeDeleted is the leafNode</span><br><span class="line">  remove the node</span><br><span class="line">Else swap nodeToBeDeleted with the lastLeafNode</span><br><span class="line">  remove noteToBeDeleted</span><br><span class="line">   </span><br><span class="line">heapify the array</span><br></pre></td></tr></table></figure><ol><li><p>Select the element to be deleted.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/delete-1_1.png" alt="deletion in heap"></p></li><li><p>Swap it with the last element.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/delete-2_1.png" alt="deletion in heap"></p></li><li><p>Remove the last element.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/delete-3_0.png" alt="deletion in heap"></p></li><li><p>Heapify the tree.</p></li></ol><p><img src="https://www.programiz.com/sites/tutorial2program/files/delete-4_0.png" alt="deletion in heap"></p><p>For Min Heap, above algorithm is modified so that both <code>childNodes</code> are greater smaller than <code>currentNode</code>.</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">// Max-Heap data structure in Java</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Heap &#123;</span><br><span class="line">  void heapify(ArrayList&lt;Integer&gt; hT, int i) &#123;</span><br><span class="line">    int size = hT.size();</span><br><span class="line">    int largest = i;</span><br><span class="line">    int l = 2 * i + 1;</span><br><span class="line">    int r = 2 * i + 2;</span><br><span class="line">    if (l &lt; size &amp;&amp; hT.get(l) &gt; hT.get(largest))</span><br><span class="line">      largest = l;</span><br><span class="line">    if (r &lt; size &amp;&amp; hT.get(r) &gt; hT.get(largest))</span><br><span class="line">      largest = r;</span><br><span class="line"></span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">      int temp = hT.get(largest);</span><br><span class="line">      hT.set(largest, hT.get(i));</span><br><span class="line">      hT.set(i, temp);</span><br><span class="line"></span><br><span class="line">      heapify(hT, largest);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void insert(ArrayList&lt;Integer&gt; hT, int newNum) &#123;</span><br><span class="line">    int size = hT.size();</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">      hT.add(newNum);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      hT.add(newNum);</span><br><span class="line">      for (int i = size / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(hT, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void deleteNode(ArrayList&lt;Integer&gt; hT, int num)</span><br><span class="line">  &#123;</span><br><span class="line">    int size = hT.size();</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      if (num == hT.get(i))</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int temp = hT.get(i);</span><br><span class="line">    hT.set(i, hT.get(size-1));</span><br><span class="line">    hT.set(size-1, temp);</span><br><span class="line"></span><br><span class="line">    hT.remove(size-1);</span><br><span class="line">    for (int j = size / 2 - 1; j &gt;= 0; j--)</span><br><span class="line">    &#123;</span><br><span class="line">      heapify(hT, j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void printArray(ArrayList&lt;Integer&gt; array, int size) &#123;</span><br><span class="line">    for (Integer i : array) &#123;</span><br><span class="line">      System.out.print(i + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    int size = array.size();</span><br><span class="line"></span><br><span class="line">    Heap h = new Heap();</span><br><span class="line">    h.insert(array, 3);</span><br><span class="line">    h.insert(array, 4);</span><br><span class="line">    h.insert(array, 9);</span><br><span class="line">    h.insert(array, 5);</span><br><span class="line">    h.insert(array, 2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Max-Heap array: &quot;);</span><br><span class="line">    h.printArray(array, size);</span><br><span class="line"></span><br><span class="line">    h.deleteNode(array, 4);</span><br><span class="line">    System.out.println(&quot;After deleting an element: &quot;);</span><br><span class="line">    h.printArray(array, size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MaxHeapify-VS-BuildMaxHeap"><a href="#MaxHeapify-VS-BuildMaxHeap" class="headerlink" title="MaxHeapify VS. BuildMaxHeap"></a>MaxHeapify VS. BuildMaxHeap</h2><p>Basically, <code>heapify</code> is an algorithm used to re-arrange the heap if the root node violates the heap property (<em>child subtrees must be heaps!</em>). It’s a vital part of building a heap, inserting or deleting a top node from the heap.</p><blockquote><p>Heapify is:</p><ul><li>after we popped the top node of the heap and we moved the last node to the top then we rearrange the tree from top-to-bottom so it is a heap again (we heapify)</li><li>heapify time complexity O(log n)</li></ul></blockquote><p>Heapify is not:</p><p>creating a heap from an array which is a bottom-up operation with a time complexity of O(n)</p><p>even though <code>heapify</code> is actively used for building a heap, we cannot say that building a heap is <code>heapify</code>. It’s just an essential part of the process.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gradient descent &amp; gradient ascent</title>
      <link href="/2023/02/21/gradient-descent-&amp;-gradient-ascent/"/>
      <url>/2023/02/21/gradient-descent-&amp;-gradient-ascent/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_39631030/article/details/81260960?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81260960-blog-121268161.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-81260960-blog-121268161.pc_relevant_default&utm_relevant_index=8">https://blog.csdn.net/weixin_39631030/article/details/81260960?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-81260960-blog-121268161.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-81260960-blog-121268161.pc_relevant_default&amp;utm_relevant_index=8</a></p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB🥭</title>
      <link href="/2023/02/21/SoftwareDevelopment/MongoDB/"/>
      <url>/2023/02/21/SoftwareDevelopment/MongoDB/</url>
      
        <content type="html"><![CDATA[<h3 id="What-is-CRUD"><a href="#What-is-CRUD" class="headerlink" title="What is CRUD?"></a>What is CRUD?</h3><p>Create, Read, Update, and Delete (CRUD) are the four basic functions that models should be able to do, at most.</p><h3 id="Error-message-Process-finished-with-exit-code-1073741819-0xC0000005"><a href="#Error-message-Process-finished-with-exit-code-1073741819-0xC0000005" class="headerlink" title="Error message: Process finished with exit code -1073741819 (0xC0000005)"></a>Error message: Process finished with exit code -1073741819 (0xC0000005)</h3><p>问题描述：<br>    idea中启动项目报  Process finished with exit code -1073741819 (0xC0000005) ，如图所示：</p><p>问题解决：<br>   原因：经过多方查证，问题最终定位在金山词霸2016上，如果开启了金山词霸的划译功能，就会出现此错误，具体原理有待研究。在关闭金山词霸时，有时idea也会自动关闭。</p><p>​    解决：关掉金山词霸，或者把金山词霸的划译功能关掉，然后重启idea，再运行项目就没问题了。经过尝试，发现只要在IDEA第一次打开并运行的时候，没有开启金山词霸的划译功能，那么之后就算开启也不会有问题。所以如果一定需要用金山，就先打开idea运行项目，在打开金山，或者直接把金山的划译功能关掉就可以了。</p><p>   ！！！注意：金山词霸划译与idea2018.3+版本不兼容</p><h1 id="MONGODB"><a href="#MONGODB" class="headerlink" title="MONGODB"></a>MONGODB</h1><h3 id="structure"><a href="#structure" class="headerlink" title="structure"></a>structure</h3><p>Data in MongoDB is made up of three types of components: <strong>databases</strong>, <strong>collections</strong>, and <strong>documents</strong>. The database sits at the top of the hierarchy, collections at the next level, and documents at the bottom.</p><p><img src="https://studio3t.com/wp-content/uploads/2022/04/hierachy.png" alt="img"></p><h3 id="operation"><a href="#operation" class="headerlink" title="operation:"></a>operation:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">const &#123; stringify &#125; = require(&quot;querystring&quot;);</span><br><span class="line"></span><br><span class="line">//open the connection</span><br><span class="line">mongoose.connect(&quot;mongodb+srv://dxexperiments-user:DrEuMg7KfFImh774@dxvignettes.vtnenqy.mongodb.net/&quot;);</span><br><span class="line"></span><br><span class="line">// this lays out the foundation for every new fruit document that will be added to the database</span><br><span class="line">const fruitSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    rating:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        min: 1,</span><br><span class="line">        max: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    review: String</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// first parameter, name of the collection(mongodb will convert this string into a pluralize form to create your collection); so we created a new collection called Fruits</span><br><span class="line">// second parameter: It is the schema of the collection.</span><br><span class="line">const Fruit = mongoose.model(&quot;Fruit&quot;, fruitSchema);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// creating fruit document from Fruit model, means the document need to stick to this schema</span><br><span class="line">const fruit = new Fruit(&#123;</span><br><span class="line">    name:&quot;apple&quot;,</span><br><span class="line">    rating: 6,</span><br><span class="line">    review:&quot;well, average.&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//save fruit document into the Fruist collection inside of the DATABASE</span><br><span class="line">// fruit.save();</span><br><span class="line"></span><br><span class="line">const personSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age:Number</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const grape = new Fruit(&#123;</span><br><span class="line">    name: &quot;grape&quot;,</span><br><span class="line">    rating: 7,</span><br><span class="line">    review: &quot; I really like it&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const kiwi = new Fruit(&#123;</span><br><span class="line">    name: &quot;kiwi&quot;,</span><br><span class="line">    rating: 6,</span><br><span class="line">    review: &quot; I really like it&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const pineapple = new Fruit(&#123;</span><br><span class="line">    name: &quot;pineapple&quot;,</span><br><span class="line">    rating: 9,</span><br><span class="line">    review: &quot; I really like it&quot;</span><br><span class="line">&#125;);</span><br><span class="line">// Fruit.insertMany([kiwi,grape,pineapple]);</span><br><span class="line"></span><br><span class="line">Fruit.find().exec()</span><br><span class="line">  .then((fruits) =&gt; &#123;</span><br><span class="line">      //close the connection</span><br><span class="line">    mongoose.connection.close();</span><br><span class="line">    fruits.forEach((fruit) =&gt; &#123;</span><br><span class="line">      console.log(fruit.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Error retrieving fruits:&#x27;, error);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="data-validation-with-mongoose"><a href="#data-validation-with-mongoose" class="headerlink" title="data validation with mongoose:"></a>data validation with mongoose:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const fruitSchema = new mongoose.Schema(&#123;</span><br><span class="line">    name: </span><br><span class="line">    &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        required: [true, &#x27;Why no name?&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    rating:</span><br><span class="line">    &#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        min: 1,</span><br><span class="line">        max: 10</span><br><span class="line">    &#125;,</span><br><span class="line">    review: String</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="delete-and-update"><a href="#delete-and-update" class="headerlink" title="delete and update"></a>delete and update</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Fruit.updateOne(&#123;_id:&quot;648dc4fdd4b6dda3193f73b3&quot;&#125;, &#123;name: &quot;change&quot;&#125;);</span><br><span class="line">Fruit.deleteOne(&#123;name: &quot;kiwi&quot;&#125;)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;Kiwi deleted successfully&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(&quot;Error deleting kiwi:&quot;, error);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  Person.deleteMany(&#123;name: &quot;Dan&quot;&#125;)  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;Dan deleted successfully&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(&quot;Error deleting kiwi:&quot;, error);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>🌸Basic Math</title>
      <link href="/2023/02/17/BasicMath/"/>
      <url>/2023/02/17/BasicMath/</url>
      
        <content type="html"><![CDATA[<h2 id="Math-terminology"><a href="#Math-terminology" class="headerlink" title="Math terminology"></a>Math terminology</h2><ul><li><p>numerator<em>n.</em>&#x2F;ˈnjuːməreɪtə(r)&#x2F; </p><p>( <em>mathematics 数</em>) the number above the line in a <strong>fraction</strong> , for example 3 in the <strong>fraction</strong> 3⁄4 （分数中的）分子 </p></li><li><p>de·nom·in·ator <em>n.</em> &#x2F;dɪˈnɒmɪneɪtə(r)&#x2F; </p><p>( <em>mathematics 数</em>) the number below the line in a <strong>fraction</strong> showing how many parts the whole is divided into, for example 4 in 3⁄4 分母</p></li><li><p>ex·po·nen·tial    <em>adj.</em>   &#x2F;ˌekspəˈnenʃl&#x2F; </p><p>( <em>mathematics 数</em>) of or shown by an <em><strong>exponent</strong></em> 指数的；幂的；由指数表示的</p><p>2 4 is an exponential expression. 24是个指数式。</p><p>an <strong>exponential curve&#x2F;function</strong> 指数曲线╱函数</p></li><li><p>geo·met·ric    <em>adj.</em>   &#x2F;ˌdʒiːəˈmetrɪk&#x2F; </p><p>( also <em>less frequent</em> <strong>geo·met·ric·al</strong>  &#x2F;‑ɪkl&#x2F;  ) of <strong>geometry</strong> ; of or like the lines, shapes, etc. used in <strong>geometry</strong> , especially because of having regular shapes or lines 几何（学）的；（似）几何图形的</p></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><h2 id="Greek-Letters"><a href="#Greek-Letters" class="headerlink" title="Greek Letters"></a>Greek Letters</h2><table><thead><tr><th align="left">Symbol Name</th><th align="left">Capital Letter</th><th align="left">Small Letter</th></tr></thead><tbody><tr><td align="left"><a href="https://www.greeksymbols.net/alpha-symbol">Alpha</a></td><td align="left">Α</td><td align="left">α</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/beta-symbol">Beta</a></td><td align="left">Β</td><td align="left">β</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/gamma-symbol">Gamma</a></td><td align="left">Γ</td><td align="left">γ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/delta-symbol">Delta</a></td><td align="left">Δ</td><td align="left">δ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/epsilon-symbol">Epsilon</a></td><td align="left">Ε</td><td align="left">ε</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/zeta-symbol">Zeta</a></td><td align="left">Ζ</td><td align="left">ζ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/eta-symbol">Eta</a></td><td align="left">Η</td><td align="left">η</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/theta-symbol">Theta</a></td><td align="left">Θ</td><td align="left">θ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/iota-symbol">Iota</a></td><td align="left">Ι</td><td align="left">ι</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/kappa-symbol">Kappa</a></td><td align="left">Κ</td><td align="left">κ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/lambda-symbol">Lambda</a></td><td align="left">Λ</td><td align="left">λ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/mu-symbol">Mu</a></td><td align="left">Μ</td><td align="left">μ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/nu-symbol">Nu</a></td><td align="left">Ν</td><td align="left">ν</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/xi-symbol">Xi</a></td><td align="left">Ξ</td><td align="left">ξ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/omicron-symbol">Omicron</a></td><td align="left">Ο</td><td align="left">ο</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/pi-symbol">Pi</a></td><td align="left">Π</td><td align="left">π</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/rho-symbol">Rho</a></td><td align="left">Ρ</td><td align="left">ρ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/sigma-symbol">Sigma</a></td><td align="left">Σ</td><td align="left">σ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/tau-symbol">Tau</a></td><td align="left">Τ</td><td align="left">τ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/upsilon-symbol">Upsilon</a></td><td align="left">Υ</td><td align="left">υ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/phi-symbol">Phi</a></td><td align="left">Φ</td><td align="left">φ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/chi-symbol">Chi</a></td><td align="left">Χ</td><td align="left">χ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/psi-symbol">Psi</a></td><td align="left">Ψ</td><td align="left">ψ</td></tr><tr><td align="left"><a href="https://www.greeksymbols.net/omega-symbol">Omega</a></td><td align="left">Ω</td><td align="left">ω</td></tr></tbody></table><h2 id="Residules"><a href="#Residules" class="headerlink" title="Residules"></a>Residules</h2><p>A residual is a measure of how well a line fits an individual data point.</p><p><img src="https://mathbitsnotebook.com/Algebra1/StatisticsReg/residualgraph1aa.jpg" alt="residualgraph1aa"></p><h2 id="Likelihood"><a href="#Likelihood" class="headerlink" title="Likelihood"></a>Likelihood</h2><p>the likelihood is often written as <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e1f2f25132324db55a6a4e363d60e7859f407cef" alt="{\displaystyle {\mathcal {L}}(\theta \mid X)}"> instead of <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e83871172abd723dfbef5cf05077150aadff9f28" alt="{\displaystyle P(X\mid \theta )}"> to emphasize that it is to be understood as a function of the parameters θ instead of the random variable X.</p><h2 id="Log-Likelihood-Function"><a href="#Log-Likelihood-Function" class="headerlink" title="Log-Likelihood Function"></a>Log-Likelihood Function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">likelihood</span>(<span class="params">theta,xs</span>):</span><br><span class="line">    p = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xs:</span><br><span class="line">        p = p*theta**x * (<span class="number">1</span>-theta)**(<span class="number">1</span>-x)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">xs = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">theta1 = <span class="number">0.99</span></span><br><span class="line">theta2 = <span class="number">0.25</span></span><br><span class="line">loglik1 = numpy.log(likelihood(theta1,xs))</span><br><span class="line">loglik2 = numpy.log(likelihood(theta2,xs))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Log-Likelihood(&quot;</span>,theta1,<span class="string">&quot;|&quot;</span>,xs, <span class="string">&quot;)=&quot;</span>,loglik1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Log-Likelihood(&quot;</span>,theta2,<span class="string">&quot;|&quot;</span>,xs, <span class="string">&quot;)=&quot;</span>,loglik2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="comment">#Log-Likelihood( 0.99 | [0, 0, 0, 1] )= -13.8255608938</span></span><br><span class="line"><span class="comment">#Log-Likelihood( 0.25 | [0, 0, 0, 1] )= -2.24934057848</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bernoulli-model"><a href="#Bernoulli-model" class="headerlink" title="Bernoulli model"></a>Bernoulli model</h2><p> 对随机试验中某事件是否发生，实验的可能结果只有两个。又名<strong>两点分布</strong>或者<strong>0-1分布</strong>，是一个离散型概率分布。</p><h2 id="Gaussian-Distribution"><a href="#Gaussian-Distribution" class="headerlink" title="Gaussian Distribution"></a>Gaussian Distribution</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Standard_deviation_diagram.svg/2880px-Standard_deviation_diagram.svg.png" alt="img"></p><p><em>“Bell curve” redirects here.</em> </p><p>若<a href="http://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E8%AE%8A%E9%87%8F">随机变量</a><em>X</em>服从一个<a href="http://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B">数学期望</a>为μ、<a href="http://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%96%B9%E5%B7%AE">标准方差</a>为σ2的高斯分布，记为：</p><p>X∼N(μ, σ^2),</p><p>The general form of its probability density function is</p><p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/00cb9b2c9b866378626bcfa45c86a6de2f2b2e40" alt="{\displaystyle f(x)={\frac {1}{\sigma {\sqrt {2\pi }}}}e^{-{\frac {1}{2}}\left({\frac {x-\mu }{\sigma }}\right)^{2}}}"></p><p>The parameter μ is the <a href="https://en.wikipedia.org/wiki/Mean">mean</a> or <a href="https://en.wikipedia.org/wiki/Expected_value">expectation</a> of the distribution (and also its <a href="https://en.wikipedia.org/wiki/Median">median</a> and <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode</a>), while the parameter σ is its <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>. The <a href="https://en.wikipedia.org/wiki/Variance">variance</a> of the distribution is σ^2. A random variable with a Gaussian distribution is said to be <strong>normally distributed</strong>, and is called a <strong>normal deviate</strong>. 正态分布</p><h2 id="Maximum-Likelihood-Estimate-MLE"><a href="#Maximum-Likelihood-Estimate-MLE" class="headerlink" title="Maximum Likelihood Estimate (MLE)"></a>Maximum Likelihood Estimate (MLE)</h2><p>Maximum likelihood estimation is a method that determines values for the parameters of a model. The parameter values are found such that they maximize the likelihood that the process described by the model produced the data that were actually observed. <font color = "red">which can be interepreted as the parameter for which the data is most probable under the model.</font></p><h3 id="Finding-MLE-for-a-Bernoulli-Model"><a href="#Finding-MLE-for-a-Bernoulli-Model" class="headerlink" title="Finding MLE for a Bernoulli Model"></a>Finding MLE for a Bernoulli Model</h3><p><img src="https://www.linkpicture.com/q/b44baa669e565485220f2c57203e6f4.png" alt="image"></p><h3 id="Finding-𝜇𝑀𝐿𝐸-of-Gaussian-distribution"><a href="#Finding-𝜇𝑀𝐿𝐸-of-Gaussian-distribution" class="headerlink" title="Finding 𝜇𝑀𝐿𝐸 of Gaussian distribution"></a>Finding 𝜇𝑀𝐿𝐸 of Gaussian distribution</h3><p><img src="https://miro.medium.com/max/1400/1*akEbjkBGope8zRKvY00Gcg.png" alt="img"></p><p>🍄 What can we do with maximum likelihood estimates? We can predict outcome of the next experiment:</p><p><img src="https://www.linkpicture.com/q/%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%811%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230217174659.png" alt="img"></p><p>[TOC]</p>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Algorithm 🌺</title>
      <link href="/2023/02/15/algorithm/SortingAlgorithm/"/>
      <url>/2023/02/15/algorithm/SortingAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Merge-Sort"><a href="#1-Merge-Sort" class="headerlink" title="1. Merge Sort"></a><font color = "pink">1. Merge Sort</font></h1><p><img src="https://www.programiz.com/sites/tutorial2program/files/merge-sort-example_0.png" alt="merge sort example"></p><p>The MergeSort function repeatedly divides the array into two halves until we reach a stage where we try to perform MergeSort on a subarray of size 1 i.e. p &#x3D;&#x3D; r.</p><p>After that, the merge function comes into play and combines the sorted arrays into larger arrays until the whole array is merged.</p><h2 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode:"></a>Pseudocode:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MergeSort(A, p, r):</span><br><span class="line">    if p &gt; r </span><br><span class="line">        return</span><br><span class="line">    q = (p+r)/2</span><br><span class="line">    mergeSort(A, p, q)</span><br><span class="line">    mergeSort(A, q+1, r)</span><br><span class="line">    merge(A, p, q, r)</span><br></pre></td></tr></table></figure><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA:"></a>JAVA:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Merge two subarrays L and M into arr</span><br><span class="line">void merge(int arr[], int p, int q, int r) &#123; // r is the size of the array</span><br><span class="line"></span><br><span class="line">    // Create L ← A[p..q] and M ← A[q+1..r]</span><br><span class="line">    int n1 = q - p + 1;</span><br><span class="line">    int n2 = r - q;</span><br><span class="line"></span><br><span class="line">    int L[n1], M[n2];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[p + i];</span><br><span class="line">    for (int j = 0; j &lt; n2; j++)</span><br><span class="line">        M[j] = arr[q + 1 + j];</span><br><span class="line"></span><br><span class="line">    // Maintain current index of sub-arrays and main array</span><br><span class="line">    int i, j, k;</span><br><span class="line">    i = 0;</span><br><span class="line">    j = 0;</span><br><span class="line">    k = p;</span><br><span class="line"></span><br><span class="line">    // Until we reach either end of either L or M, pick larger among</span><br><span class="line">    // elements L and M and place them in the correct position at A[p..r]</span><br><span class="line">    while (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        if (L[i] &lt;= M[j]) &#123;</span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            arr[k] = M[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // When we run out of elements in either L or M,</span><br><span class="line">    // pick up the remaining elements and put in A[p..r]</span><br><span class="line">    while (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = M[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Merge( ) Function Explained Step-By-Step</strong></p><p>Merging two consecutive subarrays of array</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/merge-sort-demo-step-1.png" alt="Merging two consecutive subarrays of array"></p><p>The array A[0..5] contains <strong>two sorted</strong> subarrays A[0..3] and A[4..5]. Let us see how the merge function will merge the two arrays.</p><p><strong>Step 2:</strong> Maintain current index of sub-arrays and main array</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i, j, k;</span><br><span class="line">i = 0; </span><br><span class="line">j = 0; </span><br><span class="line">k = p; </span><br></pre></td></tr></table></figure><p><img src="https://www.programiz.com/sites/tutorial2program/files/merge-sort-demo-step-3.png" alt="Maintain indices of copies of sub array and main array">Maintain indices of copies of sub array and main array</p><p><strong>Step 3:</strong> Until we reach the end of either L or M, pick larger among elements L and M and place them in the correct position at A[p..r]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (i &lt; n1 &amp;&amp; j &lt; n2) &#123; </span><br><span class="line">    if (L[i] &lt;= M[j]) &#123; </span><br><span class="line">        arr[k] = L[i]; i++; </span><br><span class="line">    &#125; </span><br><span class="line">    else &#123; </span><br><span class="line">        arr[k] = M[j]; </span><br><span class="line">        j++; </span><br><span class="line">    &#125; </span><br><span class="line">    k++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.programiz.com/sites/tutorial2program/files/merge-sort-demo-step-4.png" alt="Comparing individual elements of sorted subarrays until we reach end of one">Comparing individual elements of sorted subarrays until we reach end of one</p><p><strong>Step 4:</strong> When we run out of elements in either L or M, pick up the remaining elements and put in A[p..r]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// We exited the earlier loop because j &lt; n2 doesn&#x27;t hold</span><br><span class="line">while (i &lt; n1)</span><br><span class="line">&#123;</span><br><span class="line">    arr[k] = L[i];</span><br><span class="line">    i++;</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.programiz.com/sites/tutorial2program/files/merge-sort-demo-step-5.png" alt="Copy the remaining elements from the first array to main subarray">Copy the remaining elements from the first array to main subarray</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // We exited the earlier loop because i &lt; n1 doesn&#x27;t hold  </span><br><span class="line">    while (j &lt; n2)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[k] = M[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-Quick-Sort"><a href="#2-Quick-Sort" class="headerlink" title="2. Quick Sort"></a><font color = "pink">2. Quick Sort</font></h1><p><strong>1. Select the Pivot Element</strong></p><p>There are different variations of quicksort where the pivot element is selected from different positions. Here, we will be selecting the <u>rightmost</u> element of the array as the pivot element.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-0.1_0.png" alt="Quick Sort Steps">Select a pivot element</p><p><strong>2. Rearrange the Array</strong></p><p>Now the elements of the array are rearranged so that elements that are smaller than the pivot are put on the left and the elements greater than the pivot are put on the right.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-0.2_0.png" alt="Quick Sort Steps"></p><p>Here’s how we rearrange the array:</p><ol><li><p>A pointer is fixed at the pivot element. The pivot element is compared with the elements beginning from the first index.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-first-step.png" alt="Quick Sort Steps"></p></li><li><p>If the element is greater than the pivot element, a second pointer is set for that element.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-second-step.png" alt="Quick Sort Steps"></p></li><li><p>Now, pivot is compared with other elements. If an element smaller than the pivot element is reached, <u>the smaller element is swapped with the greater element found earlier</u>.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-third-step.png" alt="Quick Sort Steps"></p></li><li><p>Again, the process is repeated to set the next greater element as the second pointer. And, swap it with another smaller element.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-fourth-step.png" alt="Quick Sort Steps"></p></li><li><p>The process goes on until the second last element is reached.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-fifth-step.png" alt="Quick Sort Steps">The process goes on until the second last element is reached.</p></li><li><p>Finally, the pivot element is swapped with the second pointer.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort-partition-sixth-step.png" alt="Quick Sort Steps">Finally, the pivot element is swapped with the second pointer.</p></li></ol><p><strong>3. Divide Subarrays</strong></p><p>Pivot elements are again chosen for the left and the right sub-parts separately. And, <strong>step 2</strong> is repeated.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/quick-sort_1.png" alt="Quick Sort Steps"></p><h2 id="pseudocode"><a href="#pseudocode" class="headerlink" title="pseudocode"></a>pseudocode</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">quickSort(array, p, r)</span><br><span class="line">  if (p &lt; r)</span><br><span class="line">    pivotIndex = partition(array,p, r)</span><br><span class="line">    quickSort(array, p, pivotIndex - 1)</span><br><span class="line">    quickSort(array, pivotIndex, r)</span><br><span class="line"></span><br><span class="line">partition(array, p, r)</span><br><span class="line">  set r as pivotIndex</span><br><span class="line">  storeIndex = p - 1</span><br><span class="line">  for i = p + 1 to r</span><br><span class="line">  if element[i] &lt; pivotElement</span><br><span class="line">    swap element[i] and element[storeIndex]</span><br><span class="line">    storeIndex++</span><br><span class="line">  swap pivotElement and element[storeIndex+1]</span><br><span class="line">return storeIndex + 1</span><br></pre></td></tr></table></figure><h2 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// Quick sort in Java</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">class Quicksort &#123;</span><br><span class="line"></span><br><span class="line">  // method to find the partition position</span><br><span class="line">  static int partition(int array[], int low, int high) &#123;</span><br><span class="line">    </span><br><span class="line">    // choose the rightmost element as pivot</span><br><span class="line">    int pivot = array[high];</span><br><span class="line">    </span><br><span class="line">    // pointer for greater element</span><br><span class="line">    int i = (low - 1);</span><br><span class="line"></span><br><span class="line">    // traverse through all elements</span><br><span class="line">    // compare each element with pivot</span><br><span class="line">    for (int j = low; j &lt; high; j++) &#123;</span><br><span class="line">      if (array[j] &lt;= pivot) &#123;</span><br><span class="line"></span><br><span class="line">        // if element smaller than pivot is found</span><br><span class="line">        // swap it with the greatr element pointed by i</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        // swapping element at i with element at j</span><br><span class="line">        int temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // swapt the pivot element with the greater element specified by i</span><br><span class="line">    int temp = array[i + 1];</span><br><span class="line">    array[i + 1] = array[high];</span><br><span class="line">    array[high] = temp;</span><br><span class="line"></span><br><span class="line">    // return the position from where partition is done</span><br><span class="line">    return (i + 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void quickSort(int array[], int low, int high) &#123;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line"></span><br><span class="line">      // find pivot element such that</span><br><span class="line">      // elements smaller than pivot are on the left</span><br><span class="line">      // elements greater than pivot are on the right</span><br><span class="line">      int pi = partition(array, low, high);</span><br><span class="line">      </span><br><span class="line">      // recursive call on the left of pivot</span><br><span class="line">      quickSort(array, low, pi - 1);</span><br><span class="line"></span><br><span class="line">      // recursive call on the right of pivot</span><br><span class="line">      quickSort(array, pi + 1, high);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Main class</span><br><span class="line">class Main &#123;</span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line"></span><br><span class="line">    int[] data = &#123; 8, 7, 2, 1, 0, 9, 6 &#125;;</span><br><span class="line">    System.out.println(&quot;Unsorted Array&quot;);</span><br><span class="line">    System.out.println(Arrays.toString(data));</span><br><span class="line"></span><br><span class="line">    int size = data.length;</span><br><span class="line"></span><br><span class="line">    // call quicksort() on array data</span><br><span class="line">    Quicksort.quickSort(data, 0, size - 1);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Sorted Array in Ascending Order: &quot;);</span><br><span class="line">    System.out.println(Arrays.toString(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-Counting-Sort"><a href="#3-Counting-Sort" class="headerlink" title=" 3.Counting Sort"></a><font color = "pink"> 3.Counting Sort</font></h1><ol><li>Find out the maximum element (let it be <code>max</code>) from the given array.</li></ol><p><img src="https://www.programiz.com/sites/tutorial2program/files/Counting-sort-0_0.png" alt="Counting Sort steps"></p><ol start="2"><li>Initialize an array of length <code>max+1</code> with all elements 0. This array is used for storing the count of the elements in the array.</li></ol><p><img src="https://www.programiz.com/sites/tutorial2program/files/Counting-sort-1.png" alt="Counting Sort Step"></p><ol start="3"><li><u>Store the count of each element</u> at their respective index in <code>count</code> array</li></ol><p>For example: <u>if the count of element 3 is 2 then, 2 is stored in the 3rd position of count array</u>. If element “5” is not present in the array, then 0 is stored in 5th position.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Counting-sort-2.png" alt="Counting Sort Step"></p><p><font color = "red">4. Store cumulative sum of the elements of the count array. It helps in placing the elements into the correct index of the sorted array.</font> (0, 0+1, 0+1+2, 0+1+2+2…..)</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Counting-sort-3.png" alt="Counting Sort Step"></p><ol start="5"><li>Find the index of each element of the original array in the count array. This gives the cumulative count. Place the element at the index calculated as shown in figure below.</li></ol><p><img src="https://www.programiz.com/sites/tutorial2program/files/Counting-sort-4_1.png" alt="Counting Sort Steps">6.  After placing each element at its correct position, decrease its count by one.</p><h2 id="Pesudocode"><a href="#Pesudocode" class="headerlink" title="Pesudocode"></a>Pesudocode</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">countingSort(array, size)</span><br><span class="line">  max &lt;- find largest element in array</span><br><span class="line">  initialize count array with all zeros</span><br><span class="line">  for j &lt;- 0 to size</span><br><span class="line">    find the total count of each unique element and </span><br><span class="line">    store the count at jth index in count array</span><br><span class="line">  for i &lt;- 1 to max</span><br><span class="line">    find the cumulative sum and !!!!!!! store it in count array itself !!!!!!</span><br><span class="line">  for j &lt;- size down to 1</span><br><span class="line">    restore the elements to array</span><br><span class="line">    decrease count of each element restored by 1</span><br></pre></td></tr></table></figure><h2 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counting sort in Java programming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[size + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the largest element of the array</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">        max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize count array with all zeros.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; ++i) &#123;</span><br><span class="line">      count[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the count of each element</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      count[array[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the cummulative count of each array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= max; i++) &#123;    <span class="comment">//notice, here i starts from 1</span></span><br><span class="line">      count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the index of each element of the original array in count array, and</span></span><br><span class="line">    <span class="comment">// place the elements in output array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      output[count[array[i]] - <span class="number">1</span>] = array[i];</span><br><span class="line">      count[array[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the sorted elements into original array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      array[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Driver code</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] data = &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> data.length;</span><br><span class="line">    <span class="type">CountingSort</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountingSort</span>();</span><br><span class="line">    cs.countSort(data, size);</span><br><span class="line">    System.out.println(<span class="string">&quot;Sorted Array in Ascending Order: &quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="4-Bucket-Sort"><a href="#4-Bucket-Sort" class="headerlink" title=" 4. Bucket Sort"></a><font color = "pink"> 4. Bucket Sort</font></h1><p>The process of bucket sort can be understood as a <strong>scatter-gather approach</strong>. Here, elements are first scattered into buckets then the elements in each bucket are sorted. Finally, the elements are gathered in order.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket_2.png" alt="Bucket Sort Working"></p><p>!!!!!!!</p><ol><li><p>Suppose, the input array is:</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket-sort-0.1_0.png" alt="Bucket Sort Steps">Input array</p><p>Create an array of size 10. Each slot of this array is used as a bucket for storing elements.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket-sort-0_0.png" alt="Bucket Sort Steps">Array in which each position is a bucket</p></li><li><p>Insert elements into the buckets from the array. The elements are inserted according to the range of the bucket.</p><p>In our example code, we have buckets each of ranges from 0 to 1, 1 to 2, 2 to 3,…… (n-1) to n.</p><p>Suppose, an input element is 0.23 is taken. It is multiplied by size &#x3D; 10 (ie. 0.23*10&#x3D;2.3 ). Then, it is converted into an integer (ie. 2.3≈2 ). Finally, .23 is inserted into bucket-2.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket-sort-0.2_0.png" alt="Bucket Sort Steps"></p><p>Similarly, 0.25 is also inserted into the same bucket. Everytime, the floor value of the floating point number is taken.</p><p>If we take integer numbers as input, we have to divide it by the interval (10 here) to get the floor value.</p><p>Similarly, other elements are inserted into their respective buckets.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket-sort-0.3_0.png" alt="Bucket Sort Steps"></p></li><li><p>The elements of each bucket are sorted using any of the stable sorting algorithms. Here, we have used quicksort (inbuilt function).</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket-sort-0.4_0.png" alt="Bucket Sort Steps"></p></li><li><p>The elements from each bucket are gathered.</p><p>It is done by iterating through the bucket and inserting an individual element into the original array in each cycle. The element from the bucket is erased once it is copied into the original array.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Bucket-sort-0.5_0.png" alt="Bucket Sort Steps"></p></li></ol><p>Bucket sort is used when:</p><ul><li>input is uniformly distributed over a range.</li><li>there are floating point values</li></ul><h2 id="Pseudocode-1"><a href="#Pseudocode-1" class="headerlink" title="Pseudocode"></a>Pseudocode</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bucketSort()</span><br><span class="line">  create N buckets each of which can hold a range of values</span><br><span class="line">  for all the buckets</span><br><span class="line">    initialize each bucket with 0 values</span><br><span class="line">  for all the buckets</span><br><span class="line">    put elements into buckets matching the range</span><br><span class="line">  for all the buckets </span><br><span class="line">    sort elements in each bucket</span><br><span class="line">  gather elements from each bucket</span><br><span class="line">end bucketSort</span><br></pre></td></tr></table></figure><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bucket sort in Java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">float</span>[] arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    ArrayList&lt;Float&gt;[] bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create empty buckets</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">      bucket[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Float&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add elements into the buckets</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> (<span class="type">int</span>) arr[i] * n;</span><br><span class="line">      bucket[bucketIndex].add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort the elements of each bucket</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      Collections.sort((bucket[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the sorted array</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, size = bucket[i].size(); j &lt; size; j++) &#123;</span><br><span class="line">        arr[index++] = bucket[i].get(j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Driver code</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BucketSort</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BucketSort</span>();</span><br><span class="line">    <span class="type">float</span>[] arr = &#123; (<span class="type">float</span>) <span class="number">0.42</span>, (<span class="type">float</span>) <span class="number">0.32</span>, (<span class="type">float</span>) <span class="number">0.33</span>, (<span class="type">float</span>) <span class="number">0.52</span>, (<span class="type">float</span>) <span class="number">0.37</span>, (<span class="type">float</span>) <span class="number">0.47</span>,</span><br><span class="line">        (<span class="type">float</span>) <span class="number">0.51</span> &#125;;</span><br><span class="line">    b.bucketSort(arr, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> i : arr)</span><br><span class="line">      System.out.print(i + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title=" Radix Sort"></a><font color = "pink"> Radix Sort</font></h1><ol><li><p>Find the largest element in the array, i.e. max. Let <code>X</code> be the number of digits in <code>max</code>. <code>X</code> is calculated because we have to go through all the significant places of all elements.</p><p>In this array <code>[121, 432, 564, 23, 1, 45, 788]</code>, we have the largest number 788. It has 3 digits. Therefore, the loop should go up to hundreds place (3 times).</p></li><li><p>Now, go through each significant place one by one.</p><p>Use any stable sorting technique to sort the digits at each significant place. We have used counting sort for this.</p><p>Sort the elements based on the unit place digits (X&#x3D;0).</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Radix-sort-one.png" alt="Radix Sort working with Counting Sort as intermediate step"></p></li><li><p>Now, sort the elements based on digits at tens place.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Radix-sort-ten.png" alt="Radix Sort Step"></p></li><li><p>Finally, sort the elements based on the digits at hundreds place.</p><p><img src="https://www.programiz.com/sites/tutorial2program/files/Radix-sort-hundred.png" alt="Selection Sort Step"></p></li></ol><h2 id="Pseudocode-2"><a href="#Pseudocode-2" class="headerlink" title="Pseudocode"></a>Pseudocode</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">radixSort(array)</span><br><span class="line">  d &lt;- maximum number of digits in the largest element</span><br><span class="line">  create d buckets of size 0-9</span><br><span class="line">  for i &lt;- 0 to d</span><br><span class="line">    sort the elements according to ith place digits using countingSort</span><br><span class="line"></span><br><span class="line">countingSort(array, d)</span><br><span class="line">  max &lt;- find largest element among dth place elements</span><br><span class="line">  initialize count array with all zeros</span><br><span class="line">  for j &lt;- 0 to size</span><br><span class="line">    find the total count of each unique digit in dth place of elements and</span><br><span class="line">    store the count at jth index in count array</span><br><span class="line">  for i &lt;- 1 to max</span><br><span class="line">    find the cumulative sum and store it in count array itself</span><br><span class="line">  for j &lt;- size down to 1</span><br><span class="line">    restore the elements to array</span><br><span class="line">    decrease count of each element restored by 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Radix Sort in Java Programming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Using counting sort to sort the elements in the basis of significant places</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> size, <span class="type">int</span> place)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] output = <span class="keyword">new</span> <span class="title class_">int</span>[size + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">        max = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[max + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; ++i)</span><br><span class="line">      count[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate count of elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      count[(array[i] / place) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate cumulative count</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      count[i] += count[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Place the elements in sorted order</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      output[count[(array[i] / place) % <span class="number">10</span>] - <span class="number">1</span>] = array[i];</span><br><span class="line">      count[(array[i] / place) % <span class="number">10</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      array[i] = output[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Function to get the largest element from an array</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">      <span class="keyword">if</span> (array[i] &gt; max)</span><br><span class="line">        max = array[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function to implement radix sort</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// Get maximum element</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(array, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply counting sort to sort elements based on place value.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">place</span> <span class="operator">=</span> <span class="number">1</span>; max / place &gt; <span class="number">0</span>; place *= <span class="number">10</span>)</span><br><span class="line">      countingSort(array, size, place);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Driver code</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] data = &#123; <span class="number">121</span>, <span class="number">432</span>, <span class="number">564</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">788</span> &#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> data.length;</span><br><span class="line">    <span class="type">RadixSort</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadixSort</span>();</span><br><span class="line">    rs.radixSort(data, size);</span><br><span class="line">    System.out.println(<span class="string">&quot;Sorted Array in Ascending Order: &quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="5-Heap-Sort"><a href="#5-Heap-Sort" class="headerlink" title=" 5. Heap Sort"></a><font color = "pink"> 5. Heap Sort</font></h1><h2 id="Detailed-Working-of-Heap-Sort"><a href="#Detailed-Working-of-Heap-Sort" class="headerlink" title="Detailed Working of Heap Sort"></a><strong>Detailed Working of Heap Sort</strong></h2><blockquote><p>To understand heap sort more clearly, let’s take an unsorted array and try to sort it using heap sort.<br>Consider the array: arr[] &#x3D; {4, 10, 3, 5, 1}.</p><p><strong>Build Complete Binary Tree:</strong> Build a complete binary tree from the array.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220802165905/1-660x366.png" alt="Build complete binary tree from the array"></p><p>Build complete binary tree from the array</p><p><strong>Transform into max heap:</strong> After that, the task is to construct a tree from that unsorted array and try to convert it into <a href="https://www.geeksforgeeks.org/difference-between-min-heap-and-max-heap/">max heap.</a></p><ul><li><font color ="red">To transform a heap into a max-heap, the parent node should always be greater than or equal to the child nodes</font><ul><li>Here, in this example, as the parent node <strong>4</strong> is smaller than the child node <strong>10,</strong> thus, swap them to build a max-heap.</li></ul></li></ul><p>Transform it into a max heap image widget</p><ul><li>Now, as seen, <strong>4</strong> as a parent is smaller than the child <strong>5</strong>, thus swap both of these again and the resulted heap and array should be like this:</li></ul><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220802170448/3-660x366.png" alt="Make the tree a max heap"></p><p>Make the tree a max heap</p><p><strong>Perform heap sort:</strong> Remove the maximum element in each step (i.e., move it to the end position and remove that) and then consider the remaining elements and transform it into a max heap.</p><ul><li><font color ="red">Delete the root element from the max heap. In order to delete this node, try to swap it with the last node, i.e. After removing the root element, again heapify it to convert it into max heap.</font><ul><li>Resulted heap and array should look like this:</li></ul></li></ul><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220802170744/4-571x660.png" alt="Remove 10 and perform heapify"></p><p>Remove 10 and perform heapify</p><ul><li>Repeat the above steps and it will look like the following:</li></ul><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220802170850/5-660x587.png" alt="Remove 5 and perform heapify"></p><p>Remove 5 and perform heapify</p><ul><li>Now remove the root (i.e. 3) again and perform heapify.</li></ul><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220802171042/6-660x402.png" alt="Remove 4 and perform heapify"></p><p>Remove 4 and perform heapify</p><ul><li>Now when the root is removed once again it is sorted. and the sorted array will be like <strong>arr[] &#x3D; {1, 3, 4, 5, 10}</strong>.</li></ul><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20220802171331/7-660x195.png" alt="The sorted array"></p></blockquote><h1 id="Complexity"><a href="#Complexity" class="headerlink" title=" Complexity"></a><font color = "pink"> Complexity</font></h1><h2 id="Quicksort-Complexity"><a href="#Quicksort-Complexity" class="headerlink" title="Quicksort Complexity"></a><font color = "watermel">Quicksort Complexity</font></h2><table><thead><tr><th align="left"><strong>Time Complexity</strong></th><th></th></tr></thead><tbody><tr><td align="left">Best</td><td>O(n*log n)</td></tr><tr><td align="left">Worst</td><td>O(n2)</td></tr><tr><td align="left">Average</td><td>O(n*log n)</td></tr><tr><td align="left"><strong>Space Complexity</strong></td><td>O(log n)</td></tr><tr><td align="left"><strong>Stability</strong></td><td>No</td></tr></tbody></table><ul><li><p><strong>Worst Case Complexity [Big-O]</strong>: <code>O(n2)</code><br>It occurs when the pivot element picked is <u>either the greatest or the smallest element</u>.</p><p>This condition leads to the case in which the pivot element lies in an extreme end of the sorted array. <u>One sub-array is always empty and another sub-array contains <code>n - 1</code> elements. Thus, quicksort is called only on this sub-array</u>.</p><p>However, the quicksort algorithm has better performance for scattered pivots.</p></li><li><p><strong>Best Case Complexity [Big-omega]</strong>: <code>O(n*log n)</code><br>It occurs when the pivot element is always the <u>middle</u> element or near to the middle element.</p></li><li><p><strong>Average Case Complexity [Big-theta]</strong>: <code>O(n*log n)</code><br>It occurs when the above conditions do not occur.</p></li></ul><h2 id="Merge-Sort-Complexity"><a href="#Merge-Sort-Complexity" class="headerlink" title="Merge Sort Complexity"></a><font color = "watermel">Merge Sort Complexity</font></h2><table><thead><tr><th align="left"><strong>Time Complexity</strong></th><th></th></tr></thead><tbody><tr><td align="left">Best</td><td>O(n*log n)</td></tr><tr><td align="left">Worst</td><td>O(n*log n)</td></tr><tr><td align="left">Average</td><td>O(n*log n)</td></tr><tr><td align="left"><strong>Space Complexity</strong></td><td>O(n)</td></tr><tr><td align="left"><strong>Stability</strong></td><td>Yes</td></tr></tbody></table><h2 id="Counting-Sort-Complexity"><a href="#Counting-Sort-Complexity" class="headerlink" title="Counting Sort Complexity"></a><font color = "watermel">Counting Sort Complexity</font></h2><table><thead><tr><th align="left"><strong>Time Complexity</strong></th><th></th></tr></thead><tbody><tr><td align="left">Best</td><td>O(n+k)</td></tr><tr><td align="left">Worst</td><td>O(n+k)</td></tr><tr><td align="left">Average</td><td>O(n+k)</td></tr><tr><td align="left"><strong>Space Complexity</strong></td><td>O(max)</td></tr><tr><td align="left"><strong>Stability</strong></td><td>Yes</td></tr></tbody></table><p><strong>Time Complexities</strong></p><p>There are mainly four main loops. (Finding the greatest value can be done outside the function.)</p><table><thead><tr><th align="left">for-loop</th><th align="left">time of counting</th></tr></thead><tbody><tr><td align="left">1st</td><td align="left">O(max)</td></tr><tr><td align="left">2nd</td><td align="left">O(size)</td></tr><tr><td align="left">3rd</td><td align="left">O(max)</td></tr><tr><td align="left">4th</td><td align="left">O(size)</td></tr></tbody></table><p>Overall complexity &#x3D; <code>O(max)+O(size)+O(max)+O(size)</code> &#x3D; <code>O(max+size)</code>  max -&gt; n, size-&gt;k</p><ul><li><strong>Worst Case Complexity:</strong> <code>O(n+k)</code></li><li><strong>Best Case Complexity:</strong> <code>O(n+k)</code></li><li><strong>Average Case Complexity:</strong> <code>O(n+k)</code></li></ul><p>In all the above cases, the complexity is the same because no matter how the elements are placed in the array, the algorithm goes through <code>n+k</code> times.</p><p>The space complexity of Counting Sort is <code>O(max)</code>. Larger the range of elements, larger is the space complexity.</p><h2 id="Bucket-Sort-Complexity"><a href="#Bucket-Sort-Complexity" class="headerlink" title="Bucket Sort Complexity"></a><font color = "watermel">Bucket Sort Complexity</font></h2><table><thead><tr><th align="left"><strong>Time Complexity</strong></th><th></th></tr></thead><tbody><tr><td align="left">Best</td><td>O(n+k)</td></tr><tr><td align="left">Worst</td><td>O(n2)</td></tr><tr><td align="left">Average</td><td>O(n)</td></tr><tr><td align="left"><strong>Space Complexity</strong></td><td>O(n+k)</td></tr><tr><td align="left"><strong>Stability</strong></td><td>Yes</td></tr></tbody></table><ul><li><strong>Worst Case Complexity:</strong> <code>O(n2)</code><br>When there are elements of close range in the array, they are likely to be placed in the same bucket. This may result in some buckets having more number of elements than others.<br>It makes the complexity depend on the sorting algorithm used to sort the elements of the bucket.<br>The complexity becomes even worse when the elements are in reverse order. If insertion sort is used to sort elements of the bucket, then the time complexity becomes <code>O(n2)</code>.</li><li><strong>Best Case Complexity:</strong> <code>O(n+k)</code><br>It occurs when the elements are uniformly distributed in the buckets with a nearly equal number of elements in each bucket.<br>The complexity becomes even better if the elements inside the buckets are already sorted.<br>If insertion sort is used to sort elements of a bucket then the overall complexity in the best case will be linear ie. <code>O(n+k)</code>. <code>O(n)</code> is the complexity for making the buckets and <code>O(k)</code> is the complexity for sorting the elements of the bucket using algorithms having linear time complexity at the best case.</li><li><strong>Average Case Complexity:</strong> <code>O(n)</code><br>It occurs when the elements are distributed randomly in the array. Even if the elements are not distributed uniformly, bucket sort runs in linear time. It holds true until the sum of the squares of the bucket sizes is linear in the total number of elements.</li></ul><h2 id="Radix-Sort-Complexity"><a href="#Radix-Sort-Complexity" class="headerlink" title="Radix Sort Complexity"></a><font color = "watermel">Radix Sort Complexity</font></h2><table><thead><tr><th align="left"><strong>Time Complexity</strong></th><th></th></tr></thead><tbody><tr><td align="left">Best</td><td>O(n+k)</td></tr><tr><td align="left">Worst</td><td>O(n+k)</td></tr><tr><td align="left">Average</td><td>O(n+k)</td></tr><tr><td align="left"><strong>Space Complexity</strong></td><td>O(max)</td></tr><tr><td align="left"><strong>Stability</strong></td><td>Yes</td></tr></tbody></table><hr><p>Since radix sort is a non-comparative algorithm, it has advantages over comparative sorting algorithms.</p><p>For the radix sort that uses counting sort as an intermediate stable sort, the time complexity is <code>O(d(n+k))</code>.</p><p>Thus, radix sort has linear time complexity which is better than <code>O(nlog n)</code> of comparative sorting algorithms.</p><p>If we take very large digit numbers or the number of other bases like 32-bit and 64-bit numbers then it can perform in linear time however the intermediate sort takes large space.</p><p>This makes radix sort space inefficient. This is the reason why this sort is not used in software libraries.</p><p>[TOC]</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph 🌺</title>
      <link href="/2023/02/15/algorithm/graph/"/>
      <url>/2023/02/15/algorithm/graph/</url>
      
        <content type="html"><![CDATA[<h2 id="Components-of-a-Graph"><a href="#Components-of-a-Graph" class="headerlink" title="Components of a Graph"></a>Components of a Graph</h2><ul><li><strong>Vertices*&#x2F;<em>ˈvɜːrtɪsiː</em>&#x2F;*:</strong> Vertices are the fundamental units of the graph. Sometimes, vertices are also known as vertex or nodes. Every node&#x2F;vertex can be labeled or unlabelled.</li><li><strong>Edges:</strong> Edges are drawn or used to connect two nodes of the graph. It can be ordered pair of nodes in a directed graph. Edges can connect any two nodes in any possible way. There are no rules. Sometimes, edges are also known as arcs. Every edge can be labeled&#x2F;unlabelled.</li></ul><p>The graph is denoted by <strong>G(V, E).</strong></p><h2 id="Types-Of-Graph"><a href="#Types-Of-Graph" class="headerlink" title="Types Of Graph"></a><strong>Types Of Graph</strong></h2><h4 id="Undirected-Graph"><a href="#Undirected-Graph" class="headerlink" title="Undirected Graph"></a>Undirected Graph</h4><ul><li>cannot have self loop</li></ul><p>A graph in which edges do not have any direction. That is the nodes are unordered pairs in the definition of every edge. </p><h4 id="Directed-Graph"><a href="#Directed-Graph" class="headerlink" title="Directed Graph"></a>Directed Graph</h4><ul><li>self loops allowed</li></ul><p>A graph in which edge has direction. That is the nodes are ordered pairs in the definition of every edge.</p><p><a href="https://media.geeksforgeeks.org/wp-content/uploads/20200630114438/directed.jpg"><img src="https://media.geeksforgeeks.org/wp-content/uploads/20200630114438/directed.jpg" alt="img"></a></p><p><strong>Weighted Graph</strong></p><ul><li>A graph in which the edges are already specified with suitable weight is known as a weighted graph. </li><li>Weighted graphs can be further classified as directed weighted graphs and undirected weighted graphs.</li></ul><p><font color = "red"> <strong>Dense Graph</strong>: </font></p><p>A dense graph is a graph in which there is a large number of edges. Typically in a dense graph, the number of edges is close to the maximum number of edges.</p><ul><li>the maximum edges for a tree: E  ≈ V^2. (consider self loops)</li></ul><p><font color = "red"><strong>Sparse Graph</strong>:</font></p><p> A sparse graph is a graph in which there is a small number of edges. In this case the number of edges is considerably less than the maximum number of edges.</p><p>the graph which is least dense is actually a tree.</p><ul><li>the minimum edges for a tree: E &#x3D; V -1. E &lt;&lt;  V^2</li></ul><h3 id="Adjacency"><a href="#Adjacency" class="headerlink" title="Adjacency"></a>Adjacency</h3><p>Adjacency relationship is:</p><ul><li>Symmetric if G is undirected.</li><li>Not necessarily so if G is directed.</li></ul><p>Here are the norms of adjacency −</p><ul><li>In a graph, two vertices are said to be <strong>adjacent</strong>, if there is an edge between the two vertices. Here, the adjacency of vertices is maintained by the single edge that is connecting those two vertices.</li><li>In a graph, two edges are said to be adjacent, if there is a common vertex between the two edges. Here, the adjacency of edges is maintained by the single vertex that is connecting two edges.</li></ul><p>**Example **</p><p><img src="https://www.tutorialspoint.com/graph_theory/images/adjacency.jpg" alt="Adjacency"></p><p>In the above graph −</p><ul><li>‘a’ and ‘b’ are the adjacent vertices, as there is a common edge ‘ab’ between them.</li><li>‘a’ and ‘d’ are the adjacent vertices, as there is a common edge ‘ad’ between them.</li><li>ab’ and ‘be’ are the adjacent edges, as there is a common vertex ‘b’ between them.</li><li>be’ and ‘de’ are the adjacent edges, as there is a common vertex ‘e’ between them.</li></ul><h2 id="Connected"><a href="#Connected" class="headerlink" title="Connected:"></a>Connected:</h2><p>if G is connected:</p><p>there is a path between every pair of vertices.</p><p>From every node you can get to every other node.</p><h1 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm:"></a>Prim’s Algorithm:</h1><blockquote><iframe frameborder="0" src="https://428b683dddf07d0e14e3e8d64eae3a16.safeframe.googlesyndication.com/safeframe/1-0-40/html/container.html" id="google_ads_iframe_/27823234/GFG_Desktop_PostContent_336x280_0" title="3rd party ad content" name="" scrolling="no" marginwidth="0" marginheight="0" width="1" height="1" data-is-safeframe="true" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="3" data-load-complete="true" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 17px; vertical-align: bottom; max-width: 100%;"></iframe><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223140007/mstdrawio.png" alt="Example of a graph"></p><p>Example of a graph</p><p><strong>Step 1:</strong> Firstly, we select an arbitrary vertex that acts as the starting vertex of the Minimum Spanning Tree. Here we have selected vertex <strong>0</strong> as the starting vertex.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223140425/mst1drawio.png" alt="0 is selected as starting vertex"></p><p>0 is selected as starting vertex</p><p><strong>Step 2:</strong> All the edges connecting the incomplete MST and other vertices are the edges {0, 1} and {0, 7}. Between these two the edge with minimum weight is {0, 1}. So include the edge and vertex 1 in the MST.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223140811/mst2drawio.png" alt="1 is added to the MST"></p><p>1 is added to the MST</p><p> <strong>Step 3:</strong> The edges connecting the incomplete MST to other vertices are {0, 7}, {1, 7} and {1, 2}. Among these edges the minimum weight is 8 which is of the edges {0, 7} and {1, 2}. Let us here include the edge {0, 7} and the vertex 7 in the MST. [We could have also included edge {1, 2} and vertex 2 in the MST]. </p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223152544/mst3drawio.png" alt="7 is added in the MST"></p><p>7 is added in the MST</p><p><strong>Step 4:</strong> The edges that connect the incomplete MST with the fringe vertices are {1, 2}, {7, 6} and {7, 8}. Add the edge {7, 6} and the vertex 6 in the MST as it has the least weight (i.e., 1).</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223153113/mst4drawio.png" alt="6 is added in the MST"></p><p>6 is added in the MST</p><p><strong>Step 5:</strong> The connecting edges now are {7, 8}, {1, 2}, {6, 8} and {6, 5}. Include edge {6, 5} and vertex 5 in the MST as the edge has the minimum weight (i.e., 2) among them.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223153329/mst5drawio.png" alt="Include vertex 5 in the MST"></p><p>Include vertex 5 in the MST</p><p><strong>Step 6:</strong> Among the current connecting edges, the edge {5, 2} has the minimum weight. So include that edge and the vertex 2 in the MST.</p><iframe frameborder="0" src="https://428b683dddf07d0e14e3e8d64eae3a16.safeframe.googlesyndication.com/safeframe/1-0-40/html/container.html" id="google_ads_iframe_/27823234/gfg_outstream_incontent_0" title="3rd party ad content" name="" scrolling="no" marginwidth="0" marginheight="0" width="1" height="1" data-is-safeframe="true" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="7" data-load-complete="true" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; font-size: 17px; vertical-align: bottom; max-width: 100%;"></iframe><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223153618/mst6drawio.png" alt="Include vertex 2 in the MST"></p><p>Include vertex 2 in the MST</p><p><strong>Step 7:</strong> The connecting edges between the incomplete MST and the other edges are {2, 8}, {2, 3}, {5, 3} and {5, 4}. The edge with minimum weight is edge {2, 8} which has weight 2. So include this edge and the vertex 8 in the MST.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223153852/mst7drawio.png" alt="Add vertex 8 in the MST"></p><p>Add vertex 8 in the MST</p><p><strong>Step 8:</strong> See here that the edges {7, 8} and {2, 3} both have same weight which are minimum. But 7 is already part of MST. So we will consider the edge {2, 3} and include that edge and vertex 3 in the MST.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223154124/mst8drawio.png" alt="Include vertex 3 in MST"></p><p>Include vertex 3 in MST</p><p><strong>Step 9:</strong> Only  the vertex 4 remains to be included. The minimum weighted edge from the incomplete MST to 4 is {3, 4}.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223154246/mst9drawio.png" alt="Include vertex 4 in the MST"></p><p>Include vertex 4 in the MST</p><p>The final structure of the MST is as follows and the weight of the edges of the MST is (4 + 8 + 1 + 2 + 4 + 2 + 7 + 9) &#x3D; <strong>37</strong>.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223154442/finalmstdrawio.png" alt="The structure of the MST formed using the above method"></p><p>The structure of the MST formed using the above method</p><p><strong>Note:</strong> If we had selected the edge {1, 2} in the third step then the MST would look like the following.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230223154535/alternatemstdrawio.png" alt="Structure of the alternate MST if we had selected edge {1, 2} in the MST"></p><p>Structure of the alternate MST if we had selected edge {1, 2} in the MST</p></blockquote><h1 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm:"></a>Kruskal’s Algorithm:</h1><ol><li><p>Sort all the edges in non-decreasing order of their weight. </p></li><li><p>Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If the cycle is not formed, include this edge. Else, discard it. </p></li><li><p>Repeat step#2 until there are (V-1) edges in the spanning tree.</p></li></ol><blockquote><p><strong>Input Graph:</strong></p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20210727035309/UntitledDiagram92.png" alt="Kruskal’s Minimum Spanning Tree Algorithm"></p><p>The graph contains 9 vertices and 14 edges. So, the minimum spanning tree formed will be having (9 – 1) &#x3D; 8 edges.<br>After sorting:</p><table><thead><tr><th>Weight</th><th>Source</th><th>Destination</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>6</td></tr><tr><td>2</td><td>8</td><td>2</td></tr><tr><td>2</td><td>6</td><td>5</td></tr><tr><td>4</td><td>0</td><td>1</td></tr><tr><td>4</td><td>2</td><td>5</td></tr><tr><td>6</td><td>8</td><td>6</td></tr><tr><td>7</td><td>2</td><td>3</td></tr><tr><td>7</td><td>7</td><td>8</td></tr><tr><td>8</td><td>0</td><td>7</td></tr><tr><td>8</td><td>1</td><td>2</td></tr><tr><td>9</td><td>3</td><td>4</td></tr><tr><td>10</td><td>5</td><td>4</td></tr><tr><td>11</td><td>1</td><td>7</td></tr><tr><td>14</td><td>3</td><td>5</td></tr></tbody></table><p>Now pick all edges one by one from the sorted list of edges </p><p><strong>Step 1:</strong> Pick edge 7-6. No cycle is formed, include it. </p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306132726/img1drawio.png" alt="Add edge 7-6 in the MST"></p><p>Add edge 7-6 in the MST</p><p><strong>Step 2:</strong> <em>Pick edge 8-2.</em> No cycle is formed, include it. </p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306132819/img2drawio.png" alt="Add edge 8-2 in the MST"></p><p>Add edge 8-2 in the MST</p><p><strong>Step 3:</strong> <em>Pick edge 6-5.</em> No cycle is formed, include it. </p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306132901/img3drawio.png" alt="Add edge 6-5 in the MST"></p><p>Add edge 6-5 in the MST</p><p><strong>Step 4:</strong> <em>Pick edge 0-1.</em> No cycle is formed, include it.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306132939/img4drawio.png" alt="Add edge 0-1 in the MST"></p><p>Add edge 0-1 in the MST</p><p><strong>Step 5:</strong> <em>Pick edge 2-5.</em> No cycle is formed, include it.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306133028/img5drawio.png" alt="Add edge 0-1 in the MST"></p><p>Add edge 2-5 in the MST</p><p><em><strong>Step 6:</strong> Pick edge 8-6.</em> Since including this edge results in the cycle, discard it. <em>Pick edge 2-3:</em> No cycle is formed, include it.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306133247/img6drawio.png" alt="Add edge 2-3 in the MST"></p><p>Add edge 2-3 in the MST</p><p><strong>Step 7:</strong> <em>Pick edge 7-8.</em> Since including this edge results in the cycle, discard it. <em>Pick edge 0-7.</em> No cycle is formed, include it.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306133618/img7drawio.png" alt="Add edge 0-7 in MST"></p><p>Add edge 0-7 in MST</p><p><strong>Step 8:</strong> <em>Pick edge 1-2.</em> Since including this edge results in the cycle, discard it. <em>Pick edge 3-4.</em> No cycle is formed, include it.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230306133406/img8drawio.png" alt="Add edge 3-4 in the MST"></p><p>Add edge 3-4 in the MST</p><p><strong>Note:</strong> Since the number of edges included in the MST equals to (V – 1), so the algorithm stops here</p></blockquote><h1 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm:"></a>Dijkstra Algorithm:</h1><blockquote><p>To understand the Dijkstra’s Algorithm lets take a graph and find the shortest path from source to all nodes.<br>Consider below graph and <strong>src &#x3D; 0</strong></p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/Fig-11.jpg" alt="img"></p><p><strong>Step 1:</strong></p><ul><li>The set <em><strong>sptSet</strong></em> is initially empty and distances assigned to vertices are {0, INF, INF, INF, INF, INF, INF, INF} where <strong>INF</strong> indicates infinite. </li><li>Now pick the vertex with a minimum distance value. The vertex 0 is picked, include it in <em>sptSet</em>. So <em>sptSet</em> becomes {0}. After including 0 to <em>sptSet</em>, update distance values of its adjacent vertices. </li><li>Adjacent vertices of 0 are 1 and 7. The distance values of 1 and 7 are updated as 4 and 8.</li></ul><p>The following subgraph shows vertices and their distance values, only the vertices with finite distance values are shown. The vertices included in SPT are shown in <strong>green</strong> colour.</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/MST1.jpg" alt="img"></p><p><strong>Step 2:</strong></p><ul><li>Pick the vertex with minimum distance value and not already included in SPT (not in sptSET). The vertex 1 is picked and added to sptSet. </li><li>So sptSet now becomes {0, 1}. Update the distance values of adjacent vertices of 1. </li><li>The distance value of vertex 2 becomes <strong>12</strong>.</li></ul><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/DIJ2.jpg" alt="img"></p><p><strong>Step 3:</strong> </p><ul><li>Pick the vertex with minimum distance value and not already included in SPT (not in sptSET). Vertex 7 is picked. So sptSet now becomes <strong>{0, 1, 7}.</strong> </li><li><strong><font color ="red">Update the distance values of adjacent vertices of 7( only 7, no vertex 2)</font>.</strong> The distance value of vertex 6 and 8 becomes finite (<strong>15 and 9</strong> respectively).</li></ul><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/DIJ3.jpg" alt="img"></p><p><strong>Step 4:</strong></p><ul><li>Pick the vertex with minimum distance value and not already included in SPT (not in sptSET). Vertex 6 is picked. So sptSet now becomes <strong>{0, 1, 7, 6}</strong>. </li><li>Update the distance values of adjacent vertices of 6. The distance value of vertex 5 and 8 are updated.</li></ul><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/DIJ4.jpg" alt="img"></p><p>We repeat the above steps until <em>sptSet</em> <strong>includes</strong> all vertices of the given graph. Finally, we get the following Shortest Path Tree (SPT).</p><p><img src="https://www.geeksforgeeks.org/wp-content/uploads/DIJ5.jpg" alt="img"></p></blockquote><h1 id="Bellman–Ford-Algorithm"><a href="#Bellman–Ford-Algorithm" class="headerlink" title="Bellman–Ford Algorithm"></a>Bellman–Ford Algorithm</h1><p><strong>Step 1:</strong> Let the given source vertex be 0. Initialize all distances as infinite, except the distance to the source itself. Total number of vertices in the graph is 5, so <em>all edges must be processed 4 times.</em></p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/bellmanford1.png" alt="Bellman–Ford Algorithm Example Graph 1"></p><p><strong>Step 2:</strong> Let all edges are processed in the following order: (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), (E, D). We get the following distances when all edges are processed the first time. The first row shows initial distances. The second row shows distances when edges (B, E), (D, B), (B, D) and (A, B) are processed. The third row shows distances when (A, C) is processed. The fourth row shows when (D, C), (B, C) and (E, D) are processed. </p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/bellmanford2.png" alt="Bellman–Ford Algorithm Example Graph 2"></p><p><strong>Step 3:</strong> The first iteration guarantees to give all shortest paths which are at most 1 edge long. We get the following distances when all edges are processed second time (The last row shows final values). </p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/bellmanford3.png" alt="Bellman–Ford Algorithm Example Graph 3"></p><p><strong>Step 4:</strong> The second iteration guarantees to give all shortest paths which are at most 2 edges long. The algorithm processes all edges 2 more times. The distances are minimized after the second iteration, so third and fourth iterations don’t update the distances.</p><h1 id="Floyd-Warshall-Algorithm"><a href="#Floyd-Warshall-Algorithm" class="headerlink" title="Floyd-Warshall Algorithm"></a>Floyd-Warshall Algorithm</h1>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Array &amp; Hash</title>
      <link href="/2023/02/13/LeetCode/Array%20&amp;%20Hash/"/>
      <url>/2023/02/13/LeetCode/Array%20&amp;%20Hash/</url>
      
        <content type="html"><![CDATA[<h1 id="Array-amp-Hash-🌼"><a href="#Array-amp-Hash-🌼" class="headerlink" title="Array &amp; Hash 🌼"></a>Array &amp; Hash 🌼</h1><h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>An <code>interface</code> is a completely “<strong>abstract class</strong>“ that is used to group related methods with <strong>empty bodies</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">animalSound</span><span class="params">()</span>; <span class="comment">// interface method (does not have a body)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// interface method (does not have a body)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To access the interface methods, the interface must be “implemented” (kinda like inherited) by another class with the <code>implements</code> keyword (instead of <code>extends</code>). The body of the interface method is provided by the “implement” class:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">animalSound</span><span class="params">()</span>; <span class="comment">// interface method (does not have a body)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>; <span class="comment">// interface method (does not have a body)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pig &quot;implements&quot; the Animal interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">animalSound</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The body of animalSound() is provided here</span></span><br><span class="line">    System.out.println(<span class="string">&quot;The pig says: wee wee&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// The body of sleep() is provided here</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Zzz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Pig</span> <span class="variable">myPig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();  <span class="comment">// Create a Pig object</span></span><br><span class="line">    myPig.animalSound();</span><br><span class="line">    myPig.sleep();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>Notes on Interfaces:</strong></p><ul><li>Like <strong>abstract classes</strong>, interfaces <strong>cannot</strong> be used to create objects (in the example above, it is not possible to create an “Animal” object in the MyMainClass)</li><li>Interface methods do not have a body - the body is provided by the “implement” class</li><li>On implementation of an interface, you must <strong>override all of its methods</strong></li><li>Interface methods are by default <code>abstract</code> and <code>public</code></li><li>Interface attributes are by default <code>public</code>, <code>static</code> and <code>final</code></li><li>An interface <strong>cannot contain a constructor</strong> (as it cannot be used to create objects)</li></ul><p><strong>Why And When To Use Interfaces?</strong></p><ol><li><p>To achieve <strong>security</strong> - hide certain details and only show the important details of an object (interface).</p></li><li><p>Java does not support “multiple inheritance” (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can <strong>implement multiple interfaces.</strong> <strong>Note:</strong> To implement multiple interfaces, separate them with a comma (see example below).</p></li></ol><h2 id="Lambda-expression"><a href="#Lambda-expression" class="headerlink" title="Lambda expression"></a>Lambda expression</h2><p>Lambda Expressions were added in Java 8.</p><p>A lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.</p><p>Syntax</p><p>The simplest lambda expression contains a single parameter and an expression:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter -&gt; expression</span><br></pre></td></tr></table></figure><p>To use more than one parameter, wrap them in parentheses:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameter1, parameter2) -&gt; expression</span><br></pre></td></tr></table></figure><p>Expressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as <code>if</code> or <code>for</code>. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a <code>return</code> statement.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameter1, parameter2) -&gt; &#123; code block &#125;</span><br></pre></td></tr></table></figure><p>Example</p><p>Use a lambda expression in the <code>ArrayList</code>‘s <code>forEach()</code> method to print every item in the list:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    numbers.add(<span class="number">5</span>);</span><br><span class="line">    numbers.add(<span class="number">9</span>);</span><br><span class="line">    numbers.add(<span class="number">8</span>);</span><br><span class="line">    numbers.add(<span class="number">1</span>);</span><br><span class="line">    numbers.forEach( (n) -&gt; &#123; System.out.println(n); &#125; );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>To use a lambda expression in a method, <strong>the method should have a parameter with a single-method interface as its type</strong>. Calling the interface’s method will run the lambda expression:</p><p>Example</p><p>Create a method which takes a lambda expression as a parameter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringFunction</span> &#123;</span><br><span class="line">  String <span class="title function_">run</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringFunction</span> <span class="variable">exclaim</span> <span class="operator">=</span> (s) -&gt; s + <span class="string">&quot;!&quot;</span>;   </span><br><span class="line">    <span class="type">StringFunction</span> <span class="variable">ask</span> <span class="operator">=</span> (s) -&gt; s + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    printFormatted(<span class="string">&quot;Hello&quot;</span>, exclaim);</span><br><span class="line">    printFormatted(<span class="string">&quot;Hello&quot;</span>, ask);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFormatted</span><span class="params">(String str, StringFunction format)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> format.run(str);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hello!</span><br><span class="line">Hello?</span><br></pre></td></tr></table></figure><h2 id="Double-colon-operator"><a href="#Double-colon-operator" class="headerlink" title="Double colon :: operator"></a>Double colon :: operator</h2><p>They behave exactly as the lambda expressions. The only difference it has from lambda expressions is that this uses direct reference to the method by name instead of providing a delegate to the method.</p><p><strong>Syntax:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Class name&gt;::&lt;method name&gt;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong> To print all elements of the stream:</p><ul><li><p>Using Lambda expression:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach( s-&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java code to print the elements of Stream</span></span><br><span class="line"><span class="comment">// without using double colon operator</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.stream.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GFG</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> `main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the stream</span></span><br><span class="line">    Stream&lt;String&gt; stream</span><br><span class="line">      = Stream.of(<span class="string">&quot;Geeks&quot;</span>, <span class="string">&quot;For&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Geeks&quot;</span>, <span class="string">&quot;A&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Computer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Portal&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Print the stream</span></span><br><span class="line">    stream.forEach(s -&gt; System.out.println(s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Geeks</span><br><span class="line">For</span><br><span class="line">Geeks</span><br><span class="line">A</span><br><span class="line">Computer</span><br><span class="line">Portal</span><br></pre></td></tr></table></figure><p>Using double colon operator:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.forEach( System.out::println);</span><br></pre></td></tr></table></figure><p><strong>When and how to use double colon operator?</strong></p><p>Method reference or double colon operator can be used to refer:</p><ul><li>a static method,</li><li>an instance method, or</li><li>a constructor.</li></ul><p>How to use method reference in Java:</p><ol><li><p>Static method</p><p><strong>Syntax:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ClassName::methodName)</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeClass::someStaticMethod</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java code to show use of double colon operator</span></span><br><span class="line"><span class="comment">// for static methods</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GFG</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static function to be called</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">someFunction</span><span class="params">(String s)</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Geeks&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;For&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;GEEKS&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the static method</span></span><br><span class="line"><span class="comment">// using double colon operator</span></span><br><span class="line">list.forEach(GFG::someFunction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Geeks</span><br><span class="line">For</span><br><span class="line">GEEKS</span><br></pre></td></tr></table></figure><ol start="2"><li>Instance method</li></ol><p><strong>Syntax:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(objectOfClass::methodName)</span><br></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out::println</span><br></pre></td></tr></table></figure><p><strong>Program:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// Java code to show use of double colon operator</span><br><span class="line">// for instance methods</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class GFG &#123;</span><br><span class="line"></span><br><span class="line">// instance function to be called</span><br><span class="line">void someFunction(String s)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;Geeks&quot;);</span><br><span class="line">list.add(&quot;For&quot;);</span><br><span class="line">list.add(&quot;GEEKS&quot;);</span><br><span class="line"></span><br><span class="line">// call the instance method</span><br><span class="line">// using double colon operator</span><br><span class="line">list.forEach((new GFG())::someFunction);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Geeks</span><br><span class="line">For</span><br><span class="line">GEEKS</span><br></pre></td></tr></table></figure><p><a href="https://www.geeksforgeeks.org/double-colon-operator-in-java/">https://www.geeksforgeeks.org/double-colon-operator-in-java/</a></p><h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p>Easy</p><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have *<strong>exactly* one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,7,11,15], target = 9</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,4], target = 6</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,3], target = 6</span><br><span class="line">Output: [0,1]</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123; </span><br><span class="line">      <span class="comment">// use HashMap to record the values in num and the order of num[i]</span></span><br><span class="line">      <span class="comment">// also HashMap can find elements fast ,using containsKey containsValue function</span></span><br><span class="line">​    HashMap&lt;Integer, Integer&gt; mark = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;(); </span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line"></span><br><span class="line">​       <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - num;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">if</span>(mark.containsKey(diff))&#123;</span><br><span class="line"></span><br><span class="line">​       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;mark.get(diff),i&#125;;</span><br><span class="line"></span><br><span class="line">​       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​           mark.put(num, i);</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h2><p>Medium</p><p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]</span><br><span class="line">Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;&quot;]</span><br><span class="line">Output: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;a&quot;]</span><br><span class="line">Output: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">//returned value</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// check input </span></span><br><span class="line">        <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// Use computeIfAbsent of HashMap to check if it has previous anagrams</span></span><br><span class="line">        <span class="comment">// String -&gt; int[] Hash; List&lt;String&gt; -&gt; String s</span></span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="comment">// use int array to record component letters of each s </span></span><br><span class="line">            <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                hash[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// turn int array into string so we can compare if there&#x27;s same key</span></span><br><span class="line">            <span class="comment">// if we don&#x27;t turn into string here then we need to do a loop for 26 times to see if there&#x27;s a same hash before which is not worth it</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Arrays.toString(hash)); 🌟</span><br><span class="line">            <span class="comment">//use computeIfAbsent to see if there&#x27;s a anagram of s before </span></span><br><span class="line">            <span class="comment">// if no then create a new arraylist in value</span></span><br><span class="line">            <span class="comment">// if yes then computeIfAbsent won&#x27;t do anything</span></span><br><span class="line">            map.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); 🌟🌟 </span><br><span class="line">            <span class="comment">// s will be added to the existing arraylist</span></span><br><span class="line">            map.get(key).add(s); 🌟</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// values of the HashMap(trype: List&lt;String&gt;) are the answer</span></span><br><span class="line">        res.addAll(map.values()); 🌟</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭕ For List, it’s addAll; </p><p>​      For HashMap, it’s putAll</p><p>⭕ List&lt;List<String>&gt; res &#x3D; new ArrayList&lt;&gt;<font color = "red">()</font>;     remember there’s a parenthesis</p><p>⭕ It’s  Arrays.toString(hash), instead of hash.Arrays.toString()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()); </span><br><span class="line">map.get(key).add(s); </span><br></pre></td></tr></table></figure><p>the above is equal to the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(! map.containsKey(mid))&#123;</span><br><span class="line">List&lt;String&gt; x = new ArrayList&lt;&gt;();</span><br><span class="line">   map.put(mid, x);</span><br><span class="line"> &#125;</span><br><span class="line"> map.get(mid).add(s);</span><br></pre></td></tr></table></figure><h2 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h2><p>Medium</p><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li><li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li></ul><p><strong>Follow up:</strong> Your algorithm’s time complexity must be better than <code>O(n log n)</code>, where n is the array’s size.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time Complexity: O(n)</span></span><br><span class="line"><span class="comment">     * Space Complexity: O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="comment">//key: number. value: times of number appeared</span></span><br><span class="line">        List&lt;Integer&gt; bucket[] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[nums.length + <span class="number">1</span>];                <span class="comment">// sort map&#x27;s value</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">            count.merge(num, <span class="number">1</span>, Integer::sum); <span class="comment">// calculate times</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> key : count.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> count.get(key);</span><br><span class="line">            <span class="keyword">if</span> (bucket[freq] == <span class="literal">null</span>)</span><br><span class="line">                bucket[freq] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">            bucket[freq].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (bucket[i] != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> val : bucket[i])&#123;</span><br><span class="line">                    res[index++] = val;</span><br><span class="line">                    <span class="keyword">if</span>(index == k)</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure><p>⭕ The syntax of the <code>merge()</code> method is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashmap.merge(key, value, BiFunction remappingFunction)</span><br></pre></td></tr></table></figure><p><strong>Parameters:</strong> This method accepts three parameters:</p><ul><li><strong>Key:</strong> which is the key for which we have a particular value. If two keys have the same value they are merged.</li><li><strong>Value:</strong> which is the index corresponding to the particular key which is stored in the bucket.</li><li><strong>BiFunction:</strong> which is the function having two arguments to be used for calculating the new mapping from the old value and given value.</li></ul><p><strong>Return Value:</strong> This method returns the key along with its value if the key is not present or is associated with null. Else if the key already holds any value, it merges the old value with the new value using the mapping technique.</p><h1 id="Array"><a href="#Array" class="headerlink" title="Array:"></a>Array:</h1><h3 id="704-Binary-Search"><a href="#704-Binary-Search" class="headerlink" title="704. Binary Search"></a><a href="https://leetcode.com/problems/binary-search/">704. Binary Search</a></h3><p>Easy</p><p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 9 exists in nums and its index is 4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int res = -1;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = nums.length - 1;</span><br><span class="line">        backtrack(nums, target, start, end);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums, int target, int start, int end)&#123;</span><br><span class="line">        if(start &lt;= end) &#123;</span><br><span class="line">            int mid = start + (end - start) / 2;;</span><br><span class="line">            if(target &gt; nums[mid])&#123;</span><br><span class="line">                backtrack(nums, target, mid+1, end);</span><br><span class="line">            &#125;else if( target  &lt; nums[mid])&#123;</span><br><span class="line">                backtrack(nums, target, start, mid-1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrong version:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = nums.length - 1;</span><br><span class="line">        backtrack(nums, target, start, end);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums, int target, int start, int end)&#123;</span><br><span class="line">        if(start &gt; end) res = -1;  //!!!!</span><br><span class="line">        int mid = (start + end)/2; //!!!!</span><br><span class="line">        if(target &gt; nums[mid])&#123;</span><br><span class="line">            backtrack(nums, target, mid, end);  //!!!!</span><br><span class="line">        &#125;else if( target  &lt; nums[mid])&#123;</span><br><span class="line">            backtrack(nums, target, start, mid); //!!!!</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leedcode master:</p><p>!!!!!!!!!!!!!!!!! 二分法第1种写法</p><p>我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>左闭右闭区间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span><br><span class="line">        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[mid] == target)</span><br><span class="line">                return mid;</span><br><span class="line">            else if (nums[mid] &lt; target)</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            else if (nums[mid] &gt; target)</span><br><span class="line">                right = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!!!!!!!!!!!!!!!!! 二分法第二种写法</p><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></h3><p>Easy</p><p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>. The order of the elements may be changed. Then return <em>the number of elements in</em> <code>nums</code> <em>which are not equal to</em> <code>val</code>.</p><p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p><ul><li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li><li>Return <code>k</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2,_,_]</span><br><span class="line">Explanation: Your function should return k = 2, with the first two elements of nums being 2.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i =0; i&lt;nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] != val)&#123;</span><br><span class="line">                nums[flag] = nums[i];</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return flag;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="844-Backspace-String-Compare"><a href="#844-Backspace-String-Compare" class="headerlink" title="844. Backspace String Compare"></a><a href="https://leetcode.com/problems/backspace-string-compare/">844. Backspace String Compare</a></h3><p>Easy</p><p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if they are equal when both are typed into empty text editors</em>. <code>&#39;#&#39;</code> means a backspace character.</p><p>Note that after backspacing an empty text, the text will continue empty.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ab#c&quot;, t = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both s and t become &quot;ac&quot;.</span><br></pre></td></tr></table></figure><p>wrong version:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String s, String t) &#123;</span><br><span class="line">        char[] s_ = s.toCharArray();</span><br><span class="line">        char[] t_ = t.toCharArray();</span><br><span class="line">        return backspace(s_).equals(backspace(t_));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String backspace(char[] s)&#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length; i++)&#123;</span><br><span class="line">            if(s[i] != &#x27;#&#x27;)&#123;</span><br><span class="line">                s[flag] = s[i];</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(s, 0, flag); //flag is exclusive</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>correct:</p><ul><li>two pointers:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String s, String t) &#123;</span><br><span class="line">        char[] s_ = s.toCharArray();</span><br><span class="line">        char[] t_ = t.toCharArray(); //!!!!!</span><br><span class="line">        return backspace(s_).equals(backspace(t_)); //!!!!</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String backspace(char[] s)&#123;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.length; i++)&#123;</span><br><span class="line">            if(s[i] != &#x27;#&#x27;)&#123;</span><br><span class="line">                s[flag] = s[i];</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                flag--;   //!!!!!</span><br><span class="line">                if(flag &lt; 0) flag = 0; //!!!!!!!!!!!!!!</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(s, 0, flag); //flag is exclusive !!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>stack:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// string builder</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String s, String t) &#123;</span><br><span class="line">        StringBuilder ssb = new StringBuilder(); // 模拟栈</span><br><span class="line">        StringBuilder tsb = new StringBuilder(); // 模拟栈</span><br><span class="line">        // 分别处理两个 String</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (c != &#x27;#&#x27;) &#123;</span><br><span class="line">                ssb.append(c); // 模拟入栈</span><br><span class="line">            &#125; else if (ssb.length() &gt; 0)&#123; // 栈非空才能弹栈</span><br><span class="line">                ssb.deleteCharAt(ssb.length() - 1); // 模拟弹栈</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (char c : t.toCharArray()) &#123;</span><br><span class="line">            if (c != &#x27;#&#x27;) &#123;</span><br><span class="line">                tsb.append(c); // 模拟入栈</span><br><span class="line">            &#125; else if (tsb.length() &gt; 0)&#123; // 栈非空才能弹栈</span><br><span class="line">                tsb.deleteCharAt(tsb.length() - 1); // 模拟弹栈</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ssb.toString().equals(tsb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// stack</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String s, String t) &#123;</span><br><span class="line">        return buildStack(s).equals(buildStack(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Stack&lt;Character&gt; buildStack(String str) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (char c : str.toCharArray()) &#123;</span><br><span class="line">            if (c != &#x27;#&#x27;) &#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125; else if (!stack.isEmpty()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a><a href="https://leetcode.com/problems/squares-of-a-sorted-array/">977. Squares of a Sorted Array</a></h3><p>Easy</p><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing</strong> order, return <em>an array of <strong>the squares of each number</strong> sorted in non-decreasing order</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br><span class="line">Explanation: After squaring, the array becomes [16,1,0,9,100].</span><br><span class="line">After sorting, it becomes [0,1,9,16,100].</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">easy way:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">two pointers:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        int index = nums.length - 1;</span><br><span class="line">        int[] result = new int[nums.length];</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            if(nums[left] * nums[left] &lt; nums[right] * nums[right])&#123;</span><br><span class="line">                result[index] = nums[right] * nums[right];</span><br><span class="line">                index--;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result[index] = nums[left] * nums[left];</span><br><span class="line">                index--;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.md#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95">双指针法</a></h3><p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p><p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p><p>此时可以考虑双指针法了，i指向起始位置，j指向终止位置。</p><p>定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。</p><p>如果<code>A[i] * A[i] &lt; A[j] * A[j]</code> 那么<code>result[k--] = A[j] * A[j];</code> 。</p><p>如果<code>A[i] * A[i] &gt;= A[j] * A[j]</code> 那么<code>result[k--] = A[i] * A[i];</code> 。</p></li></ul><h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a><a href="https://leetcode.com/problems/minimum-size-subarray-sum/">209. Minimum Size Subarray Sum</a></h3><ul><li>sliding window</li></ul><p>Medium</p><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a</em> </p><p><em>subarray</em></p><p> <em>whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line">        for(int right = 0; right &lt; nums.length; right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            if(sum &gt;= target)&#123;</span><br><span class="line">                while(sum &gt;= target)&#123;</span><br><span class="line">                    res = Math.min(res, right - left + 1);</span><br><span class="line">                    sum -= nums[left];</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(res == Integer.MAX_VALUE) return 0;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>okay, so for sliding window, you move the right border first, once the sum is bigger than the target, then you move the left border until the sum is sum is smaller than the target. once the sum is smaller, then once again move the right border.</p><h3 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a><a href="https://leetcode.com/problems/spiral-matrix-ii/">59. Spiral Matrix II</a></h3><p>Medium</p><p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.md</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int[][] res = new int[n][n];</span><br><span class="line">        int i = 0,j = 0; // i is column, j is row;</span><br><span class="line">        int loop = 1; //!!!! not 0</span><br><span class="line">        int count = 1;</span><br><span class="line">        while(loop &lt;= n/2)&#123;</span><br><span class="line">        //every loop starts from [loop-1][loop-1]</span><br><span class="line">            for(j = loop - 1; j &lt; n - loop; j++ )&#123; </span><br><span class="line">            // j = loop - 1 not loop</span><br><span class="line">                res[loop - 1][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            for( i = loop - 1 ; i &lt; n - loop; i++)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(; j &gt;= loop; j--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(; i &gt;= loop; i--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n % 2 == 1) &#123;</span><br><span class="line">            res[loop - 1][loop - 1] = count; //!!!!!</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GreedyAlgorithm</title>
      <link href="/2023/02/13/LeetCode/GreedyAlgorithm/"/>
      <url>/2023/02/13/LeetCode/GreedyAlgorithm/</url>
      
        <content type="html"><![CDATA[<h2 id="Lamda-expression"><a href="#Lamda-expression" class="headerlink" title="Lamda expression"></a>Lamda expression</h2><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908102703169.png" alt="image-20230908102703169"></p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908095717662.png" alt="image-20230908095717662"></p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908103000971.png" alt="image-20230908103000971"></p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908103033599.png" alt="image-20230908103033599"></p><p>also in lambada.java</p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908103156544.png" alt="image-20230908103156544"></p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908103219413.png" alt="image-20230908103219413"></p><p>lambda:</p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908103649766.png" alt="image-20230908103649766"></p><p>simplify:</p><p><img src="C:\Users\XIANGDANTONG\AppData\Roaming\Typora\typora-user-images\image-20230908104049965.png" alt="image-20230908104049965"></p><p>lambda make method into implementations into objects like any other than can be saved into variables and passed into methods as parameters.</p><h1 id="Greedy-Algorithm-🌼"><a href="#Greedy-Algorithm-🌼" class="headerlink" title="Greedy Algorithm 🌼"></a>Greedy Algorithm 🌼</h1><h3 id="455-Assign-Cookies"><a href="#455-Assign-Cookies" class="headerlink" title="455. Assign Cookies"></a><a href="https://leetcode.com/problems/assign-cookies/">455. Assign Cookies</a></h3><p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p><p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: g = [1,2,3], s = [1,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. </span><br><span class="line">And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.</span><br><span class="line">You need to output 1.</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/c35c8b7eafc656d702a2d7258fc4725879e6715db4871295f86a68bc6eb3522b/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303233303430353232353632382e706e67" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i &lt; s.length &amp;&amp; j &lt; g.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[j] &lt;= s[i])&#123;</span><br><span class="line">                count ++;</span><br><span class="line">                j++; <span class="comment">//注意这是j++不是i++</span></span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a><a href="https://leetcode.com/problems/wiggle-subsequence/">376. Wiggle Subsequence</a></h3><p>A <strong>wiggle sequence</strong> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p><ul><li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <strong>wiggle sequence</strong> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li><li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li></ul><p>A <strong>subsequence</strong> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>wiggle subsequence</strong> of</em> <code>nums</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,7,4,9,2,5]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).</span><br></pre></td></tr></table></figure><p><img src="https://camo.githubusercontent.com/507a5af510d35d31fe3ff9c13d8355f4de4e42283be3acd3913d429b7e2ad29a/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343137343332373539372e706e67" alt="376.摆动序列"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// my version: still has bugs:   28 / 31 testcases passed</span><br><span class="line">这个方法平坡的时候会遇上问题</span><br><span class="line">而且像这种每次循坏比较，比较了数组里面的三个元素，这样不方便情况分类</span><br><span class="line">代码随想录中，每次只用i表示出来来个元素，这样的代码写出来更加清晰</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        int count = 1;</span><br><span class="line">        int start = 0;</span><br><span class="line">        //找峰值</span><br><span class="line">        for(int i = 1 ; i &lt; nums.length - 1 ; i++)&#123;</span><br><span class="line">            if(nums[ i - 1] &lt;= nums[i] &amp;&amp; nums[i+1] &lt; nums[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找峰谷</span><br><span class="line">        for(int i = 1 ; i &lt; nums.length - 1 ; i++)&#123;</span><br><span class="line">            if(nums[ i - 1] &gt;= nums[i] &amp;&amp; nums[i+1] &gt; nums[i])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">//排查头和尾巴的情况</span><br><span class="line">        if(nums.length &gt; 1 &amp;&amp; nums[nums.length-2]!= nums[nums.length-1] &amp;&amp;nums[0]!= nums[1])&#123;</span><br><span class="line">            count = count + 1;</span><br><span class="line">        &#125; </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// leetcodemaster:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        int count = 1; //默认最右边就是一个摆动</span><br><span class="line">        int curDif = 0;</span><br><span class="line">        int preDif = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 1 ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            curDif = nums[i] - nums[i-1];</span><br><span class="line">            //等于0的情况表示初始时的preDiff</span><br><span class="line">            if((curDif &gt;0 &amp;&amp; preDif &lt;=0) ||(curDif &lt;0 &amp;&amp; preDif &gt;=0))&#123;  </span><br><span class="line">            //这里不是curDif &gt;= 0 curDif &lt;= 0 是为了考虑第一个元素</span><br><span class="line">                count++;</span><br><span class="line">                preDif = curDif; // preDif 不能和curDif一直实时变换  -&gt; 1 2 2 2 3 </span><br><span class="line">            &#125;</span><br><span class="line">            //preDif = curDif; cannot put it here </span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="1005. Maximize Sum Of Array After K Negations"></a><a href="https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/">1005. Maximize Sum Of Array After K Negations</a></h3><p>Given an integer array <code>nums</code> and an integer <code>k</code>, modify the array in the following way:</p><ul><li>choose an index <code>i</code> and replace <code>nums[i]</code> with <code>-nums[i]</code>.</li></ul><p>You should apply this process exactly <code>k</code> times. You may choose the same index <code>i</code> multiple times.</p><p>Return <em>the largest possible sum of the array after modifying it in this way</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,2,3], k = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Choose index 1 and nums becomes [4,-2,3].</span><br></pre></td></tr></table></figure><p>my:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int k) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int  count = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int min = 100000;</span><br><span class="line">        for(int i = 0 ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            if( nums[i] &lt; 0)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(Math.abs(nums[i])&lt; min )&#123;</span><br><span class="line">                min = Math.abs(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( k &lt; count)&#123;</span><br><span class="line">            for(int i = 0 ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">                if(k &gt; 0)&#123;</span><br><span class="line">                    res -= nums[i];</span><br><span class="line">                    k -- ;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">             for(int i = 0 ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">                res += Math.abs(nums[i]);</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">             if( (k-count)%2 == 0)&#123;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return res - 2*min;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>optimize：</p><p>for(int i &#x3D; 0 ; i &lt; nums.length ; i++){</p><p>​      if( k &gt; 0 &amp;&amp; nums[i] &lt; 0){</p><p>​        res +&#x3D; Math.abs(nums[i]);</p><p>​        k –;  </p><p>​      }else{</p><p>​        res +&#x3D; nums[i];</p><p>​      }</p><p>​    }</p><p>​    if(k &gt; 0){</p><p>​      if( k % 2 &#x3D;&#x3D; 1)</p><p>​        res &#x3D; res - 2 * min;</p><p>​      if( k % 2 &#x3D;&#x3D; 0)</p><p>​        res&#x3D; res;</p><p>​    }</p><p>leetcode-master:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int K) &#123;</span><br><span class="line">    // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小</span><br><span class="line">nums = IntStream.of(nums)</span><br><span class="line">     .boxed()</span><br><span class="line">     .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))</span><br><span class="line">     .mapToInt(Integer::intValue).toArray();</span><br><span class="line">int len = nums.length;    </span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    //从前向后遍历，遇到负数将其变为正数，同时K--</span><br><span class="line">    if (nums[i] &lt; 0 &amp;&amp; K &gt; 0) &#123;</span><br><span class="line">    nums[i] = -nums[i];</span><br><span class="line">    K--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 如果K还大于0，那么反复转变数值最小的元素，将K用完</span><br><span class="line"></span><br><span class="line">if (K % 2 == 1) nums[len - 1] = -nums[len - 1];</span><br><span class="line">return Arrays.stream(nums).sum();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.md</a></p><h3 id="860-Lemonade-Change"><a href="#860-Lemonade-Change" class="headerlink" title="860. Lemonade Change"></a><a href="https://leetcode.com/problems/lemonade-change/">860. Lemonade Change</a></h3><p>Easy</p><p>At a lemonade stand, each lemonade costs <code>$5</code>. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a <code>$5</code>, <code>$10</code>, or <code>$20</code> bill. You must provide the correct change to each customer so that the net transaction is that the customer pays <code>$5</code>.</p><p>Note that you do not have any change in hand at first.</p><p>Given an integer array <code>bills</code> where <code>bills[i]</code> is the bill the <code>ith</code> customer pays, return <code>true</code> <em>if you can provide every customer with the correct change, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: bills = [5,5,5,10,20]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">From the first 3 customers, we collect three $5 bills in order.</span><br><span class="line">From the fourth customer, we collect a $10 bill and give back a $5.</span><br><span class="line">From the fifth customer, we give a $10 bill and a $5 bill.</span><br><span class="line">Since all customers got correct change, we output true.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean lemonadeChange(int[] bills) &#123;</span><br><span class="line">        int five = 0;</span><br><span class="line">        int ten = 0;</span><br><span class="line">        for(int i = 0; i &lt; bills.length; i++)&#123;</span><br><span class="line">            if (bills[i] == 5)&#123;</span><br><span class="line">                five ++;</span><br><span class="line">            &#125;else if(bills[i] == 10)&#123;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line"></span><br><span class="line">            &#125;else if(bills[i]==20 )&#123;  // important</span><br><span class="line">                if(ten &gt; 0)&#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    five -= 3;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(five &lt; 0 || ten &lt; 0)&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II</a></h3><p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p><p>On each day, you may decide to buy and&#x2F;or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p><p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Total profit is 4 + 3 = 7.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">prof</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(prices[i] &lt; prices[i+<span class="number">1</span>])&#123;</span><br><span class="line">        prof += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prof;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. Best Time to Buy and Sell Stock with Transaction Fee</a></h3><p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>fee</code> representing a transaction fee.</p><p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p><p><strong>Note:</strong></p><ul><li>You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</li><li>The transaction fee is only charged once for each stock purchase and sale.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [1,3,2,8,4,9], fee = 2</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The maximum profit can be achieved by:</span><br><span class="line">- Buying at prices[0] = 1</span><br><span class="line">- Selling at prices[3] = 8</span><br><span class="line">- Buying at prices[4] = 4</span><br><span class="line">- Selling at prices[5] = 9</span><br><span class="line">The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure><h3 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a><a href="https://leetcode.com/problems/gas-station/">134. Gas Station</a></h3><p>Medium</p><p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">暴力解法：//not sure it&#x27;s right and also exceeded tgt time limit</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int[] val = new int[gas.length];</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; gas.length; i++)&#123;</span><br><span class="line">            val[i] = gas[i] - cost[i];</span><br><span class="line">            sum += val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; 0) return -1;</span><br><span class="line">        for(int i = 0; i &lt; val.length; i++)&#123;</span><br><span class="line">            sum = 0;</span><br><span class="line">            int time = val.length;</span><br><span class="line">            int j = i;</span><br><span class="line">            while(time &gt; 0)&#123;</span><br><span class="line">                if(j == val.length) j =0;</span><br><span class="line">                sum += val[j];</span><br><span class="line">                if(sum &lt; 0) break;</span><br><span class="line">                j++;</span><br><span class="line">                time--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (time == 0) return i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greedy algorithm:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int totalsum = 0;</span><br><span class="line">        int cursum = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; gas.length; i++)&#123;</span><br><span class="line">            totalsum += gas[i] - cost[i];</span><br><span class="line">            cursum += gas[i] - cost[i];</span><br><span class="line">            if(cursum &lt; 0) &#123;</span><br><span class="line">                res = i + 1;</span><br><span class="line">                if(res == gas.length) res = 0;</span><br><span class="line">                cursum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(totalsum &lt; 0) return -1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>那么局部最优：当前累加rest[i]的和curSum !!!一旦!!! 小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><h3 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a><a href="https://leetcode.com/problems/candy/">135. Candy</a></h3><p>Hard</p><p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p><p>You are giving candies to these children subjected to the following requirements:</p><ul><li>Each child must have at least one candy.</li><li>Children with a higher rating get more candies than their neighbors.</li></ul><p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: ratings = [1,0,2]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        int[] candy = new int[ratings.length];</span><br><span class="line">        candy[0] = 1;</span><br><span class="line">        for(int i = 1; i &lt; ratings.length; i++)&#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i-1]) </span><br><span class="line">            &#123;</span><br><span class="line">                candy[i] = candy[i-1] + 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                candy[i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = ratings.length - 2; i &gt;= 0; i--)&#123;</span><br><span class="line">            if(ratings[i] &gt; ratings[i+1]) candy[i] = Math.max(candy[i+1] + 1, candy[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i = 0; i &lt; ratings.length; i++)&#123;</span><br><span class="line">            res += candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前向后遍历，再从后向前遍历，取最大值这样就两个方向都可以满足条件。</p><p>不要遍历一次同时比较左右两边，这样做会非常复杂。</p><p><a href="https://camo.githubusercontent.com/81ef61389a5c134af2ac44dd5a1cb03926b6f733f4eac47db2e73f0784e647e4/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303233303230323130323034342e706e67"><img src="https://camo.githubusercontent.com/81ef61389a5c134af2ac44dd5a1cb03926b6f733f4eac47db2e73f0784e647e4/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303233303230323130323034342e706e67" alt="img"></a></p><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>那么又要贪心了，局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><p>如图：</p><p><a href="https://camo.githubusercontent.com/883e765e3ed4a40f730f17837d7124decff29c4da2ec78353f05a5a480a90283/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313131373131353635383739312e706e67"><img src="https://camo.githubusercontent.com/883e765e3ed4a40f730f17837d7124decff29c4da2ec78353f05a5a480a90283/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313131373131353635383739312e706e67" alt="135.分发糖果1"></a></p><h3 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h3><p>Medium</p><p>You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [hi, ki]</code> represents the <code>ith</code> person of height <code>hi</code> with <strong>exactly</strong> <code>ki</code> other people in front who have a height greater than or equal to <code>hi</code>.</p><p>Reconstruct and return <em>the queue that is represented by the input array</em> <code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [hj, kj]</code> is the attributes of the <code>jth</code> person in the queue (<code>queue[0]</code> is the person at the front of the queue).</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">Explanation:</span><br><span class="line">Person 0 has height 5 with no other people taller or the same height in front.</span><br><span class="line">Person 1 has height 7 with no other people taller or the same height in front.</span><br><span class="line">Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.</span><br><span class="line">Person 3 has height 6 with one person taller or the same height in front, which is person 1.</span><br><span class="line">Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.</span><br><span class="line">Person 5 has height 7 with one person taller or the same height in front, which is person 1.</span><br><span class="line">Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, (a,b) -&gt; &#123;</span><br><span class="line">            if(a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列</span><br><span class="line">            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for(int[] p : people)&#123;</span><br><span class="line">            que.add(p[1], p);//Linkedlist.add(index, value)，會將value插入到指定index裡。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return que.toArray(new int[people.length][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, (a,b) -&gt; &#123;</span><br><span class="line">            if(a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            return b[0] - a[0]; </span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i = 0; i &lt; people.length; i++)&#123;</span><br><span class="line">            que.add(people[i][1], people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return (que.toArray(new int[people.length][people[0].length]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure><ol><li><code>(a, b) -&gt; &#123;...&#125;</code>: This is a lambda expression defining the custom comparator for sorting the <code>people</code> array.</li><li>Inside the lambda expression:<ul><li><code>if (a[0] == b[0]) return a[1] - b[1];</code>: This condition checks if two people have the same height (<code>a[0] == b[0]</code>). If they have the same height, it compares their <code>k</code> values (<code>a[1]</code> and <code>b[1]</code>) in ascending order. This means that people with the same height will be sorted in ascending order of their <code>k</code> values.</li><li><code>return b[0] - a[0];</code>: If two people have different heights (<code>a[0] != b[0]</code>), it compares their heights in descending order. This means that people with different heights will be sorted in descending order of their heights.</li></ul></li></ol><p>When you subtract <code>b[1]</code> from <code>a[1]</code>, you are calculating the difference between the <code>k</code> values of two people, <code>a</code> and <code>b</code>. If the result is positive, it means that <code>a[1]</code> is greater than <code>b[1]</code>, indicating that <code>a</code> should come after <code>b</code> in ascending order. Conversely, if the result is negative, it means that <code>a[1]</code> is less than <code>b[1]</code>, indicating that <code>a</code> should come before <code>b</code> in ascending order.</p><p>So, <code>return a[1] - b[1]</code> sorts the array in ascending order of the <code>k</code> values. People with smaller <code>k</code> values (fewer people taller or as tall as them in front) will appear earlier in the sorted array, and people with larger <code>k</code> values (more people taller or as tall as them in front) will appear later in the sorted array. I apologize for any confusion in my previous responses, and thank you for pointing out the error.</p><ol><li>When you add elements with the same <code>p[1]</code> value to the <code>LinkedList</code>, the order in which they were added will be maintained. The first element with a particular <code>p[1]</code> value added to the queue will be positioned first among elements with the same <code>p[1]</code> value.</li><li>Elements with different <code>p[1]</code> values (different values of <code>k</code>) will not be affected by this and will still be ordered based on the comparison logic provided in the <code>Arrays.sort</code> step.</li></ol><p>So, if multiple people have the same number of people in front of them (<code>p[1]</code> values are the same), their relative order in the output will be determined by their original order in the input array, with the first one encountered being positioned first in the output.</p><h2 id="Arrays-sort-—-gt-comparator"><a href="#Arrays-sort-—-gt-comparator" class="headerlink" title="Arrays.sort          —-&gt;     comparator"></a>Arrays.sort          —-&gt;     comparator</h2><p><a href="https://www.geeksforgeeks.org/sort-an-array-in-java-using-comparator/">https://www.geeksforgeeks.org/sort-an-array-in-java-using-comparator/</a></p><p>No, the second parameter in <code>Arrays.sort</code> should not be of type <code>int</code>. The second parameter in <code>Arrays.sort</code> is a <code>Comparator</code> object or a lambda expression that defines the custom sorting logic for the elements in the array. It does not have to be of type <code>int</code>, but rather, it should be a function that returns an <code>int</code> to indicate the ordering relationship between two elements.</p><p>The compare() method in the Comparator is responsible for comparing two elements and returning an integer value that indicates their relative order. It follows the following convention:</p><ul><li><p>If compare(o1, o2) returns a negative value, o1 should come before o2 in the sorted order.</p></li><li><p>If compare(o1, o2) returns zero, o1 and o2 are considered equal in terms of sorting order.</p></li><li><p>If compare(o1, o2) returns a positive value, o1 should come after o2 in the sorted order.</p></li></ul><ol><li>Sorting Examples:<ul><li>You can use <code>Comparator</code> to sort arrays of custom objects based on specific attributes or fields within those objects.</li><li>You can also use it to perform case-insensitive or reverse sorting.</li></ul></li></ol><p>Here’s an example of using <code>Arrays.sort()</code> with a custom <code>Comparator</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] fruits = &#123;&quot;apple&quot;, &quot;Banana&quot;, &quot;cherry&quot;, &quot;date&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        // Sorting the array using a custom Comparator for case-insensitive sorting</span><br><span class="line">        Arrays.sort(fruits, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String o1, String o2) &#123;</span><br><span class="line">                return o1.compareToIgnoreCase(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // Printing the sorted array</span><br><span class="line">        System.out.println(Arrays.toString(fruits));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloons</a></h3><p>Medium</p><p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [xstart, xend]</code> denotes a balloon whose <strong>horizontal diameter</strong> stretches between <code>xstart</code> and <code>xend</code>. You do not know the exact y-coordinates of the balloons.</p><p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>xstart</code> and <code>xend</code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>xstart &lt;= x &lt;= xend</code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p><p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The balloons can be burst by 2 arrows:</span><br><span class="line">- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].</span><br><span class="line">- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">wrong version:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinArrowShots(int[][] points) &#123;</span><br><span class="line">        Arrays.sort(points, (a,b) -&gt; &#123;</span><br><span class="line">            return a[0] - b[0]; // here will be some overflow!</span><br><span class="line">        &#125;);</span><br><span class="line">        int time = 1;</span><br><span class="line">        for(int i = 1; i &lt; points.length; i++)&#123;</span><br><span class="line">            if(points[i - 1][1] &lt; points[i][0])&#123;</span><br><span class="line">                time++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                points[i][1] = Math.min(points[i][1], points[i-1][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return time;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">here&#x27;s right version:</span><br><span class="line">// 使用Integer内置比较方法，不会溢出</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));</span><br></pre></td></tr></table></figure><p>The <code>Integer.compare</code> method returns a negative value if <code>a[0]</code> is less than <code>b[0]</code>, zero if they are equal, and a positive value if <code>a[0]</code> is greater than <code>b[0]</code></p><h3 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a><a href="https://leetcode.com/problems/non-overlapping-intervals/">435. Non-overlapping Intervals</a></h3><p>Medium</p><p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,2],[2,3],[3,4],[1,3]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        Arrays.sort(intervals, (a,b) -&gt; &#123;</span><br><span class="line">            if(a[0] == b[0])&#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125;</span><br><span class="line">            return a[0] - b[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i = 1; i &lt; intervals.length; i++ )&#123;</span><br><span class="line">           if (intervals[i][0] &lt; intervals[i-1][1])&#123;</span><br><span class="line">               count++;</span><br><span class="line">               intervals[i][1] = Math.min(intervals[i][1], intervals[i-1][1]);  //!!!!!!!!!</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a><a href="https://leetcode.com/problems/partition-labels/">763. Partition Labels</a></h3><p>Medium</p><p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p><p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p><p>Return <em>a list of integers representing the size of these parts</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; partitionLabels(String s) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        int[] edge = new int[26];</span><br><span class="line">        for(int i = 0; i &lt; chars.length; i++)&#123;</span><br><span class="line">            edge[chars[i] - &#x27;a&#x27;] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        int count = 0;</span><br><span class="line">        int temp = -1; //mark the edge</span><br><span class="line">        for(int i = 0; i &lt; chars.length; i++)&#123;</span><br><span class="line">            temp = Math.max(temp, edge[chars[i] - &#x27;a&#x27;]);</span><br><span class="line">            count++;</span><br><span class="line">            if(i == temp)&#123;</span><br><span class="line">                res.add(count);</span><br><span class="line">                count = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><a href="https://camo.githubusercontent.com/5a55501facb21dbc3c468df2c66fb432cd4f613d282d5c4c2feb67246c938b95/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313232323139313932343431372e706e67"><img src="https://camo.githubusercontent.com/5a55501facb21dbc3c468df2c66fb432cd4f613d282d5c4c2feb67246c938b95/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313232323139313932343431372e706e67" alt="763.划分字母区间"></a></p><h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/">56. Merge Intervals</a></h3><p>Medium</p><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">        LinkedList&lt;int[]&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, (a,b)-&gt;&#123;</span><br><span class="line">            if(a[0] == b[0]) return a[1] - b[1];</span><br><span class="line">            return a[0] - b[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        int left = intervals[0][0];</span><br><span class="line">        int right = intervals[0][1];</span><br><span class="line">        for(int i = 1; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            if(right &lt; intervals[i][0])&#123;</span><br><span class="line">                //right = intervals[i-1][1]; !!! dont need it here</span><br><span class="line">                res.add(new int[]&#123;left,right&#125;);</span><br><span class="line">                left = intervals[i][0];</span><br><span class="line">                right = intervals[i][1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                right = Math.max(right,intervals[i][1]);</span><br><span class="line">                //!!!</span><br><span class="line">                // wrong: right = Math.max(intervals[i][1],intervals[i-1][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(new int[]&#123;left, right&#125;); //!!!important, dont forget to add the last round</span><br><span class="line">        return res.toArray(new int[res.size()][2]); //!!! syntax</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TwoPointer</title>
      <link href="/2023/02/13/LeetCode/TwoPointer/"/>
      <url>/2023/02/13/LeetCode/TwoPointer/</url>
      
        <content type="html"><![CDATA[<h1 id="TwoPointer-🌼"><a href="#TwoPointer-🌼" class="headerlink" title="TwoPointer 🌼"></a>TwoPointer 🌼</h1><p>双指针法将时间复杂度：O(n^2)的解法优化为 O(n)的解法。也就是降一个数量级，题目如下：</p><ul><li><a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">27.移除元素(opens new window)</a></li><li><a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">15.三数之和(opens new window)</a></li><li><a href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">18.四数之和(opens new window)</a></li></ul><p>链表相关双指针题目：</p><ul><li><a href="https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html">206.反转链表(opens new window)</a></li><li><a href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">19.删除链表的倒数第N个节点(opens new window)</a></li><li><a href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">面试题 02.07. 链表相交(opens new window)</a></li><li><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">142题.环形链表II</a></li></ul><h2 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></h2><p>Easy</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">Output: 5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.</span><br><span class="line">Note that the five elements can be returned in any order.</span><br><span class="line">It does not matter what you leave beyond the returned k (hence they are underscores).</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[flag] = nums[i];</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344. Reverse String"></a>344. Reverse String</h2><p>Easy</p><p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p>You must do this by modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> with <code>O(1)</code> extra memory. </p><p><strong>Example :</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="type">char</span> temp;</span><br><span class="line">            temp = s[i];</span><br><span class="line">            s[i] = s[tail];</span><br><span class="line">            s[tail] = temp;</span><br><span class="line">            tail --;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125.Valid Palindrome"></a>125.Valid Palindrome</h2><p>Easy</p><p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p><p>Given a string <code>s</code>, return <code>true</code> <em>if it is a <strong>palindrome</strong>, or</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Example :</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;amanaplanacanalpanama&quot; is a palindrome.</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> start ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(start = <span class="number">0</span>; start &lt;= end; )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit( s.charAt(start) ))&#123;</span><br><span class="line">                start ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit( s.charAt(end) ))&#123;</span><br><span class="line">                end --;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( Character.toLowerCase( s.charAt(start)) !=  Character.toLowerCase(s.charAt(end)) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                start ++;</span><br><span class="line">                end --;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭕ Character.isLetterOrDigit( char )</p><p>⭕ Character.toLowerCase( char )</p><p>⭕ String s -&gt; s.length();</p><p>​  char[] s -&gt; s.length;</p><p>⭕ char: &#x3D;&#x3D;</p><p>​String: equals();</p><h2 id="167-Two-Sum-II-Input-Array-Is-Sorted"><a href="#167-Two-Sum-II-Input-Array-Is-Sorted" class="headerlink" title="167. Two Sum II - Input Array Is Sorted"></a>167. Two Sum II - Input Array Is Sorted</h2><p>Medium</p><p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already *<strong>sorted in non-decreasing order*</strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code> where <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.</p><p>Return <em>the indices of the two numbers,</em> <code>index1</code> <em>and</em> <code>index2</code><em>, <strong>added by one</strong> as an integer array</em> <code>[index1, index2]</code> <em>of length 2.</em></p><p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p><p>Your solution must use only constant extra space.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; numbers.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>  <span class="variable">j</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>; j &gt; i; j --)&#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] + numbers[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span>( numbers[i] + numbers[j] &lt; target) </span><br><span class="line">               <span class="comment">// without this if sentence then the time complexity cannot pass the test</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭕The <code>break</code> statement can be used to <strong>jump out of a loop.</strong></p><p>​     The <code>continue</code> statement <strong>breaks one iteration (in the loop)</strong>, if a specified condition occurs, and continues with the next iteration in the loop.</p><h2 id="2109-Adding-Spaces-to-a-String"><a href="#2109-Adding-Spaces-to-a-String" class="headerlink" title="2109. Adding Spaces to a String"></a>2109. Adding Spaces to a String</h2><p>Medium</p><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;icodeinpython&quot;, spaces = [1,5,7,9]</span><br><span class="line">Output: &quot;i code in py thon&quot;</span><br><span class="line">Explanation:</span><br><span class="line">The indices 1, 5, 7, and 9 correspond to the underlined characters in &quot;icodeinpython&quot;.</span><br><span class="line">We then place spaces before those characters.</span><br></pre></td></tr></table></figure><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addSpaces</span><span class="params">(String s, <span class="type">int</span>[] spaces)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( j &lt; spaces.length &amp;&amp; i == spaces[j] )&#123;</span><br><span class="line">                ans.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                j++;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addSpaces</span><span class="params">(String s, <span class="type">int</span>[] spaces)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[spaces.length + s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j =<span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; spaces.length &amp;&amp; spaces[j] + j == i) &#123; <span class="comment">//!!! notice you need to  + j here</span></span><br><span class="line">                res[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = ss[flag];</span><br><span class="line">                flag ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⭕ Here we should use StringBuilder not ArrayList</p><p>⭕ Time Limit Exceeded:</p><p>if里面 i–； 最后又i++ ; i一直是一个值不变就反复跑for loop. when j &gt; space, j would not change and i will go into an dead loop.</p><p>but for the method below, i decreases at the same time when j increase so it won’t cause infinite loop.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">wrong:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addSpaces</span><span class="params">(String s, <span class="type">int</span>[] spaces)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i == spaces[j] )&#123;</span><br><span class="line">                ans.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; spaces.length - <span class="number">1</span>)</span><br><span class="line">                    j++;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a><a href="https://leetcode.com/problems/reverse-words-in-a-string/">151. Reverse Words in a String</a></h2><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;the sky is blue&quot;</span><br><span class="line">Output: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p>Input：”the sky is blue “</p><ol><li><p>remove extra: “the sky is blue”</p></li><li><p>reverse the whole input：”eulb si yks eht”</p></li><li><p>reverse every single word：”blue is sky the”</p></li></ol><p><strong>🌟Coding:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//remove extra space</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">removeSpace</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// remove all space in the front and back of the array</span></span><br><span class="line">        <span class="keyword">while</span>(s.charAt(start) ==(<span class="string">&#x27; &#x27;</span>)) start++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(end) ==(<span class="string">&#x27; &#x27;</span>)) end--;</span><br><span class="line">        <span class="comment">//remove extra space in the middle of the array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start ; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// reverse from start to end</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;  <span class="comment">//notice here could be void</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( start &lt; end)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(end);</span><br><span class="line">            sb.setCharAt(end , sb.charAt(start));</span><br><span class="line">            sb.setCharAt(start, temp);</span><br><span class="line">            start ++;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span>  removeSpace(s);     </span><br><span class="line">        reverse(temp, <span class="number">0</span> , temp.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// reverse each single word</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; temp.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(temp, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="keyword">return</span> temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//MY FIRST TRY WHICH IS WRONG</span></span><br><span class="line">    <span class="comment">// reverse each single word</span></span><br><span class="line"><span class="comment">//        int start = 0;</span></span><br><span class="line"><span class="comment">//        int end = 0;</span></span><br><span class="line"><span class="comment">//        for( int i = 0 ; i &lt; temp.length(); i ++)&#123;</span></span><br><span class="line"><span class="comment">//            if(temp.charAt(i)!= &#x27; &#x27; )&#123;</span></span><br><span class="line"><span class="comment">//                end = i; // end equals to the last charater which is right before the space</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if(temp.charAt(i) == &#x27; &#x27; )&#123;   </span></span><br><span class="line">     <span class="comment">//这里错了 可以改成if (temp.charAt(i) == &#x27; &#x27; || i == temp.length() - 1) </span></span><br><span class="line"><span class="comment">//                reverse(temp, start, end);</span></span><br><span class="line"><span class="comment">//                start = i + 1; //start move to one after the end</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// second try:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span>&#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> reverse(s, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ss.length(); i++)&#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span>(ss.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span>(i &lt; ss.length() &amp;&amp; ss.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">            i --;</span><br><span class="line">           ss = reverse(ss, start, Math.min(i, s.length()-<span class="number">1</span>));</span><br><span class="line">               </span><br><span class="line">        <span class="comment">//or  while(i+1 &lt; ss.length() &amp;&amp; ss.charAt(i+1) != &#x27; &#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//        i++;</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//    ss = reverse(ss, start, Math.min(i, s.length()-1));</span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> removeSpace(ss);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeSpace</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ss = s.trim().toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ss.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[i] != <span class="string">&#x27; &#x27;</span>) sb.append(ss[i]);</span><br><span class="line">            <span class="keyword">if</span>(ss[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; ss[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ss[start];</span><br><span class="line">            ss[start] = ss[end];</span><br><span class="line">            ss[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a><a href="https://leetcode.com/problems/4sum/">18. 4Sum</a></h3><p>Medium</p><p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) return res;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i -1]) continue;</span><br><span class="line">            for(int j = i+1; j &lt; nums.length; j++)&#123;</span><br><span class="line">                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j -1]) continue;</span><br><span class="line">                int left =  j + 1;</span><br><span class="line">                int right = nums.length -1;</span><br><span class="line">                while(right &gt;left)&#123;</span><br><span class="line">                    int sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if(sum &gt; target)&#123;</span><br><span class="line">                        right --;</span><br><span class="line">                    &#125;else if(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                    //注意这里的去重 !!!!</span><br><span class="line">                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));   !!!!!!!!!</span><br><span class="line">                        while(right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right --;  // 注意这个条件right &gt; left</span><br><span class="line">                        while(right &gt; left &amp;&amp; nums[left] == nums[left +  1]) left ++;</span><br><span class="line">                        right --;</span><br><span class="line">                        left ++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Time Limit Exceeded</span><br><span class="line">    //     Arrays.sort(nums); // Sort the array to help in avoiding duplicates</span><br><span class="line">    //     seek(nums, target, 0);</span><br><span class="line">    //     return res;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // public void seek(int[] nums, int target, int index) &#123;</span><br><span class="line">    //     if (temp.size() == 4) &#123;</span><br><span class="line">    //         int sum = 0;</span><br><span class="line">    //         for (int num : temp) &#123;</span><br><span class="line">    //             sum += num;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //         if (sum == target) &#123;</span><br><span class="line">    //             res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">    //         &#125;</span><br><span class="line">    //         return;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     for (int i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">    //         if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">    //             continue; // Skip duplicates</span><br><span class="line">    //         &#125;</span><br><span class="line">    //         temp.add(nums[i]);</span><br><span class="line">    //         seek(nums, target, i + 1);</span><br><span class="line">    //         temp.removeLast();</span><br><span class="line">    //     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Arrays.asList</p><p>！！！！  convert an array or a set of elements into a <code>List</code> implementation. </p><h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a><a href="https://leetcode.com/problems/3sum/">15. 3Sum</a></h3><p>Medium</p><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] &gt; 0) return res;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            //注意这里最开始我没有写这个while语句</span><br><span class="line">            while(left &lt; right)</span><br><span class="line">           &#123; </span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if(sum &gt; 0)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else if(sum &lt; 0)&#123;</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    // 注意这里的while我最开始写成了if</span><br><span class="line">                    while(right&gt;left &amp;&amp; nums[left] == nums[left+1]) left ++;</span><br><span class="line">                    while(right&gt;left &amp;&amp; nums[right] == nums[right-1]) right --;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[toc]</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>💐Welcome💐</title>
      <link href="/2023/02/12/Welcome/"/>
      <url>/2023/02/12/Welcome/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my corner of the internet🎇! This is where I share my battles and victories against Leetcode and other coding challenges. Think of it as a training diary for a superhero, but instead of saving the world, I’m saving lines of code. So buckle up, it’s going to be a wild ride❤️‍🔥!</p><p><img src="https://miro.medium.com/max/1400/0*oyD7ekV-hMU91h4J.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MobileApp</title>
      <link href="/2023/01/10/SoftwareDevelopment/MobileDev/"/>
      <url>/2023/01/10/SoftwareDevelopment/MobileDev/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.w3schools.com/html/html_responsive.asp">https://www.w3schools.com/html/html_responsive.asp</a></p>]]></content>
      
      
      <categories>
          
          <category> Software Development </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

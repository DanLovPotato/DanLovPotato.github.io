<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>DP | Dan's Blog</title><meta name="author" content="Dan"><meta name="copyright" content="Dan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DP🌼steps: 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  我在这里做一个总结： 求组合数：动态规划：518.零钱兑换II 求排列数：动态规划：377. 组合总和 Ⅳ、动态规划：70. 爬楼梯进阶版（完全背包） 求最小数：动态规划：322. 零钱兑换、动态规划：279.完全平方数 Leetcode:509. Fibona">
<meta property="og:type" content="article">
<meta property="og:title" content="DP">
<meta property="og:url" content="https://danlovpotato.github.io/2023/07/21/LeetCode/DP/index.html">
<meta property="og:site_name" content="Dan&#39;s Blog">
<meta property="og:description" content="DP🌼steps: 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组  我在这里做一个总结： 求组合数：动态规划：518.零钱兑换II 求排列数：动态规划：377. 组合总和 Ⅳ、动态规划：70. 爬楼梯进阶版（完全背包） 求最小数：动态规划：322. 零钱兑换、动态规划：279.完全平方数 Leetcode:509. Fibona">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png">
<meta property="article:published_time" content="2023-07-21T04:00:00.000Z">
<meta property="article:modified_time" content="2023-07-27T19:44:11.976Z">
<meta property="article:author" content="Dan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png"><link rel="shortcut icon" href="https://cdn.pixabay.com/photo/2016/03/31/19/26/cherry-blossom-1295009_1280.png"><link rel="canonical" href="https://danlovpotato.github.io/2023/07/21/LeetCode/DP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-27 15:44:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> Messageboard</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.shopify.com/s/files/1/1622/4127/files/072020_postcards_purple_pink_1024x1024.jpg?v=1595358295')"><nav id="nav"><span id="blog-info"><a href="/" title="Dan's Blog"><span class="site-name">Dan's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> Messageboard</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">DP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-21T04:00:00.000Z" title="Created 2023-07-21 00:00:00">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-07-27T19:44:11.976Z" title="Updated 2023-07-27 15:44:11">2023-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="DP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="DP🌼"><a href="#DP🌼" class="headerlink" title="DP🌼"></a>DP🌼</h1><h2 id="steps"><a href="#steps" class="headerlink" title="steps:"></a>steps:</h2><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>我在这里做一个总结：</p>
<p>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a> 求排列数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a> 求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p>
<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode:"></a>Leetcode:</h2><h3 id="509-Fibonacci-Number"><a href="#509-Fibonacci-Number" class="headerlink" title="509. Fibonacci Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fibonacci-number/">509. Fibonacci Number</a></h3><p>The <strong>Fibonacci numbers</strong>, commonly denoted <code>F(n)</code> form a sequence, called the <strong>Fibonacci sequence</strong>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0, F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2), for n &gt; 1.</span><br></pre></td></tr></table></figure>

<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fib(int n) &#123;</span><br><span class="line">        if( n &lt; 2)</span><br><span class="line">            return n;</span><br><span class="line">        int[] dp = new int[ n + 1];  </span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt; dp.length;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs</a></h2><p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>

<p>这道题的推导公式是这样得来的：<br>在到达第n层的上一步，我们只有两个选择，走一步，或者走两步。<br>如果是走一步，我们需要先通过 f(n-1)种方式到达 n-1 层<br>如果是走两步， 我们需要通过 f(n-2)种方式到达第 n - 2 层<br>所以综上有 f(n) &#x3D; f(n-2) + f(n-1)</p>
<p>it’s actually Fibonacci Number</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">    if(n &lt;= 2 )&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">     int[] dp = new int[n];</span><br><span class="line">     dp[0] = 1;</span><br><span class="line">     dp[1] = 2;</span><br><span class="line">     for(int i = 2; i &lt; dp.length; i++)&#123;</span><br><span class="line">         dp[i] = dp[i-1] + dp[i-2];</span><br><span class="line">     &#125;</span><br><span class="line">     return dp[n - 1];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0-1 unbounded knapsack </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        int[] nums = &#123;1, 2&#125;;</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for(int j = 0; j &lt; n+1; j++)&#123;</span><br><span class="line">            for(int i = 0; i &lt; 2; i++)&#123;</span><br><span class="line">                if(j &gt;= nums[i])</span><br><span class="line">                    dp[j] = dp[j]+dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="746-Min-Cost-Climbing-Stairs"><a href="#746-Min-Cost-Climbing-Stairs" class="headerlink" title="746. Min Cost Climbing Stairs"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-cost-climbing-stairs/">746. Min Cost Climbing Stairs</a></h3><p>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>ith</code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p>
<p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p>
<p>Return <em>the minimum cost to reach the top of the floor</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [10,15,20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: You will start at index 1.</span><br><span class="line">- Pay 15 and climb two steps to reach the top.</span><br><span class="line">The total cost is 15.</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        if(cost.length == 1)&#123;</span><br><span class="line">            return cost[0];</span><br><span class="line">        &#125;else if(cost.length == 2)&#123;</span><br><span class="line">            return Math.min(cost[0],cost[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[cost.length + 1];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for(int i = 2; i &lt; dp.length; i ++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2]+cost[i-2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[dp.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h3><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// mine: </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] d = new int[m][n];</span><br><span class="line">        for(int x= 0; x &lt; m; x++)&#123;</span><br><span class="line">            for(int y = 0; y &lt; n; y++)&#123;</span><br><span class="line">            ----------</span><br><span class="line">                if( y == 0)&#123;</span><br><span class="line">                    if(x==0)&#123;</span><br><span class="line">                        d[x][y] = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        d[x][y] = d[x-1][y];</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;else if(x == 0)&#123;</span><br><span class="line">                     if(y==0)&#123;</span><br><span class="line">                        d[x][y] = 1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        d[x][y] = d[x][y-1];</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    d[x][y] = d[x][y-1]+d[x-1][y];</span><br><span class="line">                &#125;</span><br><span class="line">            ---------    </span><br><span class="line">                </span><br><span class="line">                =========&gt; optimize:</span><br><span class="line">                if( y == 0)&#123;</span><br><span class="line">                    d[x][y] = 1;</span><br><span class="line">                &#125;else if(x == 0)&#123;</span><br><span class="line">                     d[x][y] = 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    d[x][y] = d[x][y-1]+d[x-1][y];</span><br><span class="line">                &#125;</span><br><span class="line">                ==========    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return d[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63.Unique Paths II"></a>63.Unique Paths II</h3><p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>
<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>
<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>
<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 109</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// mine:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int[][] dp = new int[obstacleGrid.length][obstacleGrid[0].length];</span><br><span class="line">        if(obstacleGrid[0][0] ==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; obstacleGrid.length; i++)&#123;</span><br><span class="line">            if(obstacleGrid[i][0] == 1)&#123;</span><br><span class="line">                 while( i &lt; obstacleGrid.length)&#123;</span><br><span class="line">                    dp[i][0] = 0;</span><br><span class="line">                    i++;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; obstacleGrid[0].length; i++)&#123;</span><br><span class="line">            if(obstacleGrid[0][i] == 1)&#123;</span><br><span class="line">                while( i &lt; obstacleGrid[0].length)&#123;</span><br><span class="line">                    dp[0][i] = 0;</span><br><span class="line">                    i++;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[0][i] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int x = 1; x &lt; obstacleGrid.length; x++)&#123;</span><br><span class="line">            for(int y = 1; y &lt; obstacleGrid[x].length; y++)&#123;</span><br><span class="line">                if(obstacleGrid[x][y] == 1)&#123;</span><br><span class="line">                    dp[x][y] = 0;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[x][y] = dp[x-1][y] +dp[x][y-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//leetcodemaster:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.length;</span><br><span class="line">        int n = obstacleGrid[0].length;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">        //如果在起点或终点出现了障碍，直接返回0</span><br><span class="line">        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) &#123;  // ！！！这样写非常neat</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) &#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>In Java, when you create a new array of certain data type (e.g., int[], double[], char[], etc.), the elements in the array are initialized to default values based on the data type. For numeric data types (e.g., int, double, float, etc.), the default value is 0. </p>
<p>so actually </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; obstacleGrid.length; i++)&#123;</span><br><span class="line">    if(obstacleGrid[i][0] == 1)&#123;</span><br><span class="line">         while( i &lt; obstacleGrid.length)&#123;</span><br><span class="line">            dp[i][0] = 0;    // this is unecessary</span><br><span class="line">            i++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/integer-break/">343. Integer Break</a></h3><p>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p>
<p>Return <em>the maximum product you can get</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 2 = 1 + 1, 1 × 1 = 1.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[2] =  1;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int j = 1; j &lt; i; j++)&#123;</span><br><span class="line">            </span><br><span class="line">            /*   </span><br><span class="line">        		======= optimize: ========</span><br><span class="line">             	for(int j = 1; j &lt;= i-j; j++) &#123;</span><br><span class="line">             	// 这里的 j 其实最大值为 i-j,再大只不过是重复而已，</span><br><span class="line">        	*/</span><br><span class="line">            </span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(dp[i-j]*j,j*(i-j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>this is important :</strong><br>dp[i] &#x3D; Math.max(dp[i], Math.max(dp[i-j]<em>j,</em> j*(i-j)  ));</p>
<p>dp[i-j]*j -&gt; 至少是三个integer相乘</p>
<p>j*(i-j) -&gt; 两个integer相乘</p>
<h3 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">96. Unique Binary Search Trees</a></h3><p>Given an integer <code>n</code>, return *the number of structurally unique **BST’*<em>s (binary search trees) which has exactly</em> <code>n</code> <em>nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        if(n &lt; 3)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2 ; i &lt; dp.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i-j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.md</a></p>
<p>dp[0] &#x3D; 1;</p>
<p>dp[1] &#x3D;1,</p>
<p>dp[2] &#x3D; 2;</p>
<p>dp[3] &#x3D; dp[0] ( Case -&gt; left tree has 0 node) * dp[2] (right tree has two nodes)+ dp[1] * dp[1] +  dp[2] * dp[0] </p>
<h2 id="0-x2F-1-Knapsack-problem"><a href="#0-x2F-1-Knapsack-problem" class="headerlink" title="0&#x2F;1 Knapsack problem:"></a>0&#x2F;1 Knapsack problem:</h2><ol>
<li><p>装满背包的最大价值是多少</p>
</li>
<li><p>能不能装满一个背包</p>
</li>
<li><p>多少种方式能把背包装满</p>
</li>
</ol>
<h3 id="0-x2F-1-Knapsack-Problem-two-dimenstion-array"><a href="#0-x2F-1-Knapsack-Problem-two-dimenstion-array" class="headerlink" title="0&#x2F;1 Knapsack Problem ( two dimenstion array)"></a>0&#x2F;1 Knapsack Problem ( two dimenstion array)</h3><p>确定递推公式:</p>
<p>dp [i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>代码初始化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0 ; j &lt; weight[0]; j++) &#123;  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span><br><span class="line">    dp[0][j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">// 正序遍历</span><br><span class="line">for (int j = weight[0]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[0][j] = value[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class BagProblem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] weight = &#123;1,3,4&#125;;</span><br><span class="line">        int[] value = &#123;15,20,30&#125;;</span><br><span class="line">        int bagSize = 4;</span><br><span class="line">        testWeightBagProblem(weight,value,bagSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize)&#123;</span><br><span class="line"></span><br><span class="line">        // 创建dp数组</span><br><span class="line">        int goods = weight.length;  // 获取物品的数量</span><br><span class="line">        int[][] dp = new int[goods][bagSize + 1];</span><br><span class="line"></span><br><span class="line">        // 初始化dp数组</span><br><span class="line">        // 创建数组后，其中默认的值就是0</span><br><span class="line">        for (int j = weight[0]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[0][j] = value[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 填充dp数组  两层for循环是可以颠倒的</span><br><span class="line">        for (int i = 1; i &lt; weight.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                if (j &lt; weight[i]) &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的</span><br><span class="line">                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值</span><br><span class="line">                     */</span><br><span class="line">                    dp[i][j] = dp[i-1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 当前背包的容量可以放下物品i</span><br><span class="line">                     * 那么此时分两种情况：</span><br><span class="line">                     *    1、不放物品i</span><br><span class="line">                     *    2、放物品i</span><br><span class="line">                     * 比较这两种情况下，哪种背包中物品的最大价值最大</span><br><span class="line">                     */</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 打印dp数组</span><br><span class="line">        for (int i = 0; i &lt; goods; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/3e93e2608c9e09b34e969e34ef7cf52def30f02923b91576c7c5599843361412/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f3230323130313130313033323132342e706e67" alt="动态规划-背包问题5"></p>
<p><strong>because dp[i ] [j] is caculated from dp [i- 1 ] [ j ],dp[i-1 ]  [j-1 ], so 两层for循环是可以颠倒的</strong></p>
<h3 id="0-x2F-1-Knapsack-Problem-one-dimenstion-array"><a href="#0-x2F-1-Knapsack-Problem-one-dimenstion-array" class="headerlink" title="0&#x2F;1 Knapsack Problem ( one dimenstion array)"></a>0&#x2F;1 Knapsack Problem ( one dimenstion array)</h3><ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol>
<li>一维dp数组的递推公式</li>
</ol>
<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>



<p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p>
<ol>
<li><h4 id="一维dp数组如何初始化"><a href="#一维dp数组如何初始化" class="headerlink" title="一维dp数组如何初始化"></a><strong>一维dp数组如何初始化</strong></h4></li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<ol>
<li>一维dp数组遍历顺序</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><span style="color: red"><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">************ one dimension: ********* </span><br><span class="line">for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品</span><br><span class="line">    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量</span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ********* two  dimention: *********</span><br><span class="line"> for (int i = 1; i &lt; weight.length; i++) &#123;</span><br><span class="line"> 	for (int j = 1; j &lt;= bagSize; j++) &#123;</span><br><span class="line">		 if (j &lt; weight[i]) &#123;</span><br><span class="line"> 			dp[i][j] = dp[i-1][j];</span><br><span class="line"> 		&#125; else &#123;</span><br><span class="line"> 			dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p>
<p>如果正序遍历</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>所以从后往前循环，<span style="color: red">每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</span></p>
<p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！所以倒叙正序都可以。</p>
<p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<p>（这里如果读不懂，就再回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p>
<p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">    int bagWight = 4;</span><br><span class="line">    testWeightBagProblem(weight, value, bagWight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight)&#123;</span><br><span class="line">    int wLen = weight.length;</span><br><span class="line">    //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值</span><br><span class="line">    int[] dp = new int[bagWeight + 1];</span><br><span class="line">    //遍历顺序：先遍历物品，再遍历背包容量</span><br><span class="line">    for (int i = 0; i &lt; wLen; i++)&#123;</span><br><span class="line">        for (int j = bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //打印dp数组</span><br><span class="line">    for (int j = 0; j &lt;= bagWeight; j++)&#123;</span><br><span class="line">        System.out.print(dp[j] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">416. Partition Equal Subset Sum</a></h3><p>Given an integer array <code>nums</code>, return <code>true</code> <em>if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or</em> <code>false</code> <em>otherwise</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure>

<p>my version(one dimension array):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum % 2 != 0) return false;</span><br><span class="line">        int half = sum/2;</span><br><span class="line">        int[] dp = new int[half+1]; // notice here is half+1 not half</span><br><span class="line">        for(int i = 0 ; i &lt; nums.length; i++ )&#123;</span><br><span class="line">            for(int j = half; j &gt;= nums[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(dp[half] == half)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组版本（易于理解）leetmaster：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num[] = &#123;1,5,11,5&#125;;</span><br><span class="line">        canPartition(num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        // 题目已经说非空数组，可以不做非空判断</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        // 特判：如果是奇数，就不符合要求</span><br><span class="line">        if ((sum %2 ) != 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int target = sum / 2; //目标背包容量</span><br><span class="line">        // 创建二维状态数组，行：物品索引，列：容量（包括 0）</span><br><span class="line">        /*</span><br><span class="line">        dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数</span><br><span class="line">          每个数只能用一次，使得这些数的和恰好等于 j。</span><br><span class="line">        */</span><br><span class="line">        boolean[][] dp = new boolean[len][target + 1];</span><br><span class="line"></span><br><span class="line">        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满  （这里的dp[][]数组的含义就是“恰好”，所以就算容积比它大的也不要）</span><br><span class="line">        if (nums[0] &lt;= target) &#123;</span><br><span class="line">            dp[0][nums[0]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 再填表格后面几行</span><br><span class="line">        //外层遍历物品</span><br><span class="line">        for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">            //内层遍历背包</span><br><span class="line">            for (int j = 0; j &lt;= target; j++) &#123;</span><br><span class="line">                // 直接从上一行先把结果抄下来，然后再修正</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line"></span><br><span class="line">                //如果某个物品单独的重量恰好就等于背包的重量，那么也是满足dp数组的定义的</span><br><span class="line">                if (nums[i] == j) &#123;</span><br><span class="line">                    dp[i][j] = true;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果某个物品的重量小于j，那就可以看该物品是否放入背包</span><br><span class="line">                //dp[i - 1][j]表示该物品不放入背包，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；</span><br><span class="line">                //dp[i - 1][j - nums[i]]表示该物品放入背包。如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。</span><br><span class="line">                if (nums[i] &lt; j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= target; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j]+&quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//dp数组的打印结果</span><br><span class="line">false true false false false false false false false false false false </span><br><span class="line">false true false false false true true false false false false false </span><br><span class="line">false true false false false true true false false false false true </span><br><span class="line">false true false false false true true false false false true true </span><br></pre></td></tr></table></figure>

<p>my try:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum % 2 != 0) return false;</span><br><span class="line">        int half = sum/2;</span><br><span class="line">        int[][] dp = new int[half+1][nums.length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int j = nums[0]; j &lt;= half; j++) &#123;</span><br><span class="line">            dp[j][0] = nums[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 1 ; i &lt; nums.length; i++ )&#123;</span><br><span class="line">            for(int j = 1; j &lt;= half; j++)&#123;</span><br><span class="line">                if(j &gt; nums[i])&#123;</span><br><span class="line">                dp[j][i] = Math.max(dp[j][i-1], dp[j - nums[i]][i-1] + nums[i]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[j][i] = dp[j][i-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(dp[half][nums.length -1] == half)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1049-Last-Stone-Weight-II"><a href="#1049-Last-Stone-Weight-II" class="headerlink" title="1049. Last Stone Weight II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/last-stone-weight-ii/">1049. Last Stone Weight II</a></h3><p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>ith</code> stone.</p>
<p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p>
<ul>
<li>If <code>x == y</code>, both stones are destroyed, and</li>
<li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.</li>
</ul>
<p>At the end of the game, there is <strong>at most one</strong> stone left.</p>
<p>Return <em>the smallest possible weight of the left stone</em>. If there are no stones left, return <code>0</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,</span><br><span class="line">we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,</span><br><span class="line">we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,</span><br><span class="line">we can combine 1 and 1 to get 0, so the array converts to [1], then that&#x27;s the optimal value.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: stones = [31,26,33,21,40]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++)&#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[half+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> half; j &gt;= stones[i]; j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j - stones[i]]+stones[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">part1</span> <span class="operator">=</span> dp[half] ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">part2</span> <span class="operator">=</span>  sum - dp[half];</span><br><span class="line">        <span class="keyword">return</span> Math.abs(part1 - part2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/target-sum/">494. Target Sum</a></h3><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">纯 0 - 1 背包</a> 是求 给定背包容量 装满背包 的最大价值是多少。</li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">416. 分割等和子集</a> 是求 给定背包容量，能不能装满这个背包。</li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">1049. 最后一块石头的重量 II</a> 是求 给定背包容量，尽可能装，最多能装多少</li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">494. 目标和</a> 是求 给定背包容量，装满背包有多少种方法。</li>
<li>本题是求 给定背包容量，装满背包最多有多少个物品。</li>
</ul>
<p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p>
<p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p>
<ul>
<li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li>
</ul>
<p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,1,1,1], target = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure>

<p>dp[j] ：装满容量为j的背包有dp[j]种方法</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<ol>
<li>含义：dp【i】【j】：从下标为【0…i】的物品里任取，填满j这么⼤容积的包，有dp【i】【j】种⽅法</li>
<li>递推式：dp【i】【j】 &#x3D; dp【i-1】【j】 + dp【i-1】[j-nums【i】]<br>           dp【i-1】【j】是不将物品i放入背包的方式数，dp【i-1】[j-nums【i】]是将物品i放入背包的方式数</li>
<li>初始化：dp【0】【0】 &#x3D; 1 表示装满容量为0的背包，有1种⽅法，就是装0件物品。（区别于原始的背包问题，它求的是最大价值，所以dp[0 】[0]&#x3D;0因为没有东西所以总价值是0）<br>          如果nums【0】在范围内的话，dp【0】[nums【0】] &#x3D; 1<br>           其他全为0</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target)&#123;       </span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int i=0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if((target + sum)%2 != 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &lt; Math.abs(target))&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int plus = (target + sum)/2;</span><br><span class="line"></span><br><span class="line">        int[][] dp = new int[plus + 1][nums.length];</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt;= plus; j++) &#123;</span><br><span class="line">            if(nums[0] == j) &#123;</span><br><span class="line">                dp[j][0] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int numZeros = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if(nums[i] == 0) &#123;</span><br><span class="line">                numZeros++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[0][i] = (int) Math.pow(2, numZeros);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         for(int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">             for(int j = 1; j &lt;= plus; j++)&#123;</span><br><span class="line">                if(nums[i] &lt;= j)&#123;</span><br><span class="line">                 dp[j][i] = dp[j - nums[i]][i-1] + dp[j][i-1];&#125;else&#123;</span><br><span class="line">                dp[j][i] = dp[j][i-1];</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return dp[plus][nums.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a>474. Ones and Zeroes</h3><p>Medium</p>
<p>Companies</p>
<p>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p>
<p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong></em> <code>m</code> <code>0</code><em>‘s and</em> <code>n</code> <code>1</code><em>‘s in the subset</em>.</p>
<p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The largest subset with at most 5 0&#x27;s and 3 1&#x27;s is &#123;&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, so the answer is 4.</span><br><span class="line">Other valid but smaller subsets include &#123;&quot;0001&quot;, &quot;1&quot;&#125; and &#123;&quot;10&quot;, &quot;1&quot;, &quot;0&quot;&#125;.</span><br><span class="line">&#123;&quot;111001&quot;&#125; is an invalid subset because it contains 4 1&#x27;s, greater than the maximum of 3.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The largest subset is &#123;&quot;0&quot;, &quot;1&quot;&#125;, so the answer is 2.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// it&#x27;s actually one dimmension solution</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line">        </span><br><span class="line">        int[][] dp= new int[m+1][n+1]; // notice here, [m+1][n+1]</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line"></span><br><span class="line">        for( String str: strs)&#123;</span><br><span class="line">            int one = 0;</span><br><span class="line">            int zero = 0;</span><br><span class="line">            for(char ch: str.toCharArray())&#123;</span><br><span class="line">                if(ch == &#x27;0&#x27;) zero++;</span><br><span class="line">                if(ch == &#x27;1&#x27;) one++;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int i = m; i &gt;= zero; i--)&#123;</span><br><span class="line">                for(int j = n; j &gt;= one; j--)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[i-zero][j-one]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unbounded-knapsack-problem"><a href="#unbounded-knapsack-problem" class="headerlink" title="unbounded knapsack problem"></a>unbounded knapsack problem</h2><p>遍历顺序从小到大就可以无限次选同一个物品</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//先遍历物品，再遍历背包</span><br><span class="line">private static void testCompletePack()&#123;</span><br><span class="line">    int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">    int bagWeight = 4;</span><br><span class="line">    int[] dp = new int[bagWeight + 1];</span><br><span class="line">    for (int i = 0; i &lt; weight.length; i++)&#123; // 遍历物品</span><br><span class="line">        for (int j = weight[i]; j &lt;= bagWeight; j++)&#123; // 遍历背包容量</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int maxValue : dp)&#123;</span><br><span class="line">        System.out.println(maxValue + &quot;   &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//先遍历背包，再遍历物品</span><br><span class="line">private static void testCompletePackAnotherWay()&#123;</span><br><span class="line">    int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">    int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">    int bagWeight = 4;</span><br><span class="line">    int[] dp = new int[bagWeight + 1];</span><br><span class="line">    for (int i = 1; i &lt;= bagWeight; i++)&#123; // 遍历背包容量</span><br><span class="line">        for (int j = 0; j &lt; weight.length; j++)&#123; // 遍历物品</span><br><span class="line">            if (i - weight[j] &gt;= 0)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int maxValue : dp)&#123;</span><br><span class="line">        System.out.println(maxValue + &quot;   &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="518-Coin-Change-II"><a href="#518-Coin-Change-II" class="headerlink" title="518. Coin Change II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change-ii/">518. Coin Change II</a></h3><ol>
<li>dp数组如何初始化</li>
</ol>
<p>首先dp[0]一定要为1，dp[0] &#x3D; 1是 递归公式的基础。如果dp[0] &#x3D; 0 的话，后面所有推导出来的值都是0了。</p>
<p>那么 dp[0] &#x3D; 1 有没有含义，其实既可以说 凑成总金额0的货币组合数为1，也可以说 凑成总金额0的货币组合数为0，好像都没有毛病。</p>
<p>但题目描述中，也没明确说 amount &#x3D; 0 的情况，结果应该是多少。</p>
<p>这里我认为题目描述还是要说明一下，因为后台测试数据是默认，amount &#x3D; 0 的情况，组合数为1的。</p>
<p>下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]</p>
<p>dp[0]&#x3D;1还说明了一种情况：如果正好选了coins[i]后，也就是j-coins[i] &#x3D;&#x3D; 0的情况表示这个硬币刚好能选，此时dp[0]为1表示只选coins[i]存在这样的一种选法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[] dp = new int[amount+1];</span><br><span class="line">        dp[0] =1;</span><br><span class="line">        for(int i = 0; i &lt; coins.length; i++)&#123;</span><br><span class="line">            for(int j = coins[i]; j &lt;= amount; j++)&#123;</span><br><span class="line">                dp[j] = dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iv/">377. Combination Sum IV</a></h3><p>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em> <code>target</code>.</p>
<p>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3], target = 4</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">Note that different sequences are counted as different combinations.</span><br></pre></td></tr></table></figure>

<p><span style=" color: red"><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</span></p>
<p><span style=" color: red"><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</span></p>
<p>logic one: <span style=" color: brown">就是说先遍历物品的时候相当于是先把这个物品放进去了然后再看其他的能不能放进去，所以不会出现逆序，先遍历背包相当于是用每个大小的背包看看把每一个物品都放进去一次再看别的物品能不能放进去，所以可以有逆序</span></p>
<p>logic 2:  <span style=" color: brown">关于组合和排列的问题还是有些不解。以下仅为自己的理解：先遍历物品后遍历背包是这样，比如，外层循环固定coins【1】，在内层循环遍历背包时，随着背包不断增加，coins【1】可以重复被添加进来，而由于外层循环固定了，因此coins【2】只能在下一次外层循环添加进不同大小的背包中，这么看的话，coins【i+1】只能在coins【i】之后了；如果先遍历背包后遍历物品，那么外层循环先固定背包大小j，然后在大小为j的背包中循环遍历添加物品，然后在下次外层循环背包大小变为j+1，此时仍要执行内层循环遍历添加物品，也就会出现在上一轮外层循环中添加coins【2】的基础上还能再添加coins【1】的情况，那么就有了coins【1】在coins【2】之后的情况了。</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[] dp = new int[target + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for(int j = 0; j &lt;= target; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i = 0; i &lt; nums.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[i] &lt;= j)&#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j-nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/">322. Coin Change</a></h3><p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>
<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1,2,5], amount = 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure>

<p>The check <code>if(dp[j-coins[i]]!= Integer.MAX_VALUE)</code> is necessary to ensure that we only consider valid subproblem solutions. If <code>dp[j - coins[i]]</code> is equal to <code>Integer.MAX_VALUE</code>, it means that there is no valid solution for the amount <code>j - coins[i]</code>, and hence, we cannot use the current coin denomination to make up the amount <code>j</code>.</p>
<p>Without this check, the algorithm might end up considering invalid solutions and could produce incorrect results. This check ensures that we only consider valid intermediate solutions to compute the fewest number of coins for the given <code>amount</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int coinChange(int[] coins, int amount)&#123; </span><br><span class="line"></span><br><span class="line">        int[] dp = new int[amount + 1];</span><br><span class="line">        for(int j = 0; j &lt;= amount; j++)&#123;</span><br><span class="line">            dp[j] = Integer.MAX_VALUE; //important!</span><br><span class="line">        &#125;</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for(int i =0; i &lt; coins.length; i++)&#123;</span><br><span class="line">            for(int j = coins[i]; j &lt; amount+1; j++)&#123;</span><br><span class="line">                if(dp[j-coins[i]]!= Integer.MAX_VALUE) //important!!</span><br><span class="line">                //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[amount]&lt;0 || dp[amount] == Integer.MAX_VALUE)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139.Word Break"></a>139.Word Break</h3><p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>
<p><strong>Example :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>

<ol>
<li>确定遍历顺序</li>
</ol>
<p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p>
<p>还要讨论两层for循环的前后顺序。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>我在这里做一个总结：</p>
<p>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a> 求排列数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a> 求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p>
<p>而本题其实我们求的是排列数，为什么呢。 拿 s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] 举例。</p>
<p>“apple”, “pen” 是物品，那么我们要求 物品的组合一定是 “apple” + “pen” + “apple” 才能组成 “applepenapple”。</p>
<p>“apple” + “apple” + “pen” 或者 “pen” + “apple” + “apple” 是不可以的，那么我们就是强调物品之间顺序。</p>
<p>所以说，<span style="color: red">本题一定是 先遍历 背包，再遍历物品。</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        int bagSize =  s.length() + 1;</span><br><span class="line">        boolean[] dp = new boolean[bagSize];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">       </span><br><span class="line">            for(int j = 0; j &lt; bagSize; j++)&#123; // bag</span><br><span class="line">                 for( String word : wordDict)&#123; // thing</span><br><span class="line">                    if(j &gt;= word.length() &amp;&amp; dp[j - word.length()] &amp;&amp; word.equals(s.substring(j-word.length(),j)))&#123;//important</span><br><span class="line">                        dp[j] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">198. House Robber</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1)  return nums[0];</span><br><span class="line"></span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = Math.max(nums[0], nums[1]);  //important</span><br><span class="line">        </span><br><span class="line">        for(int i = 2; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-1], dp[i-2]+ nums[i]); //important</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[nums.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-ii/">213. House Robber II</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<p>这道题目和<a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>是差不多的，唯一区别就是成环了。</p>
<p>对于一个数组，成环的话主要有如下三种情况：</p>
<ul>
<li><p>情况一：考虑不包含首尾元素</p>
</li>
<li><p>情况二：考虑包含首元素，不包含尾元素</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/7b9cd836f98b01ea8a146920e53015d909783ef8c4ceb066657e2f90f00915bf/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303832313337342d32303233303331303133343030333936312e6a7067"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/7b9cd836f98b01ea8a146920e53015d909783ef8c4ceb066657e2f90f00915bf/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303832313337342d32303233303331303133343030333936312e6a7067" alt="213.打家劫舍II1"></a></p>
<ul>
<li>情况三：考虑包含尾元素，不包含首元素</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/3a5cfd80c966a0c512d8b4b57c51403b8982c7a4be89e5e994fb08d17fa19c94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303834323439312d32303233303331303133343030383133332e6a7067"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/3a5cfd80c966a0c512d8b4b57c51403b8982c7a4be89e5e994fb08d17fa19c94/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303132393136303834323439312d32303233303331303133343030383133332e6a7067" alt="213.打家劫舍II2"></a></p>
<p>**注意我这里用的是”考虑”**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。</p>
<p><strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p>
<p>分析到这里，本题其实比较简单了。 剩下的和<a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>就是一样的了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int robRange(int[] nums, int start, int end)&#123;</span><br><span class="line">        int[] dp = new int[end - start + 1];</span><br><span class="line">        dp[0] = nums[start];</span><br><span class="line">        dp[1] = Math.max(nums[start] , nums[start+1]);</span><br><span class="line">        for(int i = 2; i &lt;= end - start ; i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i+start]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[end - start];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length == 1) return nums[0];</span><br><span class="line">        if(nums.length == 2) return Math.max(nums[0] , nums[1]);</span><br><span class="line">        int a = robRange(nums, 1 , nums.length - 1);</span><br><span class="line">        int b = robRange(nums, 0 , nums.length - 2);</span><br><span class="line"></span><br><span class="line">        return Math.max(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-iii/">337. House Robber III</a></h3><p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p>
<p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p>
<p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,2,3,null,3,null,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<p>[toc]</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://DanLovPotato.github.io">Dan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://danlovpotato.github.io/2023/07/21/LeetCode/DP/">https://danlovpotato.github.io/2023/07/21/LeetCode/DP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/28/LeetCode/tree/" title="Tree"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Tree</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/19/SoftwareDevelopment/AWS/" title="AWS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">AWS</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dan</div><div class="author-info__description">Lack the words to compliment myself today.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DanLovPotato"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DP%F0%9F%8C%BC"><span class="toc-number">1.</span> <span class="toc-text">DP🌼</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#steps"><span class="toc-number">1.1.</span> <span class="toc-text">steps:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode"><span class="toc-number">1.2.</span> <span class="toc-text">Leetcode:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#509-Fibonacci-Number"><span class="toc-number">1.2.1.</span> <span class="toc-text">509. Fibonacci Number</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-Climbing-Stairs"><span class="toc-number">1.3.</span> <span class="toc-text">70. Climbing Stairs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#746-Min-Cost-Climbing-Stairs"><span class="toc-number">1.3.1.</span> <span class="toc-text">746. Min Cost Climbing Stairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-Unique-Paths"><span class="toc-number">1.3.2.</span> <span class="toc-text">62. Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-Unique-Paths-II"><span class="toc-number">1.3.3.</span> <span class="toc-text">63.Unique Paths II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343-Integer-Break"><span class="toc-number">1.3.4.</span> <span class="toc-text">343. Integer Break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-Unique-Binary-Search-Trees"><span class="toc-number">1.3.5.</span> <span class="toc-text">96. Unique Binary Search Trees</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-x2F-1-Knapsack-problem"><span class="toc-number">1.4.</span> <span class="toc-text">0&#x2F;1 Knapsack problem:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-x2F-1-Knapsack-Problem-two-dimenstion-array"><span class="toc-number">1.4.1.</span> <span class="toc-text">0&#x2F;1 Knapsack Problem ( two dimenstion array)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-x2F-1-Knapsack-Problem-one-dimenstion-array"><span class="toc-number">1.4.2.</span> <span class="toc-text">0&#x2F;1 Knapsack Problem ( one dimenstion array)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4dp%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">一维dp数组如何初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-Partition-Equal-Subset-Sum"><span class="toc-number">1.4.3.</span> <span class="toc-text">416. Partition Equal Subset Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1049-Last-Stone-Weight-II"><span class="toc-number">1.4.4.</span> <span class="toc-text">1049. Last Stone Weight II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-Target-Sum"><span class="toc-number">1.4.5.</span> <span class="toc-text">494. Target Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-Ones-and-Zeroes"><span class="toc-number">1.4.6.</span> <span class="toc-text">474. Ones and Zeroes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unbounded-knapsack-problem"><span class="toc-number">1.5.</span> <span class="toc-text">unbounded knapsack problem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#518-Coin-Change-II"><span class="toc-number">1.5.1.</span> <span class="toc-text">518. Coin Change II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#377-Combination-Sum-IV"><span class="toc-number">1.5.2.</span> <span class="toc-text">377. Combination Sum IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-Coin-Change"><span class="toc-number">1.5.3.</span> <span class="toc-text">322. Coin Change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-Word-Break"><span class="toc-number">1.5.4.</span> <span class="toc-text">139.Word Break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198-House-Robber"><span class="toc-number">1.5.5.</span> <span class="toc-text">198. House Robber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-House-Robber-II"><span class="toc-number">1.5.6.</span> <span class="toc-text">213. House Robber II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#337-House-Robber-III"><span class="toc-number">1.5.7.</span> <span class="toc-text">337. House Robber III</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/21/ImageProcess/classNote/" title="Image Process">Image Process</a><time datetime="2023-09-21T04:00:00.000Z" title="Created 2023-09-21 00:00:00">2023-09-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/17/LeetCode/BackTracking/" title="BackTracking">BackTracking</a><time datetime="2023-08-17T04:00:00.000Z" title="Created 2023-08-17 00:00:00">2023-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/28/LeetCode/tree/" title="Tree">Tree</a><time datetime="2023-07-28T04:00:00.000Z" title="Created 2023-07-28 00:00:00">2023-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/LeetCode/DP/" title="DP">DP</a><time datetime="2023-07-21T04:00:00.000Z" title="Created 2023-07-21 00:00:00">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/19/SoftwareDevelopment/AWS/" title="AWS">AWS</a><time datetime="2023-07-19T04:00:00.000Z" title="Created 2023-07-19 00:00:00">2023-07-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Dan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Tree | Dan's Blog</title><meta name="author" content="Dan"><meta name="copyright" content="Dan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TreeğŸŒ¼Recursive VS. BackTrack https:&#x2F;&#x2F;blog.csdn.net&#x2F;ajianyingxiaoqinghan&#x2F;article&#x2F;details&#x2F;79682147 Depth-first traversalThe recursive traversal of a binary treeIn-order traversal (Left-Root-Right):  Tr">
<meta property="og:type" content="article">
<meta property="og:title" content="Tree">
<meta property="og:url" content="https://danlovpotato.github.io/2023/07/28/LeetCode/tree/index.html">
<meta property="og:site_name" content="Dan&#39;s Blog">
<meta property="og:description" content="TreeğŸŒ¼Recursive VS. BackTrack https:&#x2F;&#x2F;blog.csdn.net&#x2F;ajianyingxiaoqinghan&#x2F;article&#x2F;details&#x2F;79682147 Depth-first traversalThe recursive traversal of a binary treeIn-order traversal (Left-Root-Right):  Tr">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png">
<meta property="article:published_time" content="2023-07-28T04:00:00.000Z">
<meta property="article:modified_time" content="2024-01-24T19:45:51.004Z">
<meta property="article:author" content="Dan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png"><link rel="shortcut icon" href="https://cdn.pixabay.com/photo/2016/03/31/19/26/cherry-blossom-1295009_1280.png"><link rel="canonical" href="https://danlovpotato.github.io/2023/07/28/LeetCode/tree/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Tree',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-24 14:45:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> Messageboard</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.shopify.com/s/files/1/1622/4127/files/072020_postcards_purple_pink_1024x1024.jpg?v=1595358295')"><nav id="nav"><span id="blog-info"><a href="/" title="Dan's Blog"><span class="site-name">Dan's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> Messageboard</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Tree</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-28T04:00:00.000Z" title="Created 2023-07-28 00:00:00">2023-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-01-24T19:45:51.004Z" title="Updated 2024-01-24 14:45:51">2024-01-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Tree"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TreeğŸŒ¼"><a href="#TreeğŸŒ¼" class="headerlink" title="TreeğŸŒ¼"></a>TreeğŸŒ¼</h1><p>Recursive VS. BackTrack</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/79682147">https://blog.csdn.net/ajianyingxiaoqinghan/article/details/79682147</a></p>
<h2 id="Depth-first-traversal"><a href="#Depth-first-traversal" class="headerlink" title="Depth-first traversal"></a>Depth-first traversal</h2><h3 id="The-recursive-traversal-of-a-binary-tree"><a href="#The-recursive-traversal-of-a-binary-tree" class="headerlink" title="The recursive traversal of a binary tree"></a>The recursive traversal of a binary tree</h3><p><strong>In-order traversal (Left-Root-Right)</strong>:</p>
<ol>
<li>Traverse the left subtree.</li>
<li>Visit the current node (Root).</li>
<li>Traverse the right subtree.</li>
</ol>
<p><strong>Pre-order traversal (Root-Left-Right)</strong>:</p>
<ol>
<li>Visit the current node (Root).</li>
<li>Traverse the left subtree.</li>
<li>Traverse the right subtree.</li>
</ol>
<p><strong>Post-order traversal (Left-Right-Root)</strong>:</p>
<ol>
<li>Traverse the left subtree.</li>
<li>Traverse the right subtree.</li>
<li>Visit the current node (Root).</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// å‰åºéå†Â·é€’å½’Â·LC144_äºŒå‰æ ‘çš„å‰åºéå†</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        preT(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preT(TreeNode root)&#123;</span><br><span class="line">        if(root == null) return;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preT(root.left);</span><br><span class="line">        preT(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ä¸­åºéå†Â·é€’å½’Â·LC94_äºŒå‰æ ‘çš„ä¸­åºéå†</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);             // æ³¨æ„è¿™ä¸€å¥</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// ååºéå†Â·é€’å½’Â·LC145_äºŒå‰æ ‘çš„ååºéå†</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postorder(root.left, list);</span><br><span class="line">        postorder(root.right, list);</span><br><span class="line">        list.add(root.val);             // æ³¨æ„è¿™ä¸€å¥</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterative-traversal-of-a-binary-tree"><a href="#Iterative-traversal-of-a-binary-tree" class="headerlink" title="Iterative traversal of a binary tree"></a>Iterative traversal of a binary tree</h3><ol>
<li><p><strong>Iterative In-order traversal</strong>: In this method, we simulate the function call stack of the recursive in-order traversal using a stack data structure. It involves traversing the left subtree first, then visiting the current node, and finally, traversing the right subtree.</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/6ea32e330a3c937346b1f48b3808a3ab0aade0f9b3cbe4a93b5580c08727cdb1/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545342542382541442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/6ea32e330a3c937346b1f48b3808a3ab0aade0f9b3cbe4a93b5580c08727cdb1/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545342542382541442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966" alt="äºŒå‰æ ‘ä¸­åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰"></a></p>
</li>
<li><p><strong>Iterative Pre-order traversal</strong>: In this approach, we use a stack to mimic the recursive pre-order traversal. It involves visiting the current node, then traversing the left subtree, and finally, traversing the right subtree.</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/b9924e53ce35c0417f176da66bcac1738f75eeb2ab20f4f243c36be62295004a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545352538392538442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/b9924e53ce35c0417f176da66bcac1738f75eeb2ab20f4f243c36be62295004a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f2545342542412538432545352538462538392545362541302539312545352538392538442545352542412538462545392538312538442545352538452538362545462542432538382545382542462541442545342542422541332545362542332539352545462542432538392e676966" alt="äºŒå‰æ ‘å‰åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰"></a></p>
</li>
<li><p><strong>Iterative Post-order traversal</strong>: This method can be a bit more complex than the other two. It requires two stacks or a single stack with additional bookkeeping to simulate the recursive post-order traversal. The nodes are processed in the order of the left subtree, right subtree, and then the current node.</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/997513e75ec0672ae4d7e8a962d571139646ac3ebef98ba4f89e5fba29db05e7/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830383230303333383932342e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/997513e75ec0672ae4d7e8a962d571139646ac3ebef98ba4f89e5fba29db05e7/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230303830383230303333383932342e706e67" alt="å‰åºåˆ°ååº"></a></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// å‰åºéå†é¡ºåºï¼šä¸­-å·¦-å³ï¼Œå…¥æ ˆé¡ºåºï¼šä¸­-å³-å·¦</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ä¸­åºéå†é¡ºåº: å·¦-ä¸­-å³ å…¥æ ˆé¡ºåºï¼š å·¦-å³</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        while (cur != null || !stack.isEmpty())&#123;</span><br><span class="line">           if (cur != null)&#123; </span><br><span class="line">           // Continuing the traversal of the left nodes </span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">           // reached the end of the root node</span><br><span class="line">           // add value into the result </span><br><span class="line">               cur = stack.pop();</span><br><span class="line">               result.add(cur.val);</span><br><span class="line">               cur = cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ååºéå†é¡ºåº å·¦-å³-ä¸­ å…¥æ ˆé¡ºåºï¼šä¸­-å·¦-å³ å‡ºæ ˆé¡ºåºï¼šä¸­-å³-å·¦ï¼Œ æœ€åç¿»è½¬ç»“æœ</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.left != null)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right != null)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Level-order-traversal"><a href="#Level-order-traversal" class="headerlink" title="Level-order traversal"></a>Level-order traversal</h2><ol>
<li><p>å…ˆæä¸ªqueï¼ŒæŠŠrootåŠ åˆ°queé‡Œé¢</p>
</li>
<li><p>whileï¼ˆqueçš„é•¿åº¦ä¸ä¸º0ï¼‰</p>
<p>è®°å½•ä¸‹queçš„é•¿åº¦ï¼Œè¿™å°±æ˜¯è¿™ä¸€æ’çš„å…ƒç´ ä¸ªæ•°</p>
<p>æŒ¨ç€æŠŠqueçš„å…ƒç´ åŠ åˆ°resé‡Œé¢å»ï¼ŒåŠ è¿›å»ä¸€ä¸ªçš„åŒæ—¶æŠŠè¿™ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹åŠ å…¥åˆ°queé‡Œé¢å»ã€‚</p>
</li>
</ol>
<h4 id="implement-breadth-first-traversal-level-order-traversal-of-a-binary-tree-using-a-queue"><a href="#implement-breadth-first-traversal-level-order-traversal-of-a-binary-tree-using-a-queue" class="headerlink" title="implement breadth-first traversal (level-order traversal) of a binary tree using a queue."></a>implement breadth-first traversal (level-order traversal) of a binary tree using a queue.</h4><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/919d39fe06ad2477c184566959d71de2394c53628d4d7a2cc858087a3a1d113b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3130322545342542412538432545352538462538392545362541302539312545372539412538342545352542312538322545352542412538462545392538312538442545352538452538362e676966"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/919d39fe06ad2477c184566959d71de2394c53628d4d7a2cc858087a3a1d113b/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3130322545342542412538432545352538462538392545362541302539312545372539412538342545352542312538322545352542412538462545392538312538442545352538452538362e676966" alt="102äºŒå‰æ ‘çš„å±‚åºéå†"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 102.äºŒå‰æ ‘çš„å±‚åºéå†</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        //checkFun01(root,0);</span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        return resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //DFS--é€’å½’æ–¹å¼</span><br><span class="line">    public void checkFun01(TreeNode node, Integer deep) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        if (resList.size() &lt; deep) &#123;</span><br><span class="line">            //å½“å±‚çº§å¢åŠ æ—¶ï¼Œlistçš„Itemä¹Ÿå¢åŠ ï¼Œåˆ©ç”¨listçš„ç´¢å¼•å€¼è¿›è¡Œå±‚çº§ç•Œå®š</span><br><span class="line">            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        resList.get(deep - 1).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //BFS--è¿­ä»£æ–¹å¼--å€ŸåŠ©é˜Ÿåˆ—</span><br><span class="line">    public void checkFun02(TreeNode node) &#123;</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); //!!! </span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        while (!que.isEmpty()) &#123; //!!!!</span><br><span class="line">        	// new level</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); //!!!!</span><br><span class="line">            int len = que.size();</span><br><span class="line"></span><br><span class="line">            while (len &gt; 0) &#123;</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                if (tmpNode.left != null) que.offer(tmpNode.left);</span><br><span class="line">                if (tmpNode.right != null) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>my version: </p>
<ol start="102">
<li>Binary Tree Level Order Traversal</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        trav(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void trav(TreeNode node)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;(); // !!!LinkedList, cant be arraylist</span><br><span class="line">        que.offer(node);</span><br><span class="line">        while(!que.isEmpty())&#123; //que != null</span><br><span class="line">            int num = que.size(); // not length numç”¨æ¥è®°å½•æ¯ä¸€æ’æœ‰å‡ ä¸ªå…ƒç´ </span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">            //itemList ç”¨æ¥è®°å½•queé‡Œé¢é©¬ä¸Šè¦å‡ºæ¥çš„ä¸€æ’çš„nodes</span><br><span class="line">            while(num != 0)&#123;</span><br><span class="line">                TreeNode popNode = que.poll(); </span><br><span class="line">                itemList.add(popNode.val); //å‡†å¤‡å¥½itemlist</span><br><span class="line">                num--;</span><br><span class="line">                if(popNode.left != null)&#123; //æŠŠpollå‡ºå»çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹offerè¿›æ¥</span><br><span class="line">                    que.offer(popNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(popNode.right != null)&#123;</span><br><span class="line">                    que.offer(popNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //æŠŠitemListç»™åŠ åˆ°resé‡Œé¢</span><br><span class="line">            res.add(itemList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="que-x3D-x3D-null-VS-que-isEmpty"><a href="#que-x3D-x3D-null-VS-que-isEmpty" class="headerlink" title="que&#x3D;&#x3D;null VS. que.isEmpty()"></a>que&#x3D;&#x3D;null VS. que.isEmpty()</h4><ol>
<li><code>que.isEmpty()</code>: This is a method used to check if the queue is empty or not. The <code>isEmpty()</code> method is available in the <code>java.util.Queue</code> interface and is implemented by classes like <code>LinkedList</code> or <code>PriorityQueue</code>. It returns <code>true</code> if the queue has no elements, and <code>false</code> otherwise.</li>
</ol>
<p>Hereâ€™s an example of how to use <code>isEmpty()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class QueueExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // Adding elements to the queue</span><br><span class="line">        queue.offer(&quot;Element 1&quot;);</span><br><span class="line">        queue.offer(&quot;Element 2&quot;);</span><br><span class="line"></span><br><span class="line">        // Check if the queue is empty</span><br><span class="line">        if (queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;Queue is empty.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Queue is not empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>que == null</code>: This is a comparison that checks whether the reference <code>que</code> points to a valid queue object (i.e., not null). If <code>que</code> is a valid reference to a queue object, the comparison <code>que == null</code> will return <code>false</code>. If <code>que</code> is not pointing to any object (i.e., it is null), then the comparison will return <code>true</code>.</li>
</ol>
<p>Hereâ€™s an example of how to use the <code>que == null</code> comparison:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class QueueExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Queue&lt;String&gt; queue = null;</span><br><span class="line"></span><br><span class="line">        // Check if the queue reference is null</span><br><span class="line">        if (queue == null) &#123;</span><br><span class="line">            System.out.println(&quot;Queue reference is null.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Queue reference is not null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this example, we initialize the <code>queue</code> variable to <code>null</code> and then use the <code>que == null</code> comparison to check if the reference is null.</p>
<p>Remember that <code>isEmpty()</code> is used to check if the queue has no elements, while <code>que == null</code> is used to check if the reference to the queue object is null.</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><ol>
<li><p><strong>Initialization</strong>: To create an <code>ArrayList</code>, you can use the following syntax:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;Type&gt; listName = new ArrayList&lt;Type&gt;();</span><br></pre></td></tr></table></figure>

<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Adding Elements</strong>: You can add elements to an <code>ArrayList</code> using the <code>add</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers.add(10);</span><br><span class="line">numbers.add(20);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Accessing Elements</strong>: You can access elements by their index using the <code>get</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int element = numbers.get(0); // Retrieves the first element</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Removing Elements</strong>: You can remove elements by index or by value using the <code>remove</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers.remove(0); // Removes the first element</span><br><span class="line">numbers.remove(Integer.valueOf(20)); // Removes the first occurrence of the value 20</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Checking Size</strong>: You can find the size (number of elements) in an ArrayList using the <code>size</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int size = numbers.size();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Checking if Empty</strong>: You can check if an <code>ArrayList</code> is empty using the <code>isEmpty</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean isEmpty = numbers.isEmpty();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Iterating</strong>: You can iterate through the elements of an <code>ArrayList</code> using various loops, such as <code>for-each</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Integer number : numbers) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Clearing</strong>: You can remove all elements from an <code>ArrayList</code> using the <code>clear</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numbers.clear();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Checking for Existence</strong>: You can check if an element exists in the <code>ArrayList</code> using the <code>contains</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean contains = numbers.contains(10);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Converting to an Array</strong>: You can convert an <code>ArrayList</code> to an array using the <code>toArray</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Integer[] numberArray = numbers.toArray(new Integer[0]);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Sorting</strong>: You can sort an <code>ArrayList</code> using the <code>Collections.sort</code> method:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Collections.sort(numbers);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">107. Binary Tree Level Order Traversal II</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        level(res, root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; res.size()/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; temp  = res.get(i);</span><br><span class="line">            res.set( i, res.get(res.size()-i-<span class="number">1</span>)); <span class="comment">//notice -1</span></span><br><span class="line">            res.set(res.size() - i -<span class="number">1</span>, temp);  <span class="comment">//notice -1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">        for (int i = res.size() - 1; i &gt;= 0; i-- ) &#123;</span></span><br><span class="line"><span class="comment">            result.add(res.get(i));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">level</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode  root)</span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                level.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    que.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">or:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(num &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                row.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>)que.offer(temp.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">199. Binary Tree Right Side View</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">       if( root == null) return res;</span><br><span class="line">       Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">       que.offer(root);</span><br><span class="line"></span><br><span class="line">       while(!que.isEmpty())&#123;</span><br><span class="line">           int num = que.size();</span><br><span class="line">           while(num!=0)&#123;</span><br><span class="line">               TreeNode temp = que.poll();</span><br><span class="line">               </span><br><span class="line">               if(temp.left != null)</span><br><span class="line">                que.offer(temp.left);</span><br><span class="line">               if(temp.right != null)</span><br><span class="line">                que.offer(temp.right);</span><br><span class="line">            </span><br><span class="line">                if(num == 1)&#123;</span><br><span class="line">                    res.add(temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                num--;  // need to put num-1 after num ==1</span><br><span class="line">           &#125;</span><br><span class="line">       </span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="637-Average-of-Levels-in-Binary-Tree"><a href="#637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="637. Average of Levels in Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/average-of-levels-in-binary-tree/">637. Average of Levels in Binary Tree</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class="line">        List&lt;Double&gt; res = new ArrayList&lt;Double&gt;();</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            double mark = num;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            while ( num != 0)&#123;</span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                sum += temp.val;</span><br><span class="line">                num--;</span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(sum/mark);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="429-N-ary-Tree-Level-Order-Traversal"><a href="#429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="429. N-ary Tree Level Order Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/">429. N-ary Tree Level Order Traversal</a></h3><p>Given an n-ary tree, return the <em>level order</em> traversal of its nodesâ€™ values.</p>
<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,3,2,4,null,5,6]</span><br><span class="line">Output: [[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                Node temp = que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                for(Node child: temp.children)&#123;  //!!!</span><br><span class="line">                    que.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">515. Find Largest Value in Each Tree Row</a></h3><p>Given the <code>root</code> of a binary tree, return <em>an array of the largest value in each row</em> of the tree <strong>(0-indexed)</strong>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,3,2,5,3,null,9]</span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            </span><br><span class="line">            int big = Integer.MIN_VALUE;</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                </span><br><span class="line">                big = Math.max(big, temp.val);</span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(big);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></h3><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        Queue&lt;Node&gt; que = new LinkedList&lt;Node&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            Queue&lt;Node&gt; Itemlist = new LinkedList&lt;Node&gt;();</span><br><span class="line">            while(num != 0)&#123;</span><br><span class="line">                Node temp = que.poll();  </span><br><span class="line">                Itemlist.add(temp);       </span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">                </span><br><span class="line">                num--; </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            while(Itemlist.size() &gt; 1)&#123; // &gt;1 not &gt;0</span><br><span class="line"></span><br><span class="line">                Node temp = Itemlist.poll();</span><br><span class="line">                Node tempnext = Itemlist.peek(); // cant poll, only peek.</span><br><span class="line">                </span><br><span class="line">                temp.next = tempnext;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return root;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//second try:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root ==null) return root;</span><br><span class="line">        Queue&lt;Node&gt; que = new LinkedList&lt;&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(que.size() &gt; 0)&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            List&lt;Node&gt; record = new ArrayList&lt;&gt;();</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                Node temp = que.poll();</span><br><span class="line">                if(temp.left!= null) que.add(temp.left); </span><br><span class="line">                if(temp.right!= null) que.add(temp.right);</span><br><span class="line">                record.add(temp);</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(record.size() == 1)&#123;</span><br><span class="line">                record.get(0).next = null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                for( int i = 0 ; i &lt; record.size() - 1; i++)&#123;</span><br><span class="line">                    Node first = record.get(i);</span><br><span class="line">                    Node second = record.get(i+1);</span><br><span class="line">                    first.next = second;</span><br><span class="line">                &#125;</span><br><span class="line">                record.get(record.size() - 1).next = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></h3><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3,6,9]</span><br><span class="line">Output: [4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p>æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹é€’å½’ä¸‰éƒ¨æ›²ï¼š</p>
<ol>
<li>ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼</li>
</ol>
<p>å‚æ•°å°±æ˜¯è¦ä¼ å…¥èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œä¸éœ€è¦å…¶ä»–å‚æ•°äº†ï¼Œé€šå¸¸æ­¤æ—¶å®šä¸‹æ¥ä¸»è¦å‚æ•°ï¼Œå¦‚æœåœ¨å†™é€’å½’çš„é€»è¾‘ä¸­å‘ç°è¿˜éœ€è¦å…¶ä»–å‚æ•°çš„æ—¶å€™ï¼Œéšæ—¶è¡¥å……ã€‚</p>
<p>è¿”å›å€¼çš„è¯å…¶å®ä¹Ÿä¸éœ€è¦ï¼Œä½†æ˜¯é¢˜ç›®ä¸­ç»™å‡ºçš„è¦è¿”å›rootèŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨é¢˜ç›®å®šä¹‰å¥½çš„å‡½æ•°ï¼Œæ‰€ä»¥å°±å‡½æ•°çš„è¿”å›ç±»å‹ä¸º<code>TreeNode*</code>ã€‚</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* invertTree(TreeNode* root)</span><br></pre></td></tr></table></figure>

<p>2.ç¡®å®šç»ˆæ­¢æ¡ä»¶</p>
<p>å½“å‰èŠ‚ç‚¹ä¸ºç©ºçš„æ—¶å€™ï¼Œå°±è¿”å›</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) return root;</span><br></pre></td></tr></table></figure>

<p>3.ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘</p>
<p>å› ä¸ºæ˜¯å…ˆå‰åºéå†ï¼Œæ‰€ä»¥å…ˆè¿›è¡Œäº¤æ¢å·¦å³å­©å­èŠ‚ç‚¹ï¼Œç„¶ååè½¬å·¦å­æ ‘ï¼Œåè½¬å³å­æ ‘ã€‚</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swap(root-&gt;left, root-&gt;right);</span><br><span class="line">invertTree(root-&gt;left);</span><br><span class="line">invertTree(root-&gt;right);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        if(root == null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        swapChildren(root); //preorder</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        // cant put swapChildren in the middle</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        // swapChildren(root); postorder</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swapChildren(TreeNode node)&#123;</span><br><span class="line">        TreeNode temp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// this also works</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        if(root.left != null || root.right != null)&#123;</span><br><span class="line">            TreeNode temp = root.left;</span><br><span class="line">            root.left = root.right;</span><br><span class="line">            root.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right != null) invertTree(root.right); // the order of here doesn&#x27;t matter!</span><br><span class="line">        if(root.left != null) invertTree(root.left);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//BFS</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;return null;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        while (!deque.isEmpty()) &#123;</span><br><span class="line">            int size = deque.size();</span><br><span class="line">            while (size-- &gt; 0) &#123;</span><br><span class="line">                TreeNode node = deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                if (node.left != null) deque.offer(node.left);</span><br><span class="line">                if (node.right != null) deque.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swap(TreeNode root) &#123;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//secodn try:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        if(root.left != null &amp;&amp; root.right != null)&#123;</span><br><span class="line">            TreeNode temp = root.left;</span><br><span class="line">            root.left = root.right;</span><br><span class="line">            root.right = temp;</span><br><span class="line">            invertTree( root.left );</span><br><span class="line">            invertTree( root.right );</span><br><span class="line">        &#125;else if(root.right != null &amp;&amp; root.left == null)&#123;</span><br><span class="line">            root.left = root.right;</span><br><span class="line">            root.right = null;</span><br><span class="line">            invertTree(root.left);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = null;</span><br><span class="line">            invertTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">å…¶å®ä¸Šé¢é‚£ä¸ªæ˜¯ç­‰äºè¿™æ ·å†™</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">       </span><br><span class="line">            TreeNode temp = root.left;</span><br><span class="line">            root.left = root.right;</span><br><span class="line">            root.right = temp;</span><br><span class="line">            invertTree( root.left );</span><br><span class="line">            invertTree( root.right );</span><br><span class="line">       </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">101. Symmetric Tree</a></h3><p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> compare(root.left,root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) || (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outside&amp;&amp;inside;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//second try: wrong</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left.val == root.right.val)&#123;</span><br><span class="line">                isSymmetric(root.left);</span><br><span class="line">                isSymmetric(root.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md</a></p>
<ol>
<li>ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool compare(TreeNode* left, TreeNode* right)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ç¡®å®šç»ˆæ­¢æ¡ä»¶</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if((left != null &amp;&amp; right == null) || (left == null &amp;&amp; right != null) )&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">if(left == null &amp;&amp; right == null)&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">if(left != null &amp;&amp; right != null)&#123;</span><br><span class="line">    if(left.val != right.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean outside = compare(left.left, right.right);</span><br><span class="line">boolean inside = compare(left.right, right.left);</span><br><span class="line">return outside&amp;&amp;inside;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/same-tree/">100. Same Tree</a></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: p = [1,2,3], q = [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(p, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(right != <span class="literal">null</span> &amp;&amp; left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right.val != left.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftc</span> <span class="operator">=</span> compare(left.left, right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightc</span> <span class="operator">=</span> compare(left.right, right.right);</span><br><span class="line">        <span class="keyword">return</span> leftc&amp;&amp;rightc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h3><h2 id="treeâ€™s-height-VS-treeâ€™s-depth"><a href="#treeâ€™s-height-VS-treeâ€™s-depth" class="headerlink" title="treeâ€™s height VS. treeâ€™s depth:"></a>treeâ€™s height VS. treeâ€™s depth:</h2><p>tutorialï¼š <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Gd4y1V75u/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1Gd4y1V75u/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p>
<ul>
<li>The â€œdepthâ€ of a node is measured from the root to the node.</li>
<li>The â€œheightâ€ of a node is measured from the node to a leaf.</li>
</ul>
<p><strong>é«˜åº¦ï¼ˆğŸ‘†ï¼‰ï¼š ååºéå†</strong>  (easier)</p>
<p><strong>æ·±åº¦ï¼ˆğŸ‘‡ï¼‰ï¼š å‰åºéå†</strong></p>
<p><strong><span style="color: red">æ ¹èŠ‚ç‚¹çš„é«˜åº¦å°±æ˜¯äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦</span></strong></p>
<p>æœ¬é¢˜å¯ä»¥ä½¿ç”¨å‰åºï¼ˆä¸­å·¦å³ï¼‰ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ååºéå†ï¼ˆå·¦å³ä¸­ï¼‰ï¼Œä½¿ç”¨å‰åºæ±‚çš„å°±æ˜¯æ·±åº¦ï¼Œä½¿ç”¨ååºæ±‚çš„æ˜¯é«˜åº¦ã€‚</p>
<ul>
<li>äºŒå‰æ ‘èŠ‚ç‚¹çš„æ·±åº¦ï¼šæŒ‡ä»<strong>æ ¹èŠ‚ç‚¹</strong>åˆ°è¯¥èŠ‚ç‚¹çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°æˆ–è€…èŠ‚ç‚¹æ•°ï¼ˆå–å†³äºæ·±åº¦ä»0å¼€å§‹è¿˜æ˜¯ä»1å¼€å§‹ï¼‰</li>
<li>äºŒå‰æ ‘èŠ‚ç‚¹çš„é«˜åº¦ï¼šæŒ‡ä»è¯¥èŠ‚ç‚¹åˆ°<strong>å¶å­èŠ‚ç‚¹</strong>çš„æœ€é•¿ç®€å•è·¯å¾„è¾¹çš„æ¡æ•°æˆ–è€…èŠ‚ç‚¹æ•°ï¼ˆå–å†³äºé«˜åº¦ä»0å¼€å§‹è¿˜æ˜¯ä»1å¼€å§‹ï¼‰</li>
</ul>
<p><strong>è€Œæ ¹èŠ‚ç‚¹çš„é«˜åº¦å°±æ˜¯äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦</strong>ï¼Œæ‰€ä»¥æœ¬é¢˜ä¸­æˆ‘ä»¬é€šè¿‡ååºæ±‚çš„æ ¹èŠ‚ç‚¹é«˜åº¦æ¥æ±‚çš„äºŒå‰æ ‘æœ€å¤§æ·±åº¦ã€‚</p>
<ul>
<li>WAY1 post-order traversal:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        å·¦<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        å³<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        ä¸­<span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;  <span class="comment">// æ³¨æ„è¦+1ï¼Œ è¿™æ˜¯å½“å‰èŠ‚ç‚¹çš„é«˜åº¦</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼šå‚æ•°å°±æ˜¯ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›å°±è¿”å›è¿™æ£µæ ‘çš„æ·±åº¦ï¼Œæ‰€ä»¥è¿”å›å€¼ä¸ºintç±»å‹ã€‚</li>
</ol>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getdepth(TreeNode* node)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼šå¦‚æœä¸ºç©ºèŠ‚ç‚¹çš„è¯ï¼Œå°±è¿”å›0ï¼Œè¡¨ç¤ºé«˜åº¦ä¸º0ã€‚</li>
</ol>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (node == NULL) return 0;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘ï¼šå…ˆæ±‚å®ƒçš„å·¦å­æ ‘çš„æ·±åº¦ï¼Œå†æ±‚å³å­æ ‘çš„æ·±åº¦ï¼Œæœ€åå–å·¦å³æ·±åº¦æœ€å¤§çš„æ•°å€¼ å†+1 ï¼ˆåŠ 1æ˜¯å› ä¸ºç®—ä¸Šå½“å‰ä¸­é—´èŠ‚ç‚¹ï¼‰å°±æ˜¯ç›®å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘çš„æ·±åº¦ã€‚</li>
</ol>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int left = maxDepth(root.left);</span><br><span class="line">int right = maxDepth(root.right);</span><br><span class="line">return Math.max(left, right) + 1;</span><br></pre></td></tr></table></figure>

<ul>
<li>WAY2: å±‚åºéå†</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int layer = 0;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(!que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            layer++;</span><br><span class="line">            while(num != 0)&#123;</span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                num --;</span><br><span class="line">                if(temp.left!=null)que.add(temp.left);</span><br><span class="line">                if(temp.right!=null)que.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return layer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>WAY3: pre-order traversal:(COMPLICATED, SO HAVENT READ)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int result;</span><br><span class="line">    void getdepth(TreeNode* node, int depth) &#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; // ä¸­</span><br><span class="line"></span><br><span class="line">        if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) return ;</span><br><span class="line"></span><br><span class="line">        if (node-&gt;left) &#123; // å·¦</span><br><span class="line">            depth++;    // æ·±åº¦+1</span><br><span class="line">            getdepth(node-&gt;left, depth);</span><br><span class="line">            depth--;    // å›æº¯ï¼Œæ·±åº¦-1</span><br><span class="line">        &#125;</span><br><span class="line">        if (node-&gt;right) &#123; // å³</span><br><span class="line">            depth++;    // æ·±åº¦+1</span><br><span class="line">            getdepth(node-&gt;right, depth);</span><br><span class="line">            depth--;    // å›æº¯ï¼Œæ·±åº¦-1</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        result = 0;</span><br><span class="line">        if (root == NULL) return result;</span><br><span class="line">        getdepth(root, 1);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">  /**</span><br><span class="line">   * é€’å½’æ³•(æ±‚æ·±åº¦æ³•)</span><br><span class="line">   */</span><br><span class="line">    //å®šä¹‰æœ€å¤§æ·±åº¦</span><br><span class="line">    int maxnum = 0;</span><br><span class="line"></span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        ans(root,0);</span><br><span class="line">        return maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //é€’å½’æ±‚è§£æœ€å¤§æ·±åº¦</span><br><span class="line">    void ans(TreeNode tr,int tmp)&#123;</span><br><span class="line">        if(tr==null) return;</span><br><span class="line">        tmp++;</span><br><span class="line">        maxnum = maxnum&lt;tmp?tmp:maxnum;</span><br><span class="line">        ans(tr.left,tmp);</span><br><span class="line">        ans(tr.right,tmp);</span><br><span class="line">        tmp--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>second try: (recursive loop)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        return count(root, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public int count(TreeNode node, int level)&#123;</span><br><span class="line">        if(node == null) return level;</span><br><span class="line">        return Math.max(count(node.left, level+1),count(node.right, level+1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/">559. Maximum Depth of N-ary Tree</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(Node root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        int max = 0;</span><br><span class="line">        for(Node child: root.children)&#123;</span><br><span class="line">            max = Math.max(max, maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        return max+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">111. Minimum Depth of Binary Tree</a></h3><p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>



<p>æœ€å¤§æ·±åº¦å¾ˆå®¹æ˜“ç†è§£ï¼Œæœ€å°æ·±åº¦å°±ä¸é‚£ä¹ˆå¥½ç†è§£ï¼Œå¦‚å›¾ï¼š</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/25083ce0b681f3c15cea3ccdab01aa379bd4f2ca5e562137e94273746565cd7c/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3131312e2545342542412538432545352538462538392545362541302539312545372539412538342545362539432538302545352542302538462545362542372542312545352542412541362e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/25083ce0b681f3c15cea3ccdab01aa379bd4f2ca5e562137e94273746565cd7c/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3131312e2545342542412538432545352538462538392545362541302539312545372539412538342545362539432538302545352542302538462545362542372542312545352542412541362e706e67" alt="111.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="comment">//å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œå³å­æ ‘ä¸ä¸ºç©ºï¼Œè¯´æ˜æœ€å°æ·±åº¦æ˜¯ 1 + å³å­æ ‘çš„æ·±åº¦ã€‚</span></span><br><span class="line"><span class="comment">//åä¹‹ï¼Œå³å­æ ‘ä¸ºç©ºï¼Œå·¦å­æ ‘ä¸ä¸ºç©ºï¼Œæœ€å°æ·±åº¦æ˜¯ 1 + å·¦å­æ ‘çš„æ·±åº¦ã€‚ æœ€åå¦‚æœå·¦å³å­æ ‘éƒ½ä¸ä¸ºç©ºï¼Œè¿”å›å·¦å³å­æ ‘æ·±åº¦æœ€å°å€¼ + 1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> )   !!!!!!!!!!!!</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span>;    !!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="literal">null</span> )  !!!!!!!!!!!!</span><br><span class="line">            <span class="keyword">return</span>  left + <span class="number">1</span>;    !!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * è¿­ä»£æ³•ï¼Œå±‚åºéå†</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                <span class="keyword">if</span> (poll.left == <span class="literal">null</span> &amp;&amp; poll.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// æ˜¯å¶å­ç»“ç‚¹ï¼Œç›´æ¥è¿”å›depthï¼Œå› ä¸ºä»ä¸Šå¾€ä¸‹éå†ï¼Œæ‰€ä»¥è¯¥å€¼å°±æ˜¯æœ€å°å€¼</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    deque.offer(poll.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    deque.offer(poll.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>second try:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//wrong:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        if(root.left == null) return count(root.right) + 1;</span><br><span class="line">        if(root.right == null) return count(root.left) + 1;</span><br><span class="line">        return Math.min(count(root.left),count(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">    public int count(TreeNode node)&#123;</span><br><span class="line">        if(node == null) return 0;</span><br><span class="line">        return Math.min(count(node.left) , count(node.right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h3><p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>
<p>According to <strong><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2h</code> nodes inclusive at the last level <code>h</code>.</p>
<p>Design an algorithm that runs in less than <code>O(n)</code> time complexity.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p>é€’å½’éå†çš„é¡ºåºä¾ç„¶æ˜¯ååºï¼ˆå·¦å³ä¸­ï¼‰:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        int left = countNodes(root.left) ;</span><br><span class="line">        int right = countNodes(root.right) ;</span><br><span class="line">        return left + right + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<pre><code>    int left = countNodes(root.left)+1 ; 
  
    int right = countNodes(root.right)+1 ;
     
    return left + right;
    
    è¿™æ ·çš„è¯ï¼Œç›¸å½“äºä¸Šä¸€å±‚çš„é‚£ä¸ªèŠ‚ç‚¹è¢«åŠ äº†ä¸¤æ¬¡ã€‚
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//second try wrong:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        if(root.left != null) return countNodes(root.left) + 1;</span><br><span class="line">        if(root.right != null) return countNodes(root.right) + 1;</span><br><span class="line">        </span><br><span class="line">        return  countNodes(root.left) + countNodes(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>WAY2: COMPLETE BINARY TREE </p>
<p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.md</a></p>
<p>vedio -&gt; <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eW4y1B7pD/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1eW4y1B7pD/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * é’ˆå¯¹å®Œå…¨äºŒå‰æ ‘çš„è§£æ³•</span><br><span class="line">     *</span><br><span class="line">     * æ»¡äºŒå‰æ ‘çš„ç»“ç‚¹æ•°ä¸ºï¼š2^depth - 1</span><br><span class="line">     */</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        int leftDepth = 0, rightDepth = 0; // è¿™é‡Œåˆå§‹ä¸º0æ˜¯æœ‰ç›®çš„çš„ï¼Œä¸ºäº†ä¸‹é¢æ±‚æŒ‡æ•°æ–¹ä¾¿</span><br><span class="line">        while (left != null) &#123;  // æ±‚å·¦å­æ ‘æ·±åº¦</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        while (right != null) &#123; // æ±‚å³å­æ ‘æ·±åº¦</span><br><span class="line">            right = right.right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (leftDepth == rightDepth) &#123;</span><br><span class="line">            return (2 &lt;&lt; leftDepth) - 1; // æ³¨æ„(2&lt;&lt;1) ç›¸å½“äº2^2ï¼Œæ‰€ä»¥leftDepthåˆå§‹ä¸º0</span><br><span class="line">        &#125;</span><br><span class="line">        return countNodes(root.left) + countNodes(root.right) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">110. Balanced Binary Tree</a></h3><p>Given a binary tree, determine if it is <strong>height-balanced</strong></p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>A balanced binary tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the <strong>height</strong> of <strong>the left and right subtree of  <span style = "color : red">any node</span></strong> differ by not more than 1.</p>
<p>wrong version:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> min(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> max(root);</span><br><span class="line">        <span class="keyword">if</span>(max - min &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> min(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> min(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> max(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> max(node.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, there are a few issues with the provided code:</p>
<ol>
<li>The recursive calls to <code>isBalanced</code> inside the if condition are not returning the result. Instead, they are being called, but the result is not being used or returned.</li>
<li>The calculation of height in the methods <code>countLef</code> and <code>countRig</code> seems incorrect, as it simply returns the count of nodes in the left and right subtrees, respectively, rather than the height of the subtrees.</li>
</ol>
<p>right version:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// class Solution &#123;</span><br><span class="line">//     public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">//         if(root == null) return true;</span><br><span class="line"></span><br><span class="line">//         if(countLef(root) - countRig(root) &lt;= 1) &#123;</span><br><span class="line">//             isBalanced(root.left);</span><br><span class="line">//             isBalanced(root.right);</span><br><span class="line">//         &#125;else&#123;</span><br><span class="line">//             return false;</span><br><span class="line">//         &#125;</span><br><span class="line">//         return true;</span><br><span class="line">        </span><br><span class="line">//     &#125;</span><br><span class="line">//     public int countLef(TreeNode node)&#123;</span><br><span class="line">//         if(node == null) return 0;</span><br><span class="line">//         int left = countLef(node.left);</span><br><span class="line">//         return left + 1;</span><br><span class="line">//     &#125;</span><br><span class="line">//     public int countRig(TreeNode node)&#123;</span><br><span class="line">//         if(node == null) return 0;</span><br><span class="line">//         int right = countRig(node.right);</span><br><span class="line">//         return right + 1;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftHeight = height(root.left);</span><br><span class="line">        int rightHeight = height(root.right);</span><br><span class="line"></span><br><span class="line">        if (Math.abs(leftHeight - rightHeight) &lt;= 1) &#123;</span><br><span class="line">            // Check if both left and right subtrees are balanced</span><br><span class="line">            return isBalanced(root.left) &amp;&amp; isBalanced(root.right); !!!!!!!!!!!!</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int height(TreeNode node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Compute the height of the left and right subtrees</span><br><span class="line">        int leftHeight = height(node.left);</span><br><span class="line">        int rightHeight = height(node.right);</span><br><span class="line"></span><br><span class="line">        // Return the maximum height plus 1 (to account for the current node)</span><br><span class="line">        return Math.max(leftHeight, rightHeight) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>!!!!!!!!!!!!!!!!!!!!!!104!!!!!!!!åœ¨<a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦</a>ä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å±‚åºéå†æ¥æ±‚æ·±åº¦ï¼Œä½†æ˜¯å°±ä¸èƒ½ç›´æ¥ç”¨å±‚åºéå†æ¥æ±‚é«˜åº¦äº†ï¼Œè¿™å°±ä½“ç°å‡ºæ±‚é«˜åº¦å’Œæ±‚æ·±åº¦çš„ä¸åŒã€‚!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>
<h3 id="é€’å½’"><a href="#é€’å½’" class="headerlink" title="é€’å½’"></a><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.md#%E9%80%92%E5%BD%92">é€’å½’</a></h3><p>æ­¤æ—¶å¤§å®¶åº”è¯¥æ˜ç™½äº†æ—¢ç„¶è¦æ±‚æ¯”è¾ƒé«˜åº¦ï¼Œå¿…ç„¶æ˜¯è¦<strong>ååºéå†</strong>ã€‚</p>
<p>é€’å½’ä¸‰æ­¥æ›²åˆ†æï¼š</p>
<ol>
<li>æ˜ç¡®é€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼</li>
</ol>
<p>å‚æ•°ï¼šå½“å‰ä¼ å…¥èŠ‚ç‚¹ã€‚ è¿”å›å€¼ï¼šä»¥å½“å‰ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘çš„é«˜åº¦ã€‚</p>
<p>é‚£ä¹ˆå¦‚ä½•æ ‡è®°å·¦å³å­æ ‘æ˜¯å¦å·®å€¼å¤§äº1å‘¢ï¼Ÿ</p>
<p>å¦‚æœå½“å‰ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘å·²ç»ä¸æ˜¯äºŒå‰å¹³è¡¡æ ‘äº†ï¼Œè¿˜è¿”å›é«˜åº¦çš„è¯å°±æ²¡æœ‰æ„ä¹‰äº†ã€‚</p>
<p>æ‰€ä»¥å¦‚æœå·²ç»ä¸æ˜¯äºŒå‰å¹³è¡¡æ ‘äº†ï¼Œå¯ä»¥è¿”å›-1 æ¥æ ‡è®°å·²ç»ä¸ç¬¦åˆå¹³è¡¡æ ‘çš„è§„åˆ™äº†ã€‚</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// -1 è¡¨ç¤ºå·²ç»ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘äº†ï¼Œå¦åˆ™è¿”å›å€¼æ˜¯ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹æ ‘çš„é«˜åº¦</span><br><span class="line">int getHeight(TreeNode* node)</span><br></pre></td></tr></table></figure>



<ol>
<li>æ˜ç¡®ç»ˆæ­¢æ¡ä»¶</li>
</ol>
<p>é€’å½’çš„è¿‡ç¨‹ä¸­ä¾ç„¶æ˜¯é‡åˆ°ç©ºèŠ‚ç‚¹äº†ä¸ºç»ˆæ­¢ï¼Œè¿”å›0ï¼Œè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘é«˜åº¦ä¸º0</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (node == NULL) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>æ˜ç¡®å•å±‚é€’å½’çš„é€»è¾‘</li>
</ol>
<p>å¦‚ä½•åˆ¤æ–­ä»¥å½“å‰ä¼ å…¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘å‘¢ï¼Ÿå½“ç„¶æ˜¯å…¶å·¦å­æ ‘é«˜åº¦å’Œå…¶å³å­æ ‘é«˜åº¦çš„å·®å€¼ã€‚</p>
<p>åˆ†åˆ«æ±‚å‡ºå…¶å·¦å³å­æ ‘çš„é«˜åº¦ï¼Œç„¶åå¦‚æœå·®å€¼å°äºç­‰äº1ï¼Œåˆ™è¿”å›å½“å‰äºŒå‰æ ‘çš„é«˜åº¦ï¼Œå¦åˆ™è¿”å›-1ï¼Œè¡¨ç¤ºå·²ç»ä¸æ˜¯äºŒå‰å¹³è¡¡æ ‘äº†ã€‚</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int leftHeight = getHeight(node-&gt;left); // å·¦</span><br><span class="line">if (leftHeight == -1) return -1;</span><br><span class="line">int rightHeight = getHeight(node-&gt;right); // å³</span><br><span class="line">if (rightHeight == -1) return -1;</span><br><span class="line"></span><br><span class="line">int result;</span><br><span class="line">if (abs(leftHeight - rightHeight) &gt; 1) &#123;  // ä¸­</span><br><span class="line">    result = -1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    result = 1 + max(leftHeight, rightHeight); // ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„æ ‘çš„æœ€å¤§é«˜åº¦</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br></pre></td></tr></table></figure>



<p>ä»£ç ç²¾ç®€ä¹‹åå¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int leftHeight = getHeight(node-&gt;left);</span><br><span class="line">if (leftHeight == -1) return -1;</span><br><span class="line">int rightHeight = getHeight(node-&gt;right);</span><br><span class="line">if (rightHeight == -1) return -1;</span><br><span class="line">return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight);</span><br></pre></td></tr></table></figure>



<p>æ­¤æ—¶é€’å½’çš„å‡½æ•°å°±å·²ç»å†™å‡ºæ¥äº†ï¼Œè¿™ä¸ªé€’å½’çš„å‡½æ•°ä¼ å…¥èŠ‚ç‚¹æŒ‡é’ˆï¼Œè¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„äºŒå‰æ ‘çš„é«˜åº¦ï¼Œå¦‚æœä¸æ˜¯äºŒå‰å¹³è¡¡æ ‘ï¼Œåˆ™è¿”å›-1ã€‚</p>
<p>getHeightæ•´ä½“ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int getHeight(TreeNode* node) &#123;</span><br><span class="line">    if (node == NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int leftHeight = getHeight(node-&gt;left);</span><br><span class="line">    if (leftHeight == -1) return -1;</span><br><span class="line">    int rightHeight = getHeight(node-&gt;right);</span><br><span class="line">    if (rightHeight == -1) return -1;</span><br><span class="line">    return abs(leftHeight - rightHeight) &gt; 1 ? -1 : 1 + max(leftHeight, rightHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>æœ€åæœ¬é¢˜æ•´ä½“é€’å½’ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">   /**</span><br><span class="line">     * é€’å½’æ³•</span><br><span class="line">     */</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return getHeight(root) != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getHeight(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = getHeight(root.left);</span><br><span class="line">        if (leftHeight == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int rightHeight = getHeight(root.right);</span><br><span class="line">        if (rightHeight == -1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // å·¦å³å­æ ‘é«˜åº¦å·®å¤§äº1ï¼Œreturn -1è¡¨ç¤ºå·²ç»ä¸æ˜¯å¹³è¡¡æ ‘äº†</span><br><span class="line">        if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(leftHeight, rightHeight) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257. Binary Tree Paths"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-paths/">257. Binary Tree Paths</a></h3><p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,5]</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        deal(root, &quot;&quot;);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deal(TreeNode node, String s) &#123;</span><br><span class="line">        if(node == null ) return ;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line">            res.add(s + Integer.toString(node.val));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String tmp = s + Integer.toString(node.val)+&quot;-&gt;&quot;;</span><br><span class="line">        deal(node.left,tmp);</span><br><span class="line">        deal(node.right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//////////////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        deal(root, &quot;&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deal(TreeNode node, String s) &#123;</span><br><span class="line">        if (node == null)</span><br><span class="line">            return;</span><br><span class="line">        if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">            result.add(new StringBuilder(s).append(node.val).toString()); </span><br><span class="line">            //toString method converts StringBuider into String type.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String tmp = new StringBuilder(s).append(node.val).append(&quot;-&gt;&quot;).toString();</span><br><span class="line">        deal(node.left, tmp);</span><br><span class="line">        deal(node.right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//second try:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return res;</span><br><span class="line">        findPath(root, String.valueOf(root.val));</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void findPath(TreeNode node, String path)&#123;</span><br><span class="line">        // if(node == null)&#123;</span><br><span class="line">        //     res.add(path);</span><br><span class="line">        //     return;</span><br><span class="line">        // &#125;  //!!!!!!!!!!notice where went wrong</span><br><span class="line"></span><br><span class="line">         if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class="line">            // Leaf node, add the path to the result</span><br><span class="line">            res.add(path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(node.left != null)&#123;</span><br><span class="line">            findPath(node.left, path+ &quot;-&gt;&quot; + node.left.val);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right != null)&#123;</span><br><span class="line">            findPath(node.right, path+ &quot;-&gt;&quot; + node.right.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//å›æº¯ç®—æ³•ï¼ˆåŸå§‹ç®—æ³•ï¼Œç²¾ç®€ä¹‹å‰çš„ä»£ç ï¼‰è¾ƒéš¾</span><br><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * é€’å½’æ³•</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();// å­˜æœ€ç»ˆçš„ç»“æœ</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();// ä½œä¸ºç»“æœä¸­çš„è·¯å¾„</span><br><span class="line">        traversal(root, paths, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) &#123;</span><br><span class="line">        paths.add(root.val);// å‰åºéå†ï¼Œä¸­</span><br><span class="line">        // é‡åˆ°å¶å­ç»“ç‚¹</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">            // è¾“å‡º</span><br><span class="line">            StringBuilder sb = new StringBuilder();// StringBuilderç”¨æ¥æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œé€Ÿåº¦æ›´å¿«</span><br><span class="line">            for (int i = 0; i &lt; paths.size() - 1; i++) &#123;</span><br><span class="line">                sb.append(paths.get(i)).append(&quot;-&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - 1));// è®°å½•æœ€åä¸€ä¸ªèŠ‚ç‚¹</span><br><span class="line">            res.add(sb.toString());// æ”¶é›†ä¸€ä¸ªè·¯å¾„</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // é€’å½’å’Œå›æº¯æ˜¯åŒæ—¶è¿›è¡Œï¼Œæ‰€ä»¥è¦æ”¾åœ¨åŒä¸€ä¸ªèŠ±æ‹¬å·é‡Œ</span><br><span class="line">        if (root.left != null) &#123; // å·¦</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - 1);// å›æº¯</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.right != null) &#123; // å³</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - 1);// å›æº¯</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="404-Sum-of-Left-Leaves"><a href="#404-Sum-of-Left-Leaves" class="headerlink" title="404. Sum of Left Leaves"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-left-leaves/">404. Sum of Left Leaves</a></h3><p><strong>åˆ¤æ–­å½“å‰èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­æ˜¯æ— æ³•åˆ¤æ–­çš„ï¼Œå¿…é¡»è¦é€šè¿‡èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ¥åˆ¤æ–­å…¶å·¦å­©å­æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚</strong></p>
<p>å¦‚æœè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œè¯¥èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™æ‰¾åˆ°äº†ä¸€ä¸ªå·¦å¶å­</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> &#123; <span class="comment">//æ˜¯æŒ‡rootä»¥ä¸‹çš„èŠ‚ç‚¹ï¼Œæ»¡è¶³è¦æ±‚çš„sum</span></span><br><span class="line">        <span class="keyword">if</span> (root == NULL) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//æ˜¯å› ä¸ºroot.left å’Œroot.rightä»¥ä¸‹çš„å­èŠ‚ç‚¹çš„sumofleftleaves=0.ä¸åŒ…æ‹¬æœ¬å±‚çš„ã€‚</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftValue</span> <span class="operator">=</span> sumOfLeftLeaves(root-&gt;left);    <span class="comment">// å·¦</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// å·¦å­æ ‘å°±æ˜¯ä¸€ä¸ªå·¦å¶å­çš„æƒ…å†µ</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightValue</span> <span class="operator">=</span> sumOfLeftLeaves(root-&gt;right);  <span class="comment">// å³</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> leftValue + rightValue;               <span class="comment">// ä¸­</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;   <span class="comment">//not node.left right == null !!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// Return if the current node is null</span></span><br><span class="line">        &#125;                      !!!!!!!!!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            res += node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        sum(node.left);</span><br><span class="line">        sum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>é€’å½’ä¸‰éƒ¨æ›²ï¼š</p>
<ol>
<li>ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼</li>
</ol>
<p>åˆ¤æ–­ä¸€ä¸ªæ ‘çš„å·¦å¶å­èŠ‚ç‚¹ä¹‹å’Œï¼Œé‚£ä¹ˆä¸€å®šè¦ä¼ å…¥æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œé€’å½’å‡½æ•°çš„è¿”å›å€¼ä¸ºæ•°å€¼ä¹‹å’Œï¼Œæ‰€ä»¥ä¸ºint</p>
<p>ä½¿ç”¨é¢˜ç›®ä¸­ç»™å‡ºçš„å‡½æ•°å°±å¯ä»¥äº†ã€‚</p>
<ol>
<li>ç¡®å®šç»ˆæ­¢æ¡ä»¶</li>
</ol>
<p>å¦‚æœéå†åˆ°ç©ºèŠ‚ç‚¹ï¼Œé‚£ä¹ˆå·¦å¶å­å€¼ä¸€å®šæ˜¯0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) return 0;</span><br></pre></td></tr></table></figure>



<p>æ³¨æ„ï¼Œåªæœ‰å½“å‰éå†çš„èŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œæ‰èƒ½åˆ¤æ–­å…¶å­èŠ‚ç‚¹æ˜¯ä¸æ˜¯å·¦å¶å­ã€‚ æ‰€ä»¥å¦‚æœå½“å‰éå†çš„èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹ï¼Œé‚£å…¶å·¦å¶å­ä¹Ÿå¿…å®šæ˜¯0ï¼Œé‚£ä¹ˆç»ˆæ­¢æ¡ä»¶ä¸ºï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) return 0;</span><br><span class="line">if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; //å…¶å®è¿™ä¸ªä¹Ÿå¯ä»¥ä¸å†™ï¼Œå¦‚æœä¸å†™ä¸å½±å“ç»“æœï¼Œä½†å°±ä¼šè®©é€’å½’å¤šè¿›è¡Œäº†ä¸€å±‚ã€‚</span><br></pre></td></tr></table></figure>



<ol>
<li>ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘</li>
</ol>
<p>å½“é‡åˆ°å·¦å¶å­èŠ‚ç‚¹çš„æ—¶å€™ï¼Œè®°å½•æ•°å€¼ï¼Œç„¶åé€šè¿‡é€’å½’æ±‚å–å·¦å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œå’Œ å³å­æ ‘å·¦å¶å­ä¹‹å’Œï¼Œç›¸åŠ ä¾¿æ˜¯æ•´ä¸ªæ ‘çš„å·¦å¶å­ä¹‹å’Œã€‚</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">second try:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">       sum(root);</span><br><span class="line">       return sum;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sum( TreeNode node )&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">       </span><br><span class="line">        if(node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) sum += node.left.val;</span><br><span class="line"></span><br><span class="line">        if(node.left != null) sum(node.left);</span><br><span class="line">        if(node.right != null) sum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-bottom-left-tree-value/">513. Find Bottom Left Tree Value</a></h3><p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">recursive method :</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int res = 0;</span><br><span class="line">    public int maxDep = -1; // not 0</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        findLeft(root, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void findLeft(TreeNode node, int depth)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line"></span><br><span class="line">            if(depth &gt; maxDep)&#123;</span><br><span class="line">                maxDep = depth;</span><br><span class="line">                res = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        if (node.left != null)findLeft(node.left,depth + 1); // éšè—ç€å›æº¯</span><br><span class="line">        if (node.right != null)findLeft(node.right,depth + 1); //notice not depth++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    int maxdepth = -1;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        find(root,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void find(TreeNode root, int depth)&#123;</span><br><span class="line">        if(root == null) return;</span><br><span class="line">        if(root.left == null &amp;&amp; root.right == null)&#123;</span><br><span class="line">            if(depth &gt; maxdepth)&#123;</span><br><span class="line">                res = root.val;</span><br><span class="line">                maxdepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left != null)&#123;</span><br><span class="line">            depth ++;</span><br><span class="line">            find(root.left, depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right != null)&#123;</span><br><span class="line">            depth ++;</span><br><span class="line">            find(root.right, depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterative method:  (my version)</span><br><span class="line">// find the first node in the last row of the tree</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int res;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.add(root);</span><br><span class="line">        while(! que.isEmpty())&#123;</span><br><span class="line">            int num = que.size();</span><br><span class="line">            for(int i = 0; i &lt; num; i++)&#123;</span><br><span class="line">                </span><br><span class="line">                TreeNode temp = que.poll();</span><br><span class="line">                if(i == 0) res = temp.val;</span><br><span class="line">                if(temp.left != null) que.add(temp.left);</span><br><span class="line">                if(temp.right != null) que.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112. Path Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/">112. Path Sum</a></h3><p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>
<p>A <strong>leaf</strong> is a node with no children.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The root-to-leaf path with the target sum is shown.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean res = false;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        check(root, targetSum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void check(TreeNode node, int targetSum, int sum)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        sum += node.val;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line">            if(targetSum == sum) res = true;</span><br><span class="line">        &#125;else&#123; </span><br><span class="line">             check(node.left, targetSum, sum);</span><br><span class="line">             check(node.right, targetSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.ç¡®å®šç»ˆæ­¢æ¡ä»¶</p>
<p>é¦–å…ˆè®¡æ•°å™¨å¦‚ä½•ç»Ÿè®¡è¿™ä¸€æ¡è·¯å¾„çš„å’Œå‘¢ï¼Ÿ</p>
<p>ä¸è¦å»ç´¯åŠ ç„¶ååˆ¤æ–­æ˜¯å¦ç­‰äºç›®æ ‡å’Œï¼Œé‚£ä¹ˆä»£ç æ¯”è¾ƒéº»çƒ¦ï¼Œå¯ä»¥ç”¨é€’å‡ï¼Œè®©è®¡æ•°å™¨countåˆå§‹ä¸ºç›®æ ‡å’Œï¼Œç„¶åæ¯æ¬¡å‡å»éå†è·¯å¾„èŠ‚ç‚¹ä¸Šçš„æ•°å€¼ã€‚</p>
<p>å¦‚æœæœ€åcount &#x3D;&#x3D; 0ï¼ŒåŒæ—¶åˆ°äº†å¶å­èŠ‚ç‚¹çš„è¯ï¼Œè¯´æ˜æ‰¾åˆ°äº†ç›®æ ‡å’Œã€‚</p>
<p>å¦‚æœéå†åˆ°äº†å¶å­èŠ‚ç‚¹ï¼Œcountä¸ä¸º0ï¼Œå°±æ˜¯æ²¡æ‰¾åˆ°ã€‚</p>
<p>é€’å½’ç»ˆæ­¢æ¡ä»¶ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == 0) return true; // é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œå¹¶ä¸”è®¡æ•°ä¸º0</span><br><span class="line">if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return false; // é‡åˆ°å¶å­èŠ‚ç‚¹è€Œæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„è¾¹ï¼Œç›´æ¥è¿”å›</span><br></pre></td></tr></table></figure>

<p>3.ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘</p>
<p>å› ä¸ºç»ˆæ­¢æ¡ä»¶æ˜¯åˆ¤æ–­å¶å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥é€’å½’çš„è¿‡ç¨‹ä¸­å°±ä¸è¦è®©ç©ºèŠ‚ç‚¹è¿›å…¥é€’å½’äº†ã€‚</p>
<p>é€’å½’å‡½æ•°æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œå¦‚æœé€’å½’å‡½æ•°è¿”å›trueï¼Œè¯´æ˜æ‰¾åˆ°äº†åˆé€‚çš„è·¯å¾„ï¼Œåº”è¯¥ç«‹åˆ»è¿”å›ã€‚</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (cur-&gt;left) &#123; // å·¦ ï¼ˆç©ºèŠ‚ç‚¹ä¸éå†ï¼‰</span><br><span class="line">    // é‡åˆ°å¶å­èŠ‚ç‚¹è¿”å›trueï¼Œåˆ™ç›´æ¥è¿”å›true</span><br><span class="line">    if (traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)) return true; // æ³¨æ„è¿™é‡Œæœ‰å›æº¯çš„é€»è¾‘</span><br><span class="line">&#125;</span><br><span class="line">if (cur-&gt;right) &#123; // å³ ï¼ˆç©ºèŠ‚ç‚¹ä¸éå†ï¼‰</span><br><span class="line">    // é‡åˆ°å¶å­èŠ‚ç‚¹è¿”å›trueï¼Œåˆ™ç›´æ¥è¿”å›true</span><br><span class="line">    if (traversal(cur-&gt;right, count - cur-&gt;right-&gt;val)) return true; // æ³¨æ„è¿™é‡Œæœ‰å›æº¯çš„é€»è¾‘</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure>

<p>ä»¥ä¸Šä»£ç ä¸­æ˜¯åŒ…å«ç€å›æº¯çš„ï¼Œæ²¡æœ‰å›æº¯ï¼Œå¦‚ä½•åæ’¤é‡æ–°æ‰¾å¦ä¸€æ¡è·¯å¾„å‘¢ã€‚</p>
<p>å›æº¯éšè—åœ¨<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>è¿™é‡Œï¼Œ å› ä¸ºæŠŠ<code>count - cur-&gt;left-&gt;val</code> ç›´æ¥ä½œä¸ºå‚æ•°ä¼ è¿›å»ï¼Œå‡½æ•°ç»“æŸï¼Œcountçš„æ•°å€¼æ²¡æœ‰æ”¹å˜ã€‚</p>
<p>ä¸ºäº†æŠŠå›æº¯çš„è¿‡ç¨‹ä½“ç°å‡ºæ¥ï¼Œå¯ä»¥æ”¹ä¸ºå¦‚ä¸‹ä»£ç ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (cur-&gt;left) &#123; // å·¦</span><br><span class="line">    count -= cur-&gt;left-&gt;val; // é€’å½’ï¼Œå¤„ç†èŠ‚ç‚¹;</span><br><span class="line">    if (traversal(cur-&gt;left, count)) return true;</span><br><span class="line">    count += cur-&gt;left-&gt;val; // å›æº¯ï¼Œæ’¤é”€å¤„ç†ç»“æœ</span><br><span class="line">&#125;</span><br><span class="line">if (cur-&gt;right) &#123; // å³</span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    if (traversal(cur-&gt;right, count)) return true;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// second try:  time out</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        return count(root, targetSum, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean count(TreeNode node, int target, int sum)&#123;</span><br><span class="line">        if(node == null) return false;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null) &#123; //leaf</span><br><span class="line">            sum += node.val;</span><br><span class="line">            if(sum == target) return true;</span><br><span class="line">            else return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(node.left != null) count(node.left, target, sum + node.val);</span><br><span class="line">        if(node.right != null) count(node.right, target, sum + node.val);</span><br><span class="line">        //return false;   this is wrong !!!!!!!!!!!!!</span><br><span class="line">        //In the provided code, the return false; statement is placed at the end of the count method. This statement will always be executed regardless of the conditions above it.</span><br><span class="line">        return count(node.left, target, sum + node.val) || count(node.right, target, sum + node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// modify:</span><br><span class="line">//1:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        return count(root, targetSum, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean count(TreeNode node, int target, int sum)&#123;</span><br><span class="line">        if(node == null) return false;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null) &#123; //leaf</span><br><span class="line">            sum += node.val;</span><br><span class="line">            if(sum == target) return true;</span><br><span class="line">            else return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean left = false;</span><br><span class="line">        boolean right = false;</span><br><span class="line">        if(node.left != null)  left = count(node.left, target, sum + node.val); //!!!!!!!!!!!</span><br><span class="line">        if(node.right != null) right = count(node.right, target, sum + node.val);//!!!!!!!!!!!!!</span><br><span class="line"> </span><br><span class="line">        return left || right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean res = false;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        count(root, targetSum, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void count(TreeNode node, int target, int sum)&#123; //!!!!!!!!!! void</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        if(node.left == null &amp;&amp; node.right == null) &#123; //leaf</span><br><span class="line">            sum += node.val;</span><br><span class="line">            if(sum == target) res = true;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(node.left != null) count(node.left, target, sum + node.val);</span><br><span class="line">        if(node.right != null) count(node.right, target, sum + node.val);</span><br><span class="line">        //return false; </span><br><span class="line">        //return count(node.left, target, sum + node.val) || count(node.right, target, sum + node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. Construct Binary Tree from Inorder and Postorder Traversal</a></h3><p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.md</a></p>
<ul>
<li>ç¬¬ä¸€æ­¥ï¼šå¦‚æœæ•°ç»„å¤§å°ä¸ºé›¶çš„è¯ï¼Œè¯´æ˜æ˜¯ç©ºèŠ‚ç‚¹äº†ã€‚</li>
<li>ç¬¬äºŒæ­¥ï¼šå¦‚æœä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå–ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ä½œä¸ºèŠ‚ç‚¹å…ƒç´ ã€‚</li>
<li>ç¬¬ä¸‰æ­¥ï¼šæ‰¾åˆ°ååºæ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ åœ¨ä¸­åºæ•°ç»„çš„ä½ç½®ï¼Œä½œä¸ºåˆ‡å‰²ç‚¹</li>
<li>ç¬¬å››æ­¥ï¼šåˆ‡å‰²ä¸­åºæ•°ç»„ï¼Œåˆ‡æˆä¸­åºå·¦æ•°ç»„å’Œä¸­åºå³æ•°ç»„ ï¼ˆé¡ºåºåˆ«æåäº†ï¼Œä¸€å®šæ˜¯å…ˆåˆ‡ä¸­åºæ•°ç»„ï¼‰</li>
<li>ç¬¬äº”æ­¥ï¼šåˆ‡å‰²ååºæ•°ç»„ï¼Œåˆ‡æˆååºå·¦æ•°ç»„å’Œååºå³æ•°ç»„</li>
<li>ç¬¬å…­æ­¥ï¼šé€’å½’å¤„ç†å·¦åŒºé—´å’Œå³åŒºé—´</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private TreeNode traversal(int[] inorder, int inorderBegin, int inorderEnd, int[] postorder, int postorderBegin, int postorderEnd) &#123;</span><br><span class="line">        if (postorderBegin == postorderEnd) return null;</span><br><span class="line">	// find middle node in postorder ååºéå†æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå°±æ˜¯å½“å‰çš„ä¸­é—´èŠ‚ç‚¹</span><br><span class="line">        int rootValue = postorder[postorderEnd - 1];</span><br><span class="line">        TreeNode root = new TreeNode(rootValue);</span><br><span class="line">    // leaf node</span><br><span class="line">        if (postorderEnd - postorderBegin == 0) return root;</span><br><span class="line">	// find middle node in the inorder</span><br><span class="line">        int delimiterIndex;</span><br><span class="line">        for (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;</span><br><span class="line">            if (inorder[delimiterIndex] == rootValue) break;</span><br><span class="line">        &#125;</span><br><span class="line">	// é€’å½’å¤„ç†å·¦åŒºé—´å’Œå³åŒºé—´</span><br><span class="line">	//ç”¨ä¸­åºä¸­å·¦åŒºé—´çš„å¤§å°å¯ä»¥å»åˆ‡åç»­çš„å·¦åŒºé—´</span><br><span class="line">	</span><br><span class="line">		// å·¦ä¸­åºåŒºé—´ï¼Œå·¦é—­å³å¼€[leftInorderBegin, leftInorderEnd)</span><br><span class="line">        int leftInorderBegin = inorderBegin;</span><br><span class="line">        int leftInorderEnd = delimiterIndex;</span><br><span class="line">        // å³ä¸­åºåŒºé—´ï¼Œå·¦é—­å³å¼€[rightInorderBegin, rightInorderEnd)</span><br><span class="line">        int rightInorderBegin = delimiterIndex + 1;</span><br><span class="line">        int rightInorderEnd = inorderEnd;</span><br><span class="line">		// å·¦ååºåŒºé—´ï¼Œå·¦é—­å³å¼€[leftPostorderBegin, leftPostorderEnd)</span><br><span class="line">        int leftPostorderBegin = postorderBegin;</span><br><span class="line">        int leftPostorderEnd = postorderBegin + (delimiterIndex - inorderBegin);</span><br><span class="line">        // å³ååºåŒºé—´ï¼Œå·¦é—­å³å¼€[rightPostorderBegin, rightPostorderEnd)</span><br><span class="line">        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);</span><br><span class="line">        int rightPostorderEnd = postorderEnd - 1;</span><br><span class="line"></span><br><span class="line">        root.left = traversal(inorder, leftInorderBegin, leftInorderEnd, postorder, leftPostorderBegin, leftPostorderEnd);</span><br><span class="line">        root.right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        if (inorder.length == 0 || postorder.length == 0) return null;</span><br><span class="line">        // å·¦é—­å³å¼€çš„åŸåˆ™</span><br><span class="line">        return traversal(inorder, 0, inorder.length, postorder, 0, postorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if(preorder.length == 0 || inorder.length ==0) return null;</span><br><span class="line">        return construct(preorder, 0, preorder.length, inorder, 0, inorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode construct(int[] pre, int pres, int pree, int[]in, int ins, int ine)&#123;</span><br><span class="line">        if (pres == pree) return null; // Base case</span><br><span class="line"></span><br><span class="line">        int midValue = pre[pres];</span><br><span class="line">        TreeNode mid = new TreeNode(midValue);</span><br><span class="line">        //mid.val = pre[pres];</span><br><span class="line">        if(pres - pree == 0) return mid;</span><br><span class="line">        </span><br><span class="line">        int index;</span><br><span class="line"></span><br><span class="line">        for(index = ins; index &lt; ine; index++ )&#123;</span><br><span class="line">            if(in[index] == midValue) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int leftPreStart = pres + 1;</span><br><span class="line">        int leftPreEnd = pres + 1 + index - ins ;</span><br><span class="line">        int rightPreStart = pres + 1 + index - ins;</span><br><span class="line">        int rightPreEnd = pree;</span><br><span class="line"></span><br><span class="line">        int leftInStart = ins;</span><br><span class="line">        int leftInEnd = index;</span><br><span class="line">        int rightInStart = index + 1;</span><br><span class="line">        int rightInEnd = ine;</span><br><span class="line">        mid.left = construct(pre, leftPreStart, leftPreEnd, in, leftInStart, leftInEnd);</span><br><span class="line">        mid.right = construct(pre, rightPreStart, rightPreEnd, in, rightInStart, rightInEnd);</span><br><span class="line">        return mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree/">654. Maximum Binary Tree</a></h3><p>Medium</p>
<p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p>
<ol>
<li>Create a root node whose value is the maximum value in <code>nums</code>.</li>
<li>Recursively build the left subtree on the <strong>subarray <span style="color: red">prefix</span></strong> to the <strong>left</strong> of the maximum value.</li>
<li>Recursively build the right subtree on the **subarray <span style="color: red">suffix</span> ** to the <strong>right</strong> of the maximum value.</li>
</ol>
<p>Return <em>the <strong>maximum binary tree</strong> built from</em> <code>nums</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,2,1,6,0,5]</span><br><span class="line">Output: [6,3,5,null,2,0,null,null,1]</span><br><span class="line">Explanation: The recursive calls are as follow:</span><br><span class="line">- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].</span><br><span class="line">    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].</span><br><span class="line">        - Empty array, so no child.</span><br><span class="line">        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].</span><br><span class="line">            - Empty array, so no child.</span><br><span class="line">            - Only one element, so child is a node with value 1.</span><br><span class="line">    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].</span><br><span class="line">        - Only one element, so child is a node with value 0.</span><br><span class="line">        - Empty array, so no child.</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cons(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">cons</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(end - start &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// æ²¡å…ƒç´ äº†ï¼ï¼ï¼</span></span><br><span class="line">         <span class="keyword">if</span>(end - start == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[start]); <span class="comment">//åªæœ‰ä¸€ä¸ªå…ƒç´ (å·¦é—­å³å¼€)ï¼ï¼ï¼</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; nums[i])&#123;</span><br><span class="line">                 max = nums[i];</span><br><span class="line">                 index = i;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        root.val = max;</span><br><span class="line">        root.left = cons(nums, start, index);</span><br><span class="line">        root.right =  cons(nums, index+<span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//second try:</span></span><br><span class="line"><span class="comment">//left close right close</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span> , nums.length -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin &gt; end) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//!!!!</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[begin];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> begin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin ; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(max);</span><br><span class="line">        root.left = build(nums, begin, index -<span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, index + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wrong version:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;</span><br><span class="line">        //if(nums.length == 0) return null;</span><br><span class="line">        return cons(nums, 0, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode cons(int[] nums, int start, int end)&#123;</span><br><span class="line">        // if(end - start &lt; 1) return null; // æ²¡å…ƒç´ äº†</span><br><span class="line">        // if(end - start == 1) return new TreeNode(nums[start]); //åªæœ‰ä¸€ä¸ªå…ƒç´  leaf node</span><br><span class="line">        TreeNode root = new TreeNode();</span><br><span class="line">        if(end == start ) return root;</span><br><span class="line">        int max = nums[start];</span><br><span class="line">        int index = start;</span><br><span class="line">        for( int i = start; i &lt; end; i++)&#123;</span><br><span class="line">            if (max &lt; nums[i])&#123;</span><br><span class="line">                 max = nums[i];</span><br><span class="line">                 index = i;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        root.val = max;</span><br><span class="line">        root.left = cons(nums, start, index);</span><br><span class="line">        root.right =  cons(nums, index+1, end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></h3><p>Easy</p>
<p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return <em>the merged tree</em>.</p>
<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">Output: [3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root1 == null &amp;&amp; root2 == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = new TreeNode();</span><br><span class="line">        </span><br><span class="line">        if (root1 == null) &#123;</span><br><span class="line">            root.val = root2.val;</span><br><span class="line">        &#125; else if (root2 == null) &#123;</span><br><span class="line">            root.val = root1.val;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.val = root1.val + root2.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = mergeTrees(root1 != null ? root1.left : null, root2 != null ? root2.left : null);</span><br><span class="line">        root.right = mergeTrees(root1 != null ? root1.right : null, root2 != null ? root2.right : null);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//leetcoke:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // é€’å½’</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if (root1 == null) return root2; //!!!!!!</span><br><span class="line">        if (root2 == null) return root1; //!!!!!!!!</span><br><span class="line"></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        return root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// second try: fail</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if(root1 == null &amp;&amp; root2 == null ) return root1;;</span><br><span class="line">        if(root1.left  != null &amp;&amp; root2.left != null)&#123;</span><br><span class="line">            root1.val = root1.val + root2.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="700-Search-in-a-Binary-Search-Tree"><a href="#700-Search-in-a-Binary-Search-Tree" class="headerlink" title="700. Search in a Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-a-binary-search-tree/">700. Search in a Binary Search Tree</a></h3><p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>
<p>Find the node in the BST that the nodeâ€™s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3], val = 2</span><br><span class="line">Output: [2,1,3]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        if(root.val == val) return root;</span><br><span class="line">        TreeNode result = new TreeNode();</span><br><span class="line">        result = searchBST(root.left, val);</span><br><span class="line">        if(result != null ) return result;</span><br><span class="line">        result = searchBST(root.right, val);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WRONG: </span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        if(root.val == val) return root;</span><br><span class="line">        </span><br><span class="line">        searchBST(root.left, val);</span><br><span class="line">        searchBST(root.right, val);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//second try:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root.val == val) return root;</span><br><span class="line">        if(val &lt; root.val &amp;&amp; root.left != null) return searchBST(root.left,val);</span><br><span class="line">        if(val &gt; root.val &amp;&amp; root.right != null)</span><br><span class="line">        return searchBST(root.right,val);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if (root == NULL || root-&gt;val == val) return root;</span><br><span class="line">        TreeNode* result = NULL; //!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">        if (root-&gt;val &gt; val) result = searchBST(root-&gt;left, val);</span><br><span class="line">        if (root-&gt;val &lt; val) result = searchBST(root-&gt;right, val);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>æˆ–è€…æˆ‘ä»¬ä¹Ÿå¯ä»¥è¿™ä¹ˆå†™</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* searchBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if (root == NULL || root-&gt;val == val) return root;</span><br><span class="line">        if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);</span><br><span class="line">        if (root-&gt;val &lt; val) return searchBST(root-&gt;right, val);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">98. Validate Binary Search Tree</a></h3><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>
<p>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li><p>The left subtree</p>
<p> of a node contains only nodes with keys</p>
<p>less than</p>
<p>the nodeâ€™s key.</p>
</li>
<li><p>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the nodeâ€™s key.</p>
</li>
<li><p>Both the left and right subtrees must also be binary search trees.</p>
</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">å®è´¨ä¸Šå°±æ˜¯ä¸­åºéå†</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode max;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return true;</span><br><span class="line">        </span><br><span class="line">            boolean left = isValidBST(root.left); //å·¦</span><br><span class="line">            if(!left) return false;</span><br><span class="line"></span><br><span class="line">            if (max != null &amp;&amp; root.val &lt;= max.val) &#123; //ä¸­ æ¯”è¾ƒèŠ‚ç‚¹çš„é€»è¾‘ </span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">            max = root; //è®°å½•å½“å‰èŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºæŒ‰ç…§ä¸­åºéå†ï¼Œå½“å‰èŠ‚ç‚¹éƒ½åº”è¯¥æ¯”ä¸Šä¸€ä¸ªèŠ‚ç‚¹å¤§ã€‚</span><br><span class="line"></span><br><span class="line">            boolean right = isValidBST(root.right);//å³</span><br><span class="line">            if(!right) return false;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// my </span><br><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public TreeNode max;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        boolean left  = true;</span><br><span class="line">        boolean right = true;</span><br><span class="line">        if(root.left != null)</span><br><span class="line">           left = isValidBST(root.left);</span><br><span class="line">           </span><br><span class="line">        if(max!= null &amp;&amp; root.val &lt;= max.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        max = root;</span><br><span class="line">        </span><br><span class="line">        if(root.right != null)</span><br><span class="line">            right = isValidBST(root.right);</span><br><span class="line">            </span><br><span class="line">        return left &amp;&amp; right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public  List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        see(root);</span><br><span class="line">        return check(res);</span><br><span class="line">    &#125;</span><br><span class="line">    public void see(TreeNode node)&#123;</span><br><span class="line">       if(node == null) return;</span><br><span class="line">       see(node.left);</span><br><span class="line">       res.add(node.val);</span><br><span class="line">       see(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean check(List&lt;Integer&gt; res)&#123;</span><br><span class="line">        for(int i = 0; i &lt; res.size() - 1; i++)&#123;</span><br><span class="line">            if(res.get(i) &gt;=  res.get(i+1)) return false; </span><br><span class="line">            //!!!! &gt;= not &gt;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="530-Minimum-Absolute-Difference-in-BST"><a href="#530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="530. Minimum Absolute Difference in BST"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/">530. Minimum Absolute Difference in BST</a></h3><p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,6,1,3]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mine:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public int min = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        inorder(root);</span><br><span class="line">        check(res);</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">    public void inorder(TreeNode node)&#123;</span><br><span class="line">        if(node == null) return;</span><br><span class="line">        inorder(node.left);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    public void check(List&lt;Integer&gt; res)&#123;</span><br><span class="line">        for(int i = 0; i &lt; res.size() - 1; i++)&#123;</span><br><span class="line">            int temp = res.get(i+1) - res.get(i);</span><br><span class="line">            if(temp &lt; min)&#123;</span><br><span class="line">                min = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SECOND TRY:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    Integer pre;</span><br><span class="line">    int dif = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return dif;</span><br><span class="line">        getMinimumDifference(root.left);</span><br><span class="line">        if(pre != null )&#123;</span><br><span class="line">             int temp = Math.abs(pre - root.val);</span><br><span class="line">             if(dif &gt; temp) dif = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        getMinimumDifference(root.right);</span><br><span class="line">        return dif;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">leetcode:</span><br><span class="line">// åŒæŒ‡é’ˆ</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode pre;// è®°å½•ä¸Šä¸€ä¸ªéå†çš„ç»“ç‚¹</span><br><span class="line">    int result = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">       if(root==null)return 0;</span><br><span class="line">       traversal(root);</span><br><span class="line">       return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public void traversal(TreeNode root)&#123;</span><br><span class="line">        if(root==null)return;</span><br><span class="line">        //å·¦</span><br><span class="line">        traversal(root.left);</span><br><span class="line">        //ä¸­</span><br><span class="line">        if(pre!=null)&#123;</span><br><span class="line">            result = Math.min(result,root.val-pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        //å³</span><br><span class="line">        traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="501-Find-Mode-in-Binary-Search-Tree"><a href="#501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="501. Find Mode in Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-mode-in-binary-search-tree/">501. Find Mode in Binary Search Tree</a></h3><p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p>
<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the nodeâ€™s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the nodeâ€™s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">MY VERSION:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        find(root);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123; !!!!!!!!!!!!!!!!!!</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (count &lt; temp) &#123;</span><br><span class="line">                count = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())&#123;  !!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() == count) &#123;</span><br><span class="line">                res.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray(); !!!!!!!!!!!!!!!!!!!</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//or</span></span><br><span class="line">            </span><br><span class="line">                    <span class="comment">// Convert ArrayList to array (for primitive types)</span></span><br><span class="line">                    <span class="comment">//int[] array = new int[res.size()];</span></span><br><span class="line">                    <span class="comment">//for (int i = 0; i &lt; res.size(); i++) &#123;</span></span><br><span class="line">                     <span class="comment">//     array[i] = res.get(i);</span></span><br><span class="line">                    <span class="comment">//&#125;</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        find(node.left);</span><br><span class="line">        map.put(node.val, map.getOrDefault(node.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        find(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">åŒæŒ‡é’ˆï¼š</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resList;</span><br><span class="line">    <span class="type">int</span> maxCount;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    TreeNode pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        findMode1(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()]; !!!!!!!!!!!!</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resList.size(); i++) &#123;</span><br><span class="line">            res[i] = resList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findMode1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findMode1(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootValue</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="comment">// è®¡æ•°</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">null</span> || rootValue != pre.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// æ›´æ–°ç»“æœä»¥åŠmaxCount</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            resList.clear();</span><br><span class="line">            resList.add(rootValue);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            resList.add(rootValue);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        findMode1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">å“ˆå¸Œè¡¨ï¼š</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">		<span class="comment">// è·å¾—é¢‘ç‡ Map</span></span><br><span class="line">		searchBST(root, map);</span><br><span class="line">		List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">				.sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		list.add(mapList.get(<span class="number">0</span>).getKey());</span><br><span class="line">		<span class="comment">// æŠŠé¢‘ç‡æœ€é«˜çš„åŠ å…¥ list</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; mapList.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mapList.get(i).getValue() == mapList.get(i - <span class="number">1</span>).getValue()) &#123;</span><br><span class="line">				list.add(mapList.get(i).getKey());</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">searchBST</span><span class="params">(TreeNode curr, Map&lt;Integer, Integer&gt; map)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (curr == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">		map.put(curr.val, map.getOrDefault(curr.val, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">		searchBST(curr.left, map);</span><br><span class="line">		searchBST(curr.right, map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></h3><p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md</a></p>
<p>å†æ¥çœ‹è¿”å›å€¼ï¼Œé€’å½’å‡½æ•°ä»€ä¹ˆæ—¶å€™éœ€è¦è¿”å›å€¼ï¼Ÿä»€ä¹ˆæ—¶å€™ä¸éœ€è¦è¿”å›å€¼ï¼Ÿè¿™é‡Œæ€»ç»“å¦‚ä¸‹ä¸‰ç‚¹ï¼š</p>
<ul>
<li>å¦‚æœéœ€è¦æœç´¢æ•´æ£µäºŒå‰æ ‘ä¸”ä¸ç”¨å¤„ç†é€’å½’è¿”å›å€¼ï¼Œé€’å½’å‡½æ•°å°±ä¸è¦è¿”å›å€¼ã€‚ï¼ˆè¿™ç§æƒ…å†µå°±æ˜¯æœ¬æ–‡ä¸‹åŠéƒ¨åˆ†ä»‹ç»çš„113.è·¯å¾„æ€»å’Œiiï¼‰</li>
<li>å¦‚æœéœ€è¦æœç´¢æ•´æ£µäºŒå‰æ ‘ä¸”éœ€è¦å¤„ç†é€’å½’è¿”å›å€¼ï¼Œé€’å½’å‡½æ•°å°±éœ€è¦è¿”å›å€¼ã€‚ ï¼ˆè¿™ç§æƒ…å†µæˆ‘ä»¬åœ¨<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ (opens new window)</a>ä¸­ä»‹ç»ï¼‰</li>
<li>å¦‚æœè¦æœç´¢å…¶ä¸­ä¸€æ¡ç¬¦åˆæ¡ä»¶çš„è·¯å¾„ï¼Œé‚£ä¹ˆé€’å½’ä¸€å®šéœ€è¦è¿”å›å€¼ï¼Œå› ä¸ºé‡åˆ°ç¬¦åˆæ¡ä»¶çš„è·¯å¾„äº†å°±è¦åŠæ—¶è¿”å›ã€‚ï¼ˆæœ¬é¢˜çš„æƒ…å†µï¼‰</li>
</ul>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: â€œThe lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).â€</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root == p || root == q) return root; //ç½‘ä¸Šè¿”å› !!!!!!!!!</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left , p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right , p, q);</span><br><span class="line">        if(left == null &amp;&amp; right == null) return null;</span><br><span class="line">        if(left == null &amp;&amp; right != null) return right;</span><br><span class="line">        if(left != null &amp;&amp; right == null) return left;</span><br><span class="line">        if(left != null &amp;&amp; right != null) return root;  //!!!!!!!!!!!</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>é¦–å…ˆæœ€å®¹æ˜“æƒ³åˆ°çš„ä¸€ä¸ªæƒ…å†µï¼šå¦‚æœæ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå‘ç°å·¦å­æ ‘å‡ºç°ç»“ç‚¹pï¼Œå³å­æ ‘å‡ºç°èŠ‚ç‚¹qï¼Œæˆ–è€… å·¦å­æ ‘å‡ºç°ç»“ç‚¹qï¼Œå³å­æ ‘å‡ºç°èŠ‚ç‚¹pï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹å°±æ˜¯èŠ‚ç‚¹på’Œqçš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚</strong> å³æƒ…å†µä¸€ï¼š</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/6367d6efb943d22cf2c56eff5b51a61acaa0be871f516c7e212392fc13fda234/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303232303932323137333530322e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/6367d6efb943d22cf2c56eff5b51a61acaa0be871f516c7e212392fc13fda234/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303232303932323137333530322e706e67" alt="img"></a></p>
<p>åˆ¤æ–­é€»è¾‘æ˜¯ å¦‚æœé€’å½’éå†é‡åˆ°qï¼Œå°±å°†qè¿”å›ï¼Œé‡åˆ°p å°±å°†pè¿”å›ï¼Œé‚£ä¹ˆå¦‚æœ å·¦å³å­æ ‘çš„è¿”å›å€¼éƒ½ä¸ä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶çš„ä¸­èŠ‚ç‚¹ï¼Œä¸€å®šæ˜¯q å’Œp çš„æœ€è¿‘ç¥–å…ˆã€‚</p>
<p>é‚£ä¹ˆæœ‰å½•å‹å¯èƒ½ç–‘æƒ‘ï¼Œä¼šä¸ä¼šå·¦å­æ ‘ é‡åˆ°q è¿”å›ï¼Œå³å­æ ‘ä¹Ÿé‡åˆ°qè¿”å›ï¼Œè¿™æ ·å¹¶æ²¡æœ‰æ‰¾åˆ° q å’Œpçš„æœ€è¿‘ç¥–å…ˆã€‚</p>
<p>è¿™ä¹ˆæƒ³çš„å½•å‹ï¼Œè¦å®¡é¢˜äº†ï¼Œé¢˜ç›®å¼ºè°ƒï¼š<strong>äºŒå‰æ ‘èŠ‚ç‚¹æ•°å€¼æ˜¯ä¸é‡å¤çš„ï¼Œè€Œä¸”ä¸€å®šå­˜åœ¨ q å’Œ p</strong>ã€‚</p>
<p><strong>ä½†æ˜¯å¾ˆå¤šäººå®¹æ˜“å¿½ç•¥ä¸€ä¸ªæƒ…å†µï¼Œå°±æ˜¯èŠ‚ç‚¹æœ¬èº«p(q)ï¼Œå®ƒæ‹¥æœ‰ä¸€ä¸ªå­å­™èŠ‚ç‚¹q(p)ã€‚</strong> æƒ…å†µäºŒï¼š</p>
<p>å…¶å®æƒ…å†µä¸€ å’Œ æƒ…å†µäºŒ ä»£ç å®ç°è¿‡ç¨‹éƒ½æ˜¯ä¸€æ ·çš„ï¼Œä¹Ÿå¯ä»¥è¯´ï¼Œå®ç°æƒ…å†µä¸€çš„é€»è¾‘ï¼Œé¡ºä¾¿åŒ…å«äº†æƒ…å†µäºŒã€‚</p>
<p>å› ä¸ºé‡åˆ° q æˆ–è€… p å°±è¿”å›ï¼Œè¿™æ ·ä¹ŸåŒ…å«äº† q æˆ–è€… p æœ¬èº«å°±æ˜¯ å…¬å…±ç¥–å…ˆçš„æƒ…å†µã€‚</p>
<p>è¿™ä¸€ç‚¹æ˜¯å¾ˆå¤šå½•å‹å®¹æ˜“å¿½ç•¥çš„</p>
<p>if dont understand here, check the video.</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/a7f086d812abae6ade94b964eca77c57de3f527cdc90403dc6d52fb7761efebd/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303230343135313132353834342e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/a7f086d812abae6ade94b964eca77c57de3f527cdc90403dc6d52fb7761efebd/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303230343135313132353834342e706e67" alt="236.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ1"></a></p>
<p>å›¾ä¸­èŠ‚ç‚¹10çš„å·¦å­æ ‘è¿”å›nullï¼Œå³å­æ ‘è¿”å›ç›®æ ‡å€¼7ï¼Œé‚£ä¹ˆæ­¤æ—¶èŠ‚ç‚¹10çš„å¤„ç†é€»è¾‘å°±æ˜¯æŠŠå³å­æ ‘çš„è¿”å›å€¼ï¼ˆæœ€è¿‘å…¬å…±ç¥–å…ˆ7ï¼‰è¿”å›ä¸Šå»ï¼</p>
<p>è¿™é‡Œä¹Ÿå¾ˆé‡è¦ï¼Œå¯èƒ½åˆ·è¿‡è¿™é“é¢˜ç›®çš„åŒå­¦ï¼Œéƒ½ä¸æ¸…æ¥šç»“æœç©¶ç«Ÿæ˜¯å¦‚ä½•ä»åº•å±‚ä¸€å±‚ä¸€å±‚ä¼ åˆ°å¤´ç»“ç‚¹çš„ã€‚</p>
<p>é‚£ä¹ˆå¦‚æœleftå’Œrightéƒ½ä¸ºç©ºï¼Œåˆ™è¿”å›leftæˆ–è€…rightéƒ½æ˜¯å¯ä»¥çš„ï¼Œä¹Ÿå°±æ˜¯è¿”å›ç©º</p>
<p><strong>é‚£ä¹ˆæˆ‘ç»™å¤§å®¶å½’çº³å¦‚ä¸‹ä¸‰ç‚¹</strong>ï¼š</p>
<ol>
<li>æ±‚æœ€å°å…¬å…±ç¥–å…ˆï¼Œéœ€è¦ä»åº•å‘ä¸Šéå†ï¼Œé‚£ä¹ˆäºŒå‰æ ‘ï¼Œåªèƒ½é€šè¿‡ååºéå†ï¼ˆå³ï¼šå›æº¯ï¼‰å®ç°ä»åº•å‘ä¸Šçš„éå†æ–¹å¼ã€‚</li>
<li>åœ¨å›æº¯çš„è¿‡ç¨‹ä¸­ï¼Œå¿…ç„¶è¦éå†æ•´æ£µäºŒå‰æ ‘ï¼Œå³ä½¿å·²ç»æ‰¾åˆ°ç»“æœäº†ï¼Œä¾ç„¶è¦æŠŠå…¶ä»–èŠ‚ç‚¹éå†å®Œï¼Œå› ä¸ºè¦ä½¿ç”¨é€’å½’å‡½æ•°çš„è¿”å›å€¼ï¼ˆä¹Ÿå°±æ˜¯ä»£ç ä¸­çš„leftå’Œrightï¼‰åšé€»è¾‘åˆ¤æ–­ã€‚</li>
<li>è¦ç†è§£å¦‚æœè¿”å›å€¼leftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºä¸ºä»€ä¹ˆè¦è¿”å›rightï¼Œä¸ºä»€ä¹ˆå¯ä»¥ç”¨è¿”å›rightä¼ ç»™ä¸Šä¸€å±‚ç»“æœã€‚</li>
</ol>
<p>å¯ä»¥è¯´è¿™é‡Œæ¯ä¸€æ­¥ï¼Œéƒ½æ˜¯æœ‰éš¾åº¦çš„ï¼Œéƒ½éœ€è¦å¯¹äºŒå‰æ ‘ï¼Œé€’å½’å’Œå›æº¯æœ‰ä¸€å®šçš„ç†è§£ã€‚</p>
<p>æœ¬é¢˜æ²¡æœ‰ç»™å‡ºè¿­ä»£æ³•ï¼Œå› ä¸ºè¿­ä»£æ³•ä¸é€‚åˆæ¨¡æ‹Ÿå›æº¯çš„è¿‡ç¨‹ã€‚ç†è§£é€’å½’çš„è§£æ³•å°±å¤Ÿäº†ã€‚</p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: â€œThe lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).â€</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root == null ) return null;</span><br><span class="line">        if(root.val &gt; p .val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">            if(left != null) return left;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val &lt; p .val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">            if(right != null) return right;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>you can also use the method in 236 as well.</p>
<p>åœ¨<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">äºŒå‰æ ‘ï¼šå…¬å…±ç¥–å…ˆé—®é¢˜</a>ä¸­ï¼Œå¦‚æœé€’å½’å‡½æ•°æœ‰è¿”å›å€¼ï¼Œå¦‚ä½•åŒºåˆ†è¦æœç´¢ä¸€æ¡è¾¹ï¼Œè¿˜æ˜¯æœç´¢æ•´ä¸ªæ ‘ã€‚</p>
<p>æœç´¢ä¸€æ¡è¾¹çš„å†™æ³•ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (é€’å½’å‡½æ•°(root-&gt;left)) return ;</span><br><span class="line">if (é€’å½’å‡½æ•°(root-&gt;right)) return ;</span><br></pre></td></tr></table></figure>



<p>æœç´¢æ•´ä¸ªæ ‘å†™æ³•ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = é€’å½’å‡½æ•°(root-&gt;left);</span><br><span class="line">right = é€’å½’å‡½æ•°(root-&gt;right);</span><br><span class="line">leftä¸rightçš„é€»è¾‘å¤„ç†;</span><br></pre></td></tr></table></figure>



<p>æœ¬é¢˜å°±æ˜¯æ ‡å‡†çš„æœç´¢ä¸€æ¡è¾¹çš„å†™æ³•ï¼Œé‡åˆ°é€’å½’å‡½æ•°çš„è¿”å›å€¼ï¼Œå¦‚æœä¸ä¸ºç©ºï¼Œç«‹åˆ»è¿”å›ã€‚</p>
<h3 id="701-Insert-into-a-Binary-Search-Tree"><a href="#701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="701. Insert into a Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">701. Insert into a Binary Search Tree</a></h3><p>çœ‹ä»£ç éšæƒ³å½•ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
<p>Medium</p>
<p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>
<p><strong>Notice</strong> that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,7,1,3], val = 5</span><br><span class="line">Output: [4,2,7,1,3,5]</span><br><span class="line">Explanation: Another accepted tree is:</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">rep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);<span class="comment">//é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œnewæ–°èŠ‚ç‚¹ï¼Œå¹¶è¿”å›ä¸Šå»ï¼Œè¿”å›ç»™ä¸Šä¸€å±‚</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/17ca42400b7f5cc14a6e75b8ba9208163418dbf0f740bc126a78754ce745054a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3730312e2545342542412538432545352538462538392545362539302539432545372542342541322545362541302539312545342542382541442545372539412538342545362538462539322545352538352541352545362539332538442545342542442539432e676966"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/17ca42400b7f5cc14a6e75b8ba9208163418dbf0f740bc126a78754ce745054a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3730312e2545342542412538432545352538462538392545362539302539432545372542342541322545362541302539312545342542382541442545372539412538342545362538462539322545352538352541352545362539332538442545342542442539432e676966" alt="701.äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ"></a></p>
<p>ä¾‹å¦‚æ’å…¥å…ƒç´ 10 ï¼Œéœ€è¦æ‰¾åˆ°æœ«å°¾èŠ‚ç‚¹æ’å…¥ä¾¿å¯ï¼Œä¸€æ ·çš„é“ç†æ¥æ’å…¥å…ƒç´ 15ï¼Œæ’å…¥å…ƒç´ 0ï¼Œæ’å…¥å…ƒç´ 6ï¼Œ<strong>éœ€è¦è°ƒæ•´äºŒå‰æ ‘çš„ç»“æ„ä¹ˆï¼Ÿ å¹¶ä¸éœ€è¦ã€‚</strong>ã€‚</p>
<p>åªè¦éå†äºŒå‰æœç´¢æ ‘ï¼Œæ‰¾åˆ°ç©ºèŠ‚ç‚¹ æ’å…¥å…ƒç´ å°±å¯ä»¥äº†ï¼Œé‚£ä¹ˆè¿™é“é¢˜å…¶å®å°±ç®€å•äº†ã€‚</p>
<p>æ¥ä¸‹æ¥å°±æ˜¯éå†äºŒå‰æœç´¢æ ‘çš„è¿‡ç¨‹äº†ã€‚</p>
</li>
<li><p>ç¡®å®šç»ˆæ­¢æ¡ä»¶</p>
</li>
</ul>
<p>ç»ˆæ­¢æ¡ä»¶å°±æ˜¯æ‰¾åˆ°éå†çš„èŠ‚ç‚¹ä¸ºnullçš„æ—¶å€™ï¼Œå°±æ˜¯è¦æ’å…¥èŠ‚ç‚¹çš„ä½ç½®äº†ï¼Œå¹¶æŠŠæ’å…¥çš„èŠ‚ç‚¹è¿”å›ã€‚</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (root == NULL) &#123;</span><br><span class="line">    TreeNode* node = new TreeNode(val);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>è¿™é‡ŒæŠŠæ·»åŠ çš„èŠ‚ç‚¹è¿”å›ç»™ä¸Šä¸€å±‚ï¼Œå°±å®Œæˆäº†çˆ¶å­èŠ‚ç‚¹çš„èµ‹å€¼æ“ä½œäº†ï¼Œè¯¦ç»†å†å¾€ä¸‹çœ‹ã€‚</p>
<ul>
<li>ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘</li>
</ul>
<p>æ­¤æ—¶è¦æ˜ç¡®ï¼Œéœ€è¦éå†æ•´æ£µæ ‘ä¹ˆï¼Ÿ</p>
<p>åˆ«å¿˜äº†è¿™æ˜¯æœç´¢æ ‘ï¼Œéå†æ•´æ£µæœç´¢æ ‘ç®€ç›´æ˜¯å¯¹æœç´¢æ ‘çš„ä¾®è¾±ï¼Œå“ˆå“ˆã€‚</p>
<p>æœç´¢æ ‘æ˜¯æœ‰æ–¹å‘äº†ï¼Œå¯ä»¥æ ¹æ®æ’å…¥å…ƒç´ çš„æ•°å€¼ï¼Œå†³å®šé€’å½’æ–¹å‘ã€‚</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">return root;</span><br></pre></td></tr></table></figure>

<p>ã€‚</p>
<p><strong>æœ‰è¿”å›å€¼çš„è¯ï¼Œå¯ä»¥åˆ©ç”¨è¿”å›å€¼å®Œæˆæ–°åŠ å…¥çš„èŠ‚ç‚¹ä¸å…¶çˆ¶èŠ‚ç‚¹çš„èµ‹å€¼æ“ä½œ</strong>ã€‚</p>
<p><strong>åˆ°è¿™é‡Œï¼Œå¤§å®¶åº”è¯¥èƒ½æ„Ÿå—åˆ°ï¼Œå¦‚ä½•é€šè¿‡é€’å½’å‡½æ•°è¿”å›å€¼å®Œæˆäº†æ–°åŠ å…¥èŠ‚ç‚¹çš„çˆ¶å­å…³ç³»èµ‹å€¼æ“ä½œäº†ï¼Œä¸‹ä¸€å±‚å°†åŠ å…¥èŠ‚ç‚¹è¿”å›ï¼Œæœ¬å±‚ç”¨root-&gt;leftæˆ–è€…root-&gt;rightå°†å…¶æ¥ä½</strong>ã€‚</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// with return</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        if (root == NULL) &#123;</span><br><span class="line">            TreeNode* node = new TreeNode(val);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        if (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">////////////////////////////////////</span><br><span class="line"></span><br><span class="line">//without return</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    TreeNode* parent;</span><br><span class="line">    void traversal(TreeNode* cur, int val) &#123;</span><br><span class="line">        if (cur == NULL) &#123;</span><br><span class="line">            TreeNode* node = new TreeNode(val);</span><br><span class="line">            if (val &gt; parent-&gt;val) parent-&gt;right = node;</span><br><span class="line">            else parent-&gt;left = node;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = cur;</span><br><span class="line">        if (cur-&gt;val &gt; val) traversal(cur-&gt;left, val);</span><br><span class="line">        if (cur-&gt;val &lt; val) traversal(cur-&gt;right, val);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">        parent = new TreeNode(0);</span><br><span class="line">        if (root == NULL) &#123;</span><br><span class="line">            root = new TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        traversal(root, val);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">Output: [5,4,6,2,null,null,7]</span><br><span class="line">Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the above BST.</span><br><span class="line">Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#x27;s also accepted.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root.val == key)&#123;</span><br><span class="line">            </span><br><span class="line">            if(root.left == null &amp;&amp; root.right == null)&#123;</span><br><span class="line">                return null;   // not return </span><br><span class="line">            &#125;</span><br><span class="line">            if(root.right != null &amp;&amp; root.left == null )&#123;</span><br><span class="line">                return root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(root.left != null &amp;&amp; root.right == null )&#123;</span><br><span class="line">                return root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if(root.left != null &amp;&amp; root.right != null)&#123;</span><br><span class="line">                // !!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">                TreeNode temp = root.right;</span><br><span class="line">                while(temp.left != null)&#123;</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">                temp.left = root.left;</span><br><span class="line">                return root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            if(key &lt; root.val)</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">            if(key &gt; root.val)</span><br><span class="line">            root.right = deleteNode(root.right, key); //å³å­æ ‘æ¥ä½åˆ é™¤å®ŒèŠ‚ç‚¹çš„å­æ ‘ </span><br><span class="line">            return root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trim-a-binary-search-tree/">669. Trim a Binary Search Tree</a></h3><p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any nodeâ€™s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>
<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>
<p><strong>Example :</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,0,2], low = 1, high = 2</span><br><span class="line">Output: [1,null,2]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        if(root.val &lt; low)&#123; // abandone left tree</span><br><span class="line">            TreeNode right = trimBST(root.right, low, high);</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val &gt; high)&#123; // abandone right tree</span><br><span class="line">            TreeNode left = trimBST(root.left, low, high);</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(root.val &lt; low)&#123;</span><br><span class="line">            // root.left = null;</span><br><span class="line">            // if(root.right != null)&#123;</span><br><span class="line">            //     root = root.right;</span><br><span class="line">            // &#125;</span><br><span class="line">            //return root.right;</span><br><span class="line">            root.right = trimBST(root.right, low, high);</span><br><span class="line">            return root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val &gt; high)&#123;</span><br><span class="line">            // root.right = null;</span><br><span class="line">            // if(root.left != null)&#123;</span><br><span class="line">            //     root = root.left;</span><br><span class="line">            // &#125;</span><br><span class="line">            //return root.left;</span><br><span class="line">            root.left = trimBST(root.left, low, high);</span><br><span class="line">            return trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = trimBST(root.left,  low,  high);</span><br><span class="line">        root.right = trimBST(root.right,  low,  high);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">108. Convert Sorted Array to Binary Search Tree</a></h3><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a</em> </p>
<p>*<strong>height-balanced*</strong></p>
<p> <em>binary search tree</em>. </p>
<p><strong>Example:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br><span class="line">Explanation: [0,-10,5,null,-3,null,9] is also accepted:</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> create(nums, <span class="number">0</span> , nums.length  ); <span class="comment">// å·¦é—­å³å¼€ Closed on the left, open on the right</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">create</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;   <span class="comment">// it&#x27;s &gt;= not &gt;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = create(nums, left, mid );</span><br><span class="line">        root.right = create(nums, mid + <span class="number">1</span>, right  );</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wrong:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode res;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start,<span class="type">int</span> end, TreeNode res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[(start + end) / <span class="number">2</span>]);</span><br><span class="line">        build(nums, start, (start + end) / <span class="number">2</span> - <span class="number">1</span>, res.left);</span><br><span class="line">        build(nums, (start + end) / <span class="number">2</span> + <span class="number">1</span>, end, res.right);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="538-Convert-BST-to-Greater-Tree"><a href="#538-Convert-BST-to-Greater-Tree" class="headerlink" title="538. Convert BST to Greater Tree"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree/">538. Convert BST to Greater Tree</a></h3><p>Medium</p>
<p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>
<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the nodeâ€™s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the nodeâ€™s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2019/05/02/tree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>

<p>â€‹                                                                          <strong>!!! right mid left !!!</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return null;</span><br><span class="line">        </span><br><span class="line">        if(root.right != null) convertBST(root.right);</span><br><span class="line">        res += root.val;</span><br><span class="line">        root.val = res;</span><br><span class="line">        </span><br><span class="line">        if(root.left != null) convertBST(root.left);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//wrong version:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode pre = new TreeNode(0);</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        root.val += pre.val;</span><br><span class="line">        convertBST(root.left); //</span><br><span class="line">        pre.val = root.val;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></h3><p>Medium</p>
<p>Given the <code>root</code> of a binary tree, flatten the tree into a â€œlinked listâ€:</p>
<ul>
<li>The â€œlinked listâ€ should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>
<li>The â€œlinked listâ€ should be in the same order as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR"><strong>pre-order</strong> <strong>traversal</strong></a> of the binary tree.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,5,3,4,null,6]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flattenTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">flattenTree</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursively flatten the left and right subtrees</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftTail</span> <span class="operator">=</span> flattenTree(node.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightTail</span> <span class="operator">=</span> flattenTree(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store the right subtree to link it later</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightSubtree</span> <span class="operator">=</span> node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there&#x27;s a left subtree, move it to the right</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = node.left;</span><br><span class="line">            node.left = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connect the right subtree after the newly moved left subtree</span></span><br><span class="line">        <span class="keyword">if</span> (leftTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            leftTail.right = rightSubtree;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the rightmost node after flattening</span></span><br><span class="line">        <span class="keyword">return</span> (rightTail != <span class="literal">null</span>) ? rightTail : (leftTail != <span class="literal">null</span>) ? leftTail : node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>â€‹    1</p>
<p>   &#x2F; <br>  2   5<br> &#x2F; \   <br>3   4   6</p>
<p>Step 1:<br>   1<br>  &#x2F;<br> 2</p>
<p>Step 2:<br>   1<br>  &#x2F;<br> 2<br>  <br>   3</p>
<p>Step 3:<br>   1<br>    <br>     2<br>      <br>       3</p>
<p>Step 4:<br>   1<br>    <br>     2<br>      <br>       3<br>        <br>         4</p>
<p>Step 5:<br>   1<br>    <br>     2<br>      <br>       3<br>        <br>         4<br>          <br>           5</p>
<p>Step 6:<br>   1<br>    <br>     2<br>      <br>       3<br>        <br>         4<br>          <br>           5<br>            <br>             6</p>
<p>[toc]</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://DanLovPotato.github.io">Dan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://danlovpotato.github.io/2023/07/28/LeetCode/tree/">https://danlovpotato.github.io/2023/07/28/LeetCode/tree/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/17/LeetCode/BackTracking/" title="BackTracking"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">BackTracking</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/21/LeetCode/DP/" title="DP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">DP</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dan</div><div class="author-info__description">Lack the words to compliment myself today.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DanLovPotato"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Tree%F0%9F%8C%BC"><span class="toc-number">1.</span> <span class="toc-text">TreeğŸŒ¼</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Depth-first-traversal"><span class="toc-number">1.1.</span> <span class="toc-text">Depth-first traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-recursive-traversal-of-a-binary-tree"><span class="toc-number">1.1.1.</span> <span class="toc-text">The recursive traversal of a binary tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterative-traversal-of-a-binary-tree"><span class="toc-number">1.1.2.</span> <span class="toc-text">Iterative traversal of a binary tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Level-order-traversal"><span class="toc-number">1.2.</span> <span class="toc-text">Level-order traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#implement-breadth-first-traversal-level-order-traversal-of-a-binary-tree-using-a-queue"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">implement breadth-first traversal (level-order traversal) of a binary tree using a queue.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#que-x3D-x3D-null-VS-que-isEmpty"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">que&#x3D;&#x3D;null VS. que.isEmpty()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedList"><span class="toc-number">2.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#107-Binary-Tree-Level-Order-Traversal-II"><span class="toc-number">2.0.1.</span> <span class="toc-text">107. Binary Tree Level Order Traversal II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199-Binary-Tree-Right-Side-View"><span class="toc-number">2.0.2.</span> <span class="toc-text">199. Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#637-Average-of-Levels-in-Binary-Tree"><span class="toc-number">2.0.3.</span> <span class="toc-text">637. Average of Levels in Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#429-N-ary-Tree-Level-Order-Traversal"><span class="toc-number">2.0.4.</span> <span class="toc-text">429. N-ary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#515-Find-Largest-Value-in-Each-Tree-Row"><span class="toc-number">2.0.5.</span> <span class="toc-text">515. Find Largest Value in Each Tree Row</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node"><span class="toc-number">2.0.6.</span> <span class="toc-text">116. Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#226-Invert-Binary-Tree"><span class="toc-number">2.0.7.</span> <span class="toc-text">226. Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-Symmetric-Tree"><span class="toc-number">2.0.8.</span> <span class="toc-text">101. Symmetric Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100-Same-Tree"><span class="toc-number">2.0.9.</span> <span class="toc-text">100. Same Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="toc-number">2.0.10.</span> <span class="toc-text">104. Maximum Depth of Binary Tree</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tree%E2%80%99s-height-VS-tree%E2%80%99s-depth"><span class="toc-number">2.1.</span> <span class="toc-text">treeâ€™s height VS. treeâ€™s depth:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#559-Maximum-Depth-of-N-ary-Tree"><span class="toc-number">2.1.1.</span> <span class="toc-text">559. Maximum Depth of N-ary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="toc-number">2.1.2.</span> <span class="toc-text">111. Minimum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-Count-Complete-Tree-Nodes"><span class="toc-number">2.1.3.</span> <span class="toc-text">222. Count Complete Tree Nodes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-Balanced-Binary-Tree"><span class="toc-number">2.1.4.</span> <span class="toc-text">110. Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">2.1.5.</span> <span class="toc-text">é€’å½’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-Binary-Tree-Paths"><span class="toc-number">2.1.6.</span> <span class="toc-text">257. Binary Tree Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404-Sum-of-Left-Leaves"><span class="toc-number">2.1.7.</span> <span class="toc-text">404. Sum of Left Leaves</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-Find-Bottom-Left-Tree-Value"><span class="toc-number">2.1.8.</span> <span class="toc-text">513. Find Bottom Left Tree Value</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112-Path-Sum"><span class="toc-number">2.1.9.</span> <span class="toc-text">112. Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><span class="toc-number">2.1.10.</span> <span class="toc-text">106. Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="toc-number">2.1.11.</span> <span class="toc-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#654-Maximum-Binary-Tree"><span class="toc-number">2.1.12.</span> <span class="toc-text">654. Maximum Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-Merge-Two-Binary-Trees"><span class="toc-number">2.1.13.</span> <span class="toc-text">617. Merge Two Binary Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#700-Search-in-a-Binary-Search-Tree"><span class="toc-number">2.1.14.</span> <span class="toc-text">700. Search in a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-Validate-Binary-Search-Tree"><span class="toc-number">2.1.15.</span> <span class="toc-text">98. Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#530-Minimum-Absolute-Difference-in-BST"><span class="toc-number">2.1.16.</span> <span class="toc-text">530. Minimum Absolute Difference in BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#501-Find-Mode-in-Binary-Search-Tree"><span class="toc-number">2.1.17.</span> <span class="toc-text">501. Find Mode in Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="toc-number">2.1.18.</span> <span class="toc-text">236. Lowest Common Ancestor of a Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-number">2.1.19.</span> <span class="toc-text">235. Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#701-Insert-into-a-Binary-Search-Tree"><span class="toc-number">2.1.20.</span> <span class="toc-text">701. Insert into a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-Delete-Node-in-a-BST"><span class="toc-number">2.1.21.</span> <span class="toc-text">450. Delete Node in a BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#669-Trim-a-Binary-Search-Tree"><span class="toc-number">2.1.22.</span> <span class="toc-text">669. Trim a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree"><span class="toc-number">2.1.23.</span> <span class="toc-text">108. Convert Sorted Array to Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#538-Convert-BST-to-Greater-Tree"><span class="toc-number">2.1.24.</span> <span class="toc-text">538. Convert BST to Greater Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-Flatten-Binary-Tree-to-Linked-List"><span class="toc-number">2.1.25.</span> <span class="toc-text">114. Flatten Binary Tree to Linked List</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/27/Leetcode-2Month/Hash/" title="Hash">Hash</a><time datetime="2024-05-27T04:00:00.000Z" title="Created 2024-05-27 00:00:00">2024-05-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/24/Leetcode-2Month/LinkedList/" title="LinkedList">LinkedList</a><time datetime="2024-05-24T04:00:00.000Z" title="Created 2024-05-24 00:00:00">2024-05-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/22/Leetcode-2Month/Array/" title="Array">Array</a><time datetime="2024-05-22T04:00:00.000Z" title="Created 2024-05-22 00:00:00">2024-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/01/SoftwareDevelopment/html-REVIEW/" title="HTMLreview">HTMLreview</a><time datetime="2024-05-01T04:00:00.000Z" title="Created 2024-05-01 00:00:00">2024-05-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/28/PHP/php/" title="ğŸ’PHPğŸ’">ğŸ’PHPğŸ’</a><time datetime="2024-04-29T01:03:41.425Z" title="Created 2024-04-28 21:03:41">2024-04-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Dan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
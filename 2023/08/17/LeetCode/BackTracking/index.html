<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>BackTracking | Dan's Blog</title><meta name="author" content="Dan"><meta name="copyright" content="Dan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Back Tracking🌼在二叉树系列中，我们已经不止一次，提到了回溯，例如二叉树：以为使用了递归，其实还隐藏着回溯。 回溯是递归的副产品，只要有递归就会有回溯。 回溯法解决的问题回溯法，一般可以解决如下几种问题：  组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，">
<meta property="og:type" content="article">
<meta property="og:title" content="BackTracking">
<meta property="og:url" content="https://danlovpotato.github.io/2023/08/17/LeetCode/BackTracking/index.html">
<meta property="og:site_name" content="Dan&#39;s Blog">
<meta property="og:description" content="Back Tracking🌼在二叉树系列中，我们已经不止一次，提到了回溯，例如二叉树：以为使用了递归，其实还隐藏着回溯。 回溯是递归的副产品，只要有递归就会有回溯。 回溯法解决的问题回溯法，一般可以解决如下几种问题：  组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png">
<meta property="article:published_time" content="2023-08-17T04:00:00.000Z">
<meta property="article:modified_time" content="2024-01-29T21:25:21.354Z">
<meta property="article:author" content="Dan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png"><link rel="shortcut icon" href="https://cdn.pixabay.com/photo/2016/03/31/19/26/cherry-blossom-1295009_1280.png"><link rel="canonical" href="https://danlovpotato.github.io/2023/08/17/LeetCode/BackTracking/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BackTracking',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-29 16:25:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> Messageboard</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.shopify.com/s/files/1/1622/4127/files/072020_postcards_purple_pink_1024x1024.jpg?v=1595358295')"><nav id="nav"><span id="blog-info"><a href="/" title="Dan's Blog"><span class="site-name">Dan's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> Messageboard</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BackTracking</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-17T04:00:00.000Z" title="Created 2023-08-17 00:00:00">2023-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-01-29T21:25:21.354Z" title="Updated 2024-01-29 16:25:21">2024-01-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BackTracking"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Back-Tracking🌼"><a href="#Back-Tracking🌼" class="headerlink" title="Back Tracking🌼"></a>Back Tracking🌼</h1><p>在二叉树系列中，我们已经不止一次，提到了回溯，例如<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html">二叉树：以为使用了递归，其实还隐藏着回溯</a>。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<h3 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h3><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h3 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<p>这里给出Carl总结的回溯算法模板。</p>
<p>在讲<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归</a>中我们说了递归三部曲，这里我再给大家列出回溯三部曲。</p>
<ul>
<li>回溯函数模板返回值以及参数</li>
</ul>
<p>在回溯算法中，我的习惯是函数起名字为backtracking</p>
<p>回溯算法中函数返回值一般为void。</p>
<p>再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p>
<p>但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。</p>
<p>回溯函数伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数)</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯函数终止条件</li>
</ul>
<p>既然是树形结构，那么我们在讲解<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html">二叉树的递归</a>的时候，就知道遍历树形结构一定要有终止条件。</p>
<p>所以回溯也有要终止条件。</p>
<p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p>
<p>所以回溯函数终止条件伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯搜索的遍历过程</li>
</ul>
<p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
<p>如图：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/7f6cf608866ba0994390df40f15f870691429cab9d6a9872cd0ce572f012ae39/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303133303137333633313137342e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/7f6cf608866ba0994390df40f15f870691429cab9d6a9872cd0ce572f012ae39/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303231303133303137333633313137342e706e67" alt="回溯算法理论基础"></a></p>
<p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p>
<p>回溯函数遍历过程伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); // 递归</span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p>
<p>backtracking这里自己调用自己，实现递归。</p>
<p>大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p>
<p>如果从来没有学过回溯算法的录友们，看到这里会有点懵，后面开始讲解具体题目的时候就会好一些了，已经做过回溯法题目的录友，看到这里应该会感同身受了。</p>
<p>Generally, every <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">constraint satisfaction problem</a> which has clear and well-defined constraints on any objective solution, that incrementally builds candidate to the solution and abandons a candidate (“backtracks”) as soon as it determines that the candidate cannot possibly be completed to a valid solution, can be solved by Backtracking. However, most of the problems that are discussed, can be solved using other known algorithms like <em>Dynamic Programming</em> or <em>Greedy Algorithms</em> in logarithmic, linear, linear-logarithmic time complexity in order of input size, and therefore, outshine the backtracking algorithm in every respect (since backtracking algorithms are generally exponential in both time and space). However, a few problems still remain, that only have backtracking algorithms to solve them until now. </p>
<h3 id="linkedList-VS-ArrayList"><a href="#linkedList-VS-ArrayList" class="headerlink" title="linkedList VS. ArrayList"></a>linkedList VS. ArrayList</h3><p><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/arraylist-vs-linkedlist-java/">https://www.geeksforgeeks.org/arraylist-vs-linkedlist-java/</a></p>
<p>ArrayList provides constant time for search operation, so it is better to use ArrayList if searching is more frequent operation than add and remove operation. </p>
<p>The LinkedList provides constant time for add and remove operations. So it is better to use LinkedList for manipulation.</p>
<p><strong>LinkedList:</strong></p>
<ol>
<li>Adding Elements:<ul>
<li><code>addFirst(element)</code>: Adds an element to the beginning of the list.</li>
<li><code>addLast(element)</code>: Adds an element to the end of the list.</li>
<li><code>add(index, element)</code>: Adds an element at the specified index.</li>
</ul>
</li>
<li>Removing Elements:<ul>
<li><code>removeFirst()</code>: Removes and returns the first element.</li>
<li><code>removeLast()</code>: Removes and returns the last element.</li>
<li><code>remove(index)</code>: Removes the element at the specified index.</li>
</ul>
</li>
<li>Accessing Elements:<ul>
<li><code>get(index)</code>: Retrieves the element at the specified index.</li>
<li>linkedList.set(i, newValue);</li>
</ul>
</li>
<li>Iterating:<ul>
<li>Iterating through elements using an iterator or enhanced for loop.</li>
</ul>
</li>
<li>Size:<ul>
<li><code>size()</code>: Returns the number of elements in the list.</li>
</ul>
</li>
</ol>
<p><strong>ArrayList:</strong></p>
<ol>
<li>Adding Elements:<ul>
<li><code>add(element)</code>: Adds an element to the end of the list.</li>
<li><code>add(index, element)</code>: Adds an element at the specified index.</li>
</ul>
</li>
<li>Removing Elements:<ul>
<li><code>remove(index)</code>: Removes the element at the specified index.</li>
<li><code>removeRange(fromIndex, toIndex)</code>: Removes elements within the specified range.</li>
</ul>
</li>
<li>Accessing Elements:<ul>
<li><code>get(index)</code>: Retrieves the element at the specified index.</li>
<li><code>set(index, element)</code>: Replaces the element at the specified index.</li>
</ul>
</li>
<li>Iterating:<ul>
<li>Iterating through elements using an iterator or enhanced for loop.</li>
</ul>
</li>
<li>Size:<ul>
<li><code>size()</code>: Returns the number of elements in the list.</li>
</ul>
</li>
</ol>
<p><strong>ArrayList Specific:</strong></p>
<ol>
<li>Dynamic Sizing:<ul>
<li>The underlying array dynamically grows as elements are added, reducing the need for manual resizing.</li>
</ul>
</li>
<li>Random Access:<ul>
<li>Provides fast O(1) random access to elements by index.</li>
</ul>
</li>
<li>Insertion&#x2F;Deletion Trade-Off:<ul>
<li>Insertions and deletions at the beginning&#x2F;middle of the list are slower (O(n)) due to shifting elements.</li>
</ul>
</li>
</ol>
<p><strong>LinkedList Specific:</strong></p>
<ol>
<li>Insertion&#x2F;Deletion:<ul>
<li>Offers fast O(1) insertion and deletion at the beginning and end of the list.</li>
<li>Mid-list insertions&#x2F;deletions are slower (O(n)) due to traversal.</li>
</ul>
</li>
<li>Memory Overhead:<ul>
<li>Uses more memory due to storing both elements and references&#x2F;pointers.</li>
</ul>
</li>
<li>No Random Access:<ul>
<li>Accessing elements by index is slower (O(n)) since traversal is required.</li>
</ul>
</li>
</ol>
<p>Both <code>LinkedList</code> and <code>ArrayList</code> provide similar APIs for common operations like adding, removing, accessing, and iterating through elements. The choice between them depends on your specific use case and the operations you’ll perform most frequently.</p>
<h3 id="77-Combinations-排列问题"><a href="#77-Combinations-排列问题" class="headerlink" title="77. Combinations  排列问题"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations/">77. Combinations</a>  排列问题</h3><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>
<p>You may return the answer in <strong>any order</strong>.</p>
<p><strong>Example :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span><br><span class="line">Explanation: There are 4 choose 2 = 6 total combinations.</span><br><span class="line">Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;  </span><br><span class="line">        seek(n,k,1);</span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     public void seek(int n, int k, int start) &#123;</span><br><span class="line">         if(path.size() == k )&#123;</span><br><span class="line">             res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         for(int i = start; i &lt;= n; i++)&#123;</span><br><span class="line">             path.add(i); //like put in the element 1</span><br><span class="line">             seek(n,k, i+1); // recursive like 从1以后的元素遍历，加进去</span><br><span class="line">             path.removeLast();  // backtrack 比如说加了1，2 进去然后把2退出来，再加3进去成为1，3</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>why res.add(new ArrayList&lt;&gt;(path)); instead of using res.add(path).</p>
<p>你的 <code>path</code> 是一个 <code>LinkedList</code>，用于存储当前正在构建的组合。当你找到一个符合条件的组合时，你想把这个组合加入到 <code>res</code> 中，然后继续寻找其他的组合。</p>
<p>问题在于，<code>LinkedList</code> 是一个可变的数据结构，也就是说，当你向 <code>path</code> 中添加或删除元素时，<code>path</code> 的内容会发生变化。</p>
<p>如果你直接将 <code>path</code> 加入到 <code>res</code> 中，实际上你只是将 <code>path</code> 对象的引用加入到了 <code>res</code> 中，而不是 <code>path</code> 的一个拷贝。这意味着，如果之后你继续修改 <code>path</code>，那么 <code>res</code> 中保存的组合也会随之改变，这样会导致 <code>res</code> 中的结果不正确。</p>
<p>所以，为了避免这个问题，你需要在将 <code>path</code> 加入到 <code>res</code> 中之前，先创建一个 <code>path</code> 的拷贝，然后再将拷贝加入到 <code>res</code> 中。这样，即使之后 <code>path</code> 发生变化，<code>res</code> 中保存的组合仍然保持不变。</p>
<p>when you add <code>path</code> directly to <code>res</code>, you’re not adding a copy of <code>path</code>, you’re adding a reference to the same <code>LinkedList</code> object. During backtracking, as you remove elements from <code>path</code>, those changes will also reflect in the lists already added to <code>res</code>. This leads to incorrect results because the contents of <code>path</code> are changing during the exploration of different combinations.</p>
<ul>
<li>回溯函数终止条件</li>
</ul>
<p>什么时候到达所谓的叶子节点了呢？</p>
<p>path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。</p>
<p>如图红色部分：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/63f4077f082ba18f134e3e9eeb083409b6729204a6439f7a1cd7dcd281cf57ea/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353430373930372e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/63f4077f082ba18f134e3e9eeb083409b6729204a6439f7a1cd7dcd281cf57ea/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353430373930372e706e67" alt="77.组合3"></a></p>
<p>此时用result二维数组，把path保存起来，并终止本层递归。</p>
<p>所以终止条件代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (path.size() == k) &#123;</span><br><span class="line">    result.push_back(path);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>单层搜索的过程</li>
</ul>
<p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/f8b8bec488f2b60d3c81d96391f3c6adce3dba237005a3e9f0a512a0d18aac11/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/f8b8bec488f2b60d3c81d96391f3c6adce3dba237005a3e9f0a512a0d18aac11/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333139353234323839392e706e67" alt="77.组合1"></a></p>
<p>如此我们才遍历完图中的这棵树。</p>
<p>for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = startIndex; i &lt;= n; i++) &#123; // 控制树的横向遍历</span><br><span class="line">    path.push_back(i); // 处理节点</span><br><span class="line">    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span><br><span class="line">    path.pop_back(); // 回溯，撤销处理的节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。</p>
<p>backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p>
<h3 id="77-Combinations-减枝pruning"><a href="#77-Combinations-减枝pruning" class="headerlink" title="77. Combinations  减枝pruning"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combinations/">77. Combinations</a>  减枝pruning</h3><p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.md</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    private void combineHelper(int n, int k, int startIndex)&#123;</span><br><span class="line">        //终止条件</span><br><span class="line">        if (path.size() == k)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++)&#123;  //!!!!!!!</span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + 1);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">//my version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res =  new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        if(n == 0 || k == 0) return res;</span><br><span class="line">        List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">        backtrack(n, k, 1, temp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void backtrack(int n, int  k, int start, List&lt;Integer&gt; temp )&#123;</span><br><span class="line">        if(temp.size() == k)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt;= n ; i++)&#123;</span><br><span class="line">             if(k - temp.size() &lt;= n - i + 1 )&#123;</span><br><span class="line">                temp.add(i);</span><br><span class="line">       </span><br><span class="line">                 backtrack(n, k, i + 1, temp);</span><br><span class="line"> </span><br><span class="line">                temp.removeLast( );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>path.size() ： 已经找的个数<br>k-path.size() ：还需找的个数<br>【x, n】的数组长度起码应该是k-path.size()才有继续搜索的可能， 那么就有 n-x+1 &#x3D; k-path.size()  ， 解方程得 x &#x3D; n+1 - (k-path.size()), 而且这个x是可以作为起点往下搜的 也就是for(i &#x3D; s; i&lt;&#x3D;x; i++) 这里的x是可以取到的</p>
<h3 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-iii/">216. Combination Sum III</a></h3><p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>
<ul>
<li>Only numbers <code>1</code> through <code>9</code> are used.</li>
<li>Each number is used <strong>at most once</strong>.</li>
</ul>
<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<p><strong>Example :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        seek(k, n , 1);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int k, int n, int start)&#123;</span><br><span class="line">        if(path.size() == k)&#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for(int element: path)&#123;</span><br><span class="line">                sum += element;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum == n)&#123;</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = start; i &lt;= 9; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            seek(k,n, i+1);  // notice it&#x27;s i+1 here not start +1</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// pruning!!! better version</span><br><span class="line"></span><br><span class="line">private void backTracking(int targetSum, int k, int startIndex, int sum) &#123;</span><br><span class="line">		// 减枝</span><br><span class="line">		if (sum &gt; targetSum) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (path.size() == k) &#123;</span><br><span class="line">			if (sum == targetSum) result.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 减枝 9 - (k - path.size()) + 1</span><br><span class="line">		for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) &#123;</span><br><span class="line">			path.add(i);</span><br><span class="line">			sum += i;</span><br><span class="line">			backTracking(targetSum, k, i + 1, sum);</span><br><span class="line">			//回溯</span><br><span class="line">			path.removeLast();</span><br><span class="line">			//回溯</span><br><span class="line">			sum -= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></h3><p>Medium</p>
<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; res = new ArrayList&lt;String&gt;();</span><br><span class="line">    public StringBuilder temp = new StringBuilder();</span><br><span class="line">    public String[] dict = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;; //!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if( digits.isEmpty()) return res;</span><br><span class="line">        /*</span><br><span class="line">        notice:</span><br><span class="line">        	not return null</span><br><span class="line">        	not digits == null</span><br><span class="line">        */</span><br><span class="line">        seek(digits, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(String digits, int num)&#123; // num stands for which digit we are processing 遍历到哪一个数字了</span><br><span class="line">        </span><br><span class="line">        int len = digits.length();</span><br><span class="line">        if(len == num)&#123;</span><br><span class="line">        // you can also say-&gt; if(len == temp.length())&#123;</span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int digit = digits.charAt(num) - &#x27;0&#x27;;</span><br><span class="line">        String str = dict[digit]; // current digit&#x27;s letters </span><br><span class="line">        for(int i = 0; i &lt; str.length(); i++)&#123;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            seek(digits, num+1); // append next num&#x27;s letter</span><br><span class="line">            temp.deleteCharAt(temp.length() - 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//second try:(chaotic) use string array could make code look better</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp = new StringBuilder();</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if(digits.equals(&quot;&quot;))&#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;  </span><br><span class="line">        int[] digit = new int[digits.length()];</span><br><span class="line">        for(int i = 0 ; i &lt; digits.length(); i++)&#123;</span><br><span class="line">            digit[i] = digits.charAt(i) - &#x27;0&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        com(digit, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void com(int[] digit, int start)&#123;</span><br><span class="line">        if(temp.length() == digit.length)&#123;</span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = start; i &lt; digit.length; i++)&#123;</span><br><span class="line">            int order = 3;</span><br><span class="line">            if(digit[i] == 7 || digit[i] == 9) order = 4;</span><br><span class="line"></span><br><span class="line">            int base;</span><br><span class="line">                if(digit[i] &lt; 8)&#123;</span><br><span class="line">                    base =  (digit[i] - 2)*3;</span><br><span class="line">                &#125;else if( digit[i] == 8)&#123;</span><br><span class="line">                    base = 19;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    base = 22;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            for(int j = 0 ; j &lt; order; j++)&#123;</span><br><span class="line">                </span><br><span class="line">               temp.append((char)(&#x27;a&#x27; + j + base ));</span><br><span class="line">               com(digit, i + 1);</span><br><span class="line">               temp.deleteCharAt(temp.length() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一些写法，是把回溯的过程放在递归函数里了，例如如下代码，我可以写成这样：（注意注释中不一样的地方）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 版本二</span><br><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">        const string letterMap[10] = &#123;</span><br><span class="line">            &quot;&quot;, // 0</span><br><span class="line">            &quot;&quot;, // 1</span><br><span class="line">            &quot;abc&quot;, // 2</span><br><span class="line">            &quot;def&quot;, // 3</span><br><span class="line">            &quot;ghi&quot;, // 4</span><br><span class="line">            &quot;jkl&quot;, // 5</span><br><span class="line">            &quot;mno&quot;, // 6</span><br><span class="line">            &quot;pqrs&quot;, // 7</span><br><span class="line">            &quot;tuv&quot;, // 8</span><br><span class="line">            &quot;wxyz&quot;, // 9</span><br><span class="line">        &#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    void getCombinations(const string&amp; digits, int index, const string&amp; s) &#123; // 注意参数的不同</span><br><span class="line">        if (index == digits.size()) &#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int digit = digits[index] - &#x27;0&#x27;;</span><br><span class="line">        string letters = letterMap[digit];</span><br><span class="line">        for (int i = 0; i &lt; letters.size(); i++) &#123;</span><br><span class="line">            getCombinations(digits, index + 1, s + letters[i]);  // 注意这里的不同</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; letterCombinations(string digits) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        if (digits.size() == 0) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        getCombinations(digits, 0, &quot;&quot;);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/">39. Combination Sum</a></h3><p>Medium</p>
<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>
<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the </p>
<p>frequency</p>
<p> of at least one of the chosen numbers is different.</p>
<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7</span><br><span class="line">Output: [[2,2,3],[7]]</span><br><span class="line">Explanation:</span><br><span class="line">2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.</span><br><span class="line">7 is a candidate, and 7 = 7.</span><br><span class="line">These are the only two combinations.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8</span><br><span class="line">Output: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res =  new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        seek(candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if(sum &gt; target)</span><br><span class="line">        return;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;  //!!!! 我用break 也通过了，但是这里我觉得用return更好想   </span><br><span class="line">            //这里不可以用continue，如果是continue的话层序遍历还会继续</span><br><span class="line">            //这里用return 不用 continue,终止的是这个深度上的检索</span><br><span class="line">        &#125; </span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            temp.add(candidates[i]);  //notice here is i not index</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            seek(candidates, target, i, sum);</span><br><span class="line">            temp.remove(temp.size() - 1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pruning:</span><br><span class="line">// 剪枝优化</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); // 先进行排序</span><br><span class="line">        backtracking(res, new ArrayList&lt;&gt;(), candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] candidates, int target, int sum, int idx) &#123;</span><br><span class="line">        // 找到了数字和为 target 的组合</span><br><span class="line">        if (sum == target) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            // 如果 sum + candidates[i] &gt; target 就终止遍历</span><br><span class="line">            if (sum + candidates[i] &gt; target) break;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(res, path, candidates, target, sum + candidates[i], i);</span><br><span class="line">            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//second try:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        cal(candidates, target, 0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void cal(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if(index &gt; candidates.length || sum &gt; target)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        for(int i = index ; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            if(sum == target)&#123;</span><br><span class="line">                res.add(new LinkedList&lt;&gt;(temp));</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                temp.add(candidates[i]);</span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                cal(candidates, target, i, sum);</span><br><span class="line">                sum-= candidates[i];</span><br><span class="line">                temp.removeLast();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-ii/">40. Combination Sum II</a></h3><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p><strong>这道题强调了candidates里面有重复的元素，我们需要去重</strong></p>
<p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        seek(candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if(sum &gt; target) return;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            if(i &gt;  index &amp;&amp; candidates[i-1] == candidates[i]) !!!!!!!!!!!! //树层逻辑， 横向检查</span><br><span class="line">            continue;</span><br><span class="line">            temp.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            seek(candidates, target, i + 1, sum);</span><br><span class="line">            temp.remove(temp.size() - 1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//second try:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        cal(candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void cal(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if( sum &gt; target) return;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">                res.add(new LinkedList&lt;&gt;(temp));</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            if ( i &gt; index &amp;&amp; candidates[i] == candidates[i - 1] ) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      or: while(i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) i++;</span><br><span class="line">      wrong: while(i + 1 &lt; candidates.length &amp;&amp; candidates[i] == candidates[i+1] ) i++; //要和前面比不能和后面比。</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">            temp.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            cal(candidates, target, i + 1, sum);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            //while(i + 1 &lt; candidates.length &amp;&amp; candidates[i] == candidates[i+1] ) i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树层（横向）上不能重复，</p>
<p>树枝（纵向）上可以重复。</p>
<p> if(i &gt;  index &amp;&amp; candidates[i-1] &#x3D;&#x3D; candidates[i]) </p>
<p>这里如果想不明白的话，其实这句话等同于</p>
<p> if( i !&#x3D;  index &amp;&amp; candidates[i-1] &#x3D;&#x3D; candidates[i]) continue; 从第二个开始去重</p>
<p>—-&gt; 就是重复出现的只保留最左侧的一支树枝，其他的就去重<br>比如说 【1， 1， 1， 1， 2】 求和是3， 只保留最左侧的 1-&gt;1-&gt;1这样子一支树</p>
<h3 id="131-Palindrome-Partitioning分割问题"><a href="#131-Palindrome-Partitioning分割问题" class="headerlink" title="131. Palindrome Partitioning分割问题"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-partitioning/">131. Palindrome Partitioning</a>分割问题</h3><p>Medium</p>
<p>Given a string <code>s</code>, partition <code>s</code> such that every </p>
<p>substring</p>
<p> of the partition is a <strong>palindrome</strong>. Return <em>all possible palindrome partitioning of</em> <code>s</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;aab&quot;</span><br><span class="line">Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;String&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        seek(s,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean pal(String s, int left, int right)&#123;</span><br><span class="line">        for(int i = left; i &lt; right; i ++)&#123;</span><br><span class="line">            if(s.charAt(i) == s.charAt(right))&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(String s, int index)&#123;</span><br><span class="line">        if(index &gt;= s.length())&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; s.length(); i++)&#123; </span><br><span class="line">        //i++是树的横向，左边划分的杠在动，划的线数量不变,因为++之前都removeLast了</span><br><span class="line">            if(pal(s,index, i))&#123;</span><br><span class="line">                String str = s.substring(index, i+1);</span><br><span class="line">                // for substring, left is closed but the right is open</span><br><span class="line">                path.add(str);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue; //注意这里是continue不是return;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">                </span><br><span class="line">                //如果这里是return, 相当于层序遍历直接就终止了。</span><br><span class="line">            &#125; </span><br><span class="line">            seek(s, i+1); //树的纵向, i+1是右边的划杠在动，划的线增多</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对比39：</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res =  new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        seek(candidates, target, 0, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void seek(int[] candidates, int target, int index, int sum)&#123;</span><br><span class="line">        if(sum &gt; target)</span><br><span class="line">        return;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;  //!!!! 我用break 也通过了，但是这里我觉得用return更好想   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">            //这里不可以用continue，如果是continue的话层序遍历还会继续</span><br><span class="line">            //这里用return 不用 continue,终止的是这个深度上的检索</span><br><span class="line">        &#125; </span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            temp.add(candidates[i]);  //notice here is i not index</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            seek(candidates, target, i, sum);</span><br><span class="line">            temp.remove(temp.size() - 1);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/907a2a94961ed3e0c1b67469e6f51163ce7a044af822069f0983ceccf4c168a2/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f3133312e2545352538382538362545352538392542322545352539422539452545362539362538372545342542382542322e6a7067" alt="131.分割回文串"></p>
<p>视频讲解看93的，讲的更清楚：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1XP4y1U73i/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1XP4y1U73i/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p>
<h3 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/restore-ip-addresses/">93. Restore IP Addresses</a></h3><p>Medium</p>
<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>
<ul>
<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>
</ul>
<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into</em> <code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        backtrack(s,0,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(String s, int index, int point)&#123; // index is slash</span><br><span class="line">        if(point == 3)&#123;</span><br><span class="line">            //check the last part, the fourth part</span><br><span class="line">            if(isValid(s, index, s.length() - 1))&#123;//left close right close</span><br><span class="line">                res.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; s.length(); i++)&#123;// i++是树的横向，左边划分的杠在动，划的线数量不变,因为++之前都removeLast了</span><br><span class="line">            if(isValid(s, index, i))&#123;</span><br><span class="line">                s = s.substring(0, i+1)+&quot;.&quot;+s.substring(i+1);</span><br><span class="line">                point++;</span><br><span class="line">                backtrack(s, i + 2, point); //vertical</span><br><span class="line">                point--;</span><br><span class="line">                s = s.substring(0, i+1) + s.substring(i+2);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private Boolean isValid(String s, int start, int end) &#123;</span><br><span class="line">        if (start &gt; end) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.charAt(start) == &#x27;0&#x27; &amp;&amp; start != end) &#123; // 0开头的数字不合法</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            if (s.charAt(i) &gt; &#x27;9&#x27; || s.charAt(i) &lt; &#x27;0&#x27;) &#123; // 遇到⾮数字字符不合法</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * 10 + (s.charAt(i) - &#x27;0&#x27;);</span><br><span class="line">            if (num &gt; 255) &#123; // 如果⼤于255了不合法</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//second try</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    //StringBuilder temp = new StringBuilder();</span><br><span class="line">    int len;</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        len= s.length();</span><br><span class="line">        sort(s, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sort(String s, int index)&#123;</span><br><span class="line">        if(s.length() == len + 3)&#123;</span><br><span class="line">            if(check(s, index, s.length() - 1))</span><br><span class="line">                res.add(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if( check(s, index, i))&#123;</span><br><span class="line">                s = s.substring(0, i+1) + &quot;.&quot; + s.substring(i+1);</span><br><span class="line">                sort(s, i + 2);</span><br><span class="line">                s = s.substring(0, i+1) + s.substring(i + 2);</span><br><span class="line"></span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // public boolean check(String s , int start, int end)&#123;</span><br><span class="line">    //      if (start &gt; end) &#123;</span><br><span class="line">    //         return false;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     if(s.charAt(start) == &#x27;0&#x27; &amp;&amp; start != end) return false;</span><br><span class="line">    //     //if(s!=&quot;&quot; &amp;&amp; Integer.parseInt(s.substring(start,end)) &gt; 255) return false;</span><br><span class="line"></span><br><span class="line">    //     String substring = s.substring(start, end);</span><br><span class="line">    </span><br><span class="line">    //     if (!substring.isEmpty()) &#123;</span><br><span class="line">    //     int intValue = Integer.parseInt(substring);</span><br><span class="line">    //     if (intValue &gt; 255)  return false;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     for(int i = start ; i &lt; end; i++)&#123;</span><br><span class="line">    //         if(s.charAt(i) &gt; &#x27;9&#x27; || s.charAt(i) &lt; &#x27;0&#x27;) </span><br><span class="line">    //             return false;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return true;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">         private Boolean check(String s, int start, int end) &#123;</span><br><span class="line">        if (start &gt; end) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s.charAt(start) == &#x27;0&#x27; &amp;&amp; start != end) &#123; // 0开头的数字不合法</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int num = 0;</span><br><span class="line">        for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            if (s.charAt(i) &gt; &#x27;9&#x27; || s.charAt(i) &lt; &#x27;0&#x27;) &#123; // 遇到⾮数字字符不合法</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * 10 + (s.charAt(i) - &#x27;0&#x27;);</span><br><span class="line">            if (num &gt; 255) &#123; // 如果⼤于255了不合法</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>s.substring(i + 1)</code> expression suggests that you’re extracting a substring from the string <code>s</code>, starting from the index <code>i + 1</code> and continuing until the end of the string.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/875e015ae28ea369ec6b67e63581ee5d18fd717dbe5bbfd4404ea713427d78e5/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132333230333733353933332d32303233303331303133323331343130392e706e67" alt="93.复原IP地址"></p>
<h3 id="78-Subsets-求子集问题"><a href="#78-Subsets-求子集问题" class="headerlink" title="78. Subsets 求子集问题"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/">78. Subsets</a> 求子集问题</h3><p>Medium</p>
<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> </p>
<p><em>subsets</em></p>
<p> <em>(the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(temp)); // 加上空子集</span><br><span class="line">        backtrack(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        </span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            //res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            backtrack(nums, i + 1);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></span></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/a6dcda91c3ef3c4a6ffb3d096d791c50f9bf389b645e337df73b9785e05a07c9/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f37382e2545352541442539302545392539422538362e706e67" alt="78.子集"></p>
<p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合</strong>。</p>
<h3 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets-ii/">90. Subsets II</a></h3><p>Medium</p>
<p>Companies</p>
<p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> </p>
<p><em>subsets</em></p>
<p> <em>(the power set)</em>.</p>
<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>
<p><strong>Example :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,2]</span><br><span class="line">Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTrack(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTrack(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(i &gt; index &amp;&amp; nums[i] == nums[i-1])&#123;</span><br><span class="line">               continue;  //最好把这种需要退出的情况写在前面</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">                backTrack(nums, i+1);</span><br><span class="line">                temp.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WRONG VERSION:   ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br><span class="line">    public void backTrack(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(i &gt; index &amp;&amp; nums[i] != nums[i-1])&#123;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">                backTrack(nums, i+1);</span><br><span class="line">                temp.removeLast();</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">// second try:</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res.add(new LinkedList&lt;&gt;());</span><br><span class="line">        find(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void find(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if( i &gt; index &amp;&amp; i  &lt; nums.length &amp;&amp; nums[i] == nums[i - 1]) continue;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            res.add(new LinkedList&lt;&gt;(temp));</span><br><span class="line">            //if( i + 1&lt; nums.length &amp;&amp; nums[i] == nums[i + 1]) continue; !!!!!!!!!!!!注意这个放的位置</span><br><span class="line">            find(nums, i+1);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res.add(new LinkedList&lt;&gt;());</span><br><span class="line">        find(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void find(int[] nums, int index)&#123;</span><br><span class="line">        if(index &gt;= nums.length) return;</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">            // if ( i &gt; start &amp;&amp; nums[i - 1] == nums[i] ) &#123;</span><br><span class="line">            //     continue;</span><br><span class="line">            // &#125;</span><br><span class="line">            while (i &gt; index &amp;&amp; i &lt; nums.length &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &gt;= nums.length) </span><br><span class="line">            //i = nums.length -1 ; 这样的话最后一个元素会多算一次</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            res.add(new LinkedList&lt;&gt;(temp));</span><br><span class="line">            </span><br><span class="line">            //if( i + 1&lt; nums.length &amp;&amp; nums[i] == nums[i + 1]) continue;</span><br><span class="line">            find(nums, i+1);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9bf54f50895f39143eb86212493192fd2785477ce470dd02f68b3eac1d524554/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343139353431313937372e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/9bf54f50895f39143eb86212493192fd2785477ce470dd02f68b3eac1d524554/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343139353431313937372e706e67" alt="90.子集II"></a></p>
<p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p>
<h3 id="491-Non-decreasing-Subsequences"><a href="#491-Non-decreasing-Subsequences" class="headerlink" title="491. Non-decreasing Subsequences"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/non-decreasing-subsequences/">491. Non-decreasing Subsequences</a></h3><p>Medium</p>
<p>Given an integer array <code>nums</code>, return <em>all the different possible non-decreasing subsequences of the given array with at least two elements</em>. You may return the answer in <strong>any order</strong>.</p>
<p><strong>Example :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,6,7,7]</span><br><span class="line">Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        backtrack(nums, 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums, int index)&#123;</span><br><span class="line">        // if(nums.length == index)&#123;</span><br><span class="line">        //     return;</span><br><span class="line">        // &#125;  if you add this, the result is wrong, should put this after if(temp.size() &gt; 1) statement</span><br><span class="line">        if(temp.size() &gt; 1)&#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i = index; i &lt; nums.length; i++)&#123;</span><br><span class="line">           if(!temp.isEmpty() &amp;&amp; nums[i] &lt; temp.getLast())&#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           if(map.getOrDefault(nums[i], 0) == 1)&#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(nums[i], 1);</span><br><span class="line">           temp.add(nums[i]);</span><br><span class="line">           backtrack(nums, i+1);</span><br><span class="line">           temp.removeLast();</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EG4y1h78v/?vd_source=7cf01a4cc731f5d6335bce33c114b60c">https://www.bilibili.com/video/BV1EG4y1h78v/?vd_source=7cf01a4cc731f5d6335bce33c114b60c</a></p>
<p>非常非常详细！</p>
<h3 id="46-Permutations-排列问题"><a href="#46-Permutations-排列问题" class="headerlink" title="46. Permutations 排列问题"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">46. Permutations</a> 排列问题</h3><p>Medium</p>
<p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        if (nums.length == 0) return res;</span><br><span class="line">        used = new boolean[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums)&#123;</span><br><span class="line">        if(nums.length == temp.size()) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">       // cant use hash map here   HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt;nums.length; i++)&#123;</span><br><span class="line">            if(used[i]) continue;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            temp.removeLast();</span><br><span class="line">            used[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/4d9e48eecd46a5e924bf90eaf6c6221ab99465443c6d043a60ec3080f44e3458/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313230393137343232353134352e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/4d9e48eecd46a5e924bf90eaf6c6221ab99465443c6d043a60ec3080f44e3458/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313230393137343232353134352e706e67" alt="46.全排列"></a></p>
<p>这里和<a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合问题</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.切割问题</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html">78.子集问题</a>最大的不同就是for循环里不用startIndex了。</p>
<p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。</p>
<p><strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p>
<p><strong><span style="color: red">！！！！！！！！！！！！ used数组是用来标记图里面，箭头上写的取的几。！！！！！！！！！</span></strong></p>
<h3 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">47. Permutations II</a></h3><p>Medium</p>
<p>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    public boolean[] used;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = new boolean[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(int[] nums)&#123;</span><br><span class="line">        if(nums.length == temp.size())&#123;</span><br><span class="line">            res.add(new ArrayList(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i - 1] == false) continue; //!!!!!notice  used[i - 1] == false !!!</span><br><span class="line">            if(used[i] == true) continue;</span><br><span class="line">            used[i] = true;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            used[i] = false;</span><br><span class="line">            temp.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// use linkedlist to see if it contains duplicate elements</span><br><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp = new LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">      </span><br><span class="line">        int[] used = new int[nums.length];</span><br><span class="line">        find(nums, used);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void find(int[] nums, int[] used)&#123;</span><br><span class="line">        if(temp.size() == nums.length)&#123;</span><br><span class="line">            if(!res.contains(temp))</span><br><span class="line">            res.add(new LinkedList&lt;&gt;(temp));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0 ; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if( used[i] == 1) continue;</span><br><span class="line">                temp.add(nums[i]);</span><br><span class="line">                used[i] = 1;</span><br><span class="line">                find(nums, used);</span><br><span class="line">                temp.remove(temp.size() - 1);</span><br><span class="line">                used[i] = 0;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程</p>
<p>中, 我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p>
<p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html">46.全排列</a>中已经详细讲解了排列问题的写法，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">40.组合总和II</a> 、<a target="_blank" rel="noopener" href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html">90.子集II</a>中详细讲解了去重的写法</p>
<h5 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h5><p>这道题其实还是用了我们之前讲过的去重思路，但有意思的是，去重的代码中，这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>和这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == true) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>都是可以的，这也是很多同学做这道题目困惑的地方，知道<code>used[i - 1] == false</code>也行而<code>used[i - 1] == true</code>也行，但是就想不明白为啥。</p>
<p>所以我通过举[1,1,1]的例子，把这两个去重的逻辑分别抽象成树形结构，大家可以一目了然：为什么两种写法都可以以及哪一种效率更高！</p>
<p>这里可能大家又有疑惑，既然 <code>used[i - 1] == false</code>也行而<code>used[i - 1] == true</code>也行，那为什么还要写这个条件呢？</p>
<p>直接这样写 不就完事了？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其实并不行，一定要加上 <code>used[i - 1] == false</code>或者<code>used[i - 1] == true</code>，因为 used[i - 1] 要一直是 true 或者一直是false 才可以，而不是 一会是true 一会又是false。 所以这个条件要写上。</p>
<p> okay if you cant understand here then just check the website</p>
<p>这么说是不是有点抽象？</p>
<p>来来来，我就用输入: [1,1,1] 来举一个例子。</p>
<p>树层上去重(used[i - 1] &#x3D;&#x3D; false)，的树形结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/11a65348ce2e2ede3ccc8099e9fff1737371ea4ee41e834ad75195d9d7bb01e6/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313430363139322e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/11a65348ce2e2ede3ccc8099e9fff1737371ea4ee41e834ad75195d9d7bb01e6/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313430363139322e706e67" alt="47.全排列II2"></a></p>
<p>树枝上去重（used[i - 1] &#x3D;&#x3D; true）的树型结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e2a476cb656d7c8667bdceda0c979e745da3e9767693993bf9a5240e49989578/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313433313537312e706e67"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/e2a476cb656d7c8667bdceda0c979e745da3e9767693993bf9a5240e49989578/68747470733a2f2f636f64652d7468696e6b696e672d313235333835353039332e66696c652e6d7971636c6f75642e636f6d2f706963732f32303230313132343230313433313537312e706e67" alt="47.全排列II3"></a></p>
<p>大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p>
<h3 id="去重（一些错误写法的提醒）"><a href="#去重（一些错误写法的提醒）" class="headerlink" title="去重（一些错误写法的提醒）"></a>去重（一些错误写法的提醒）</h3><p><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.md">https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.md</a></p>
<h3 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/n-queens/">51. N-Queens</a></h3><p>Hard</p>
<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>
<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>
<p><strong>Example 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: [[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        char[][] board = new char[n][n];</span><br><span class="line">        for (char[] c : board) &#123;</span><br><span class="line">            Arrays.fill(c, &#x27;.&#x27;);    !!!!!!!</span><br><span class="line">        &#125;</span><br><span class="line">        backtrack(board, n , 0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backtrack(char[][] board,int n, int row)&#123;</span><br><span class="line">        if(row == n)&#123; //走到叶子节点，那一定是合法的</span><br><span class="line">            res.add(Array2List(board));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i&lt;n; i++)&#123;</span><br><span class="line">            if(check(board,n,row,i))&#123;</span><br><span class="line">                board[row][i] = &#x27;Q&#x27;;</span><br><span class="line">                backtrack(board, n, row + 1);</span><br><span class="line">                board[row][i] = &#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List Array2List(char[][] chessboard) &#123;!!!!!</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (char[] c : chessboard) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));  !!!!!</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean check(char[][] chessboard, int n, int row, int col) &#123;</span><br><span class="line">        // 检查列</span><br><span class="line">        for (int i=0; i&lt;row; ++i) &#123; // 相当于剪枝</span><br><span class="line">            if (chessboard[i][col] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查45度对角线</span><br><span class="line">        for (int i=row, j=col; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) &#123;!!!!!!</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 检查135度对角线</span><br><span class="line">        for (int i=row, j=col; i&gt;=0 &amp;&amp; j&lt;=n-1; i--, j++) &#123;</span><br><span class="line">            if (chessboard[i][j] == &#x27;Q&#x27;) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">wrong version:</span><br><span class="line"></span><br><span class="line">    public List Array2List(char[][] chessboard) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (char[] c : chessboard) &#123;</span><br><span class="line"></span><br><span class="line">            for(char cc :  c)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(Character.toString(cc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>Output</p>
<p>[[“.”,”Q”,”.”,”.”,”.”,”.”,”.”,”Q”,”Q”,”.”,”.”,”.”,”.”,”.”,”Q”,”.”],[“.”,”.”,”Q”,”.”,”Q”,”.”,”.”,”.”,”.”,”.”,”.”,”Q”,”.”,”Q”,”.”,”.”]]</p>
<p>Expected</p>
<p>[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</p>
<ol>
<li><strong>Using <code>Arrays.fill()</code></strong>:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codefor (char[] c : board) &#123;</span><br><span class="line">    Arrays.fill(c, &#x27;.&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this approach, you are using the <code>Arrays.fill()</code> method to fill each row of the 2D array <code>board</code> with the character <code>&#39;.&#39;</code>. This method directly modifies the array elements in place, replacing the characters within each subarray with <code>&#39;.&#39;</code>.</p>
<ol>
<li><strong>Using nested loops</strong>:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codefor (char[] c : board) &#123;</span><br><span class="line">    for (char cc : c) &#123;</span><br><span class="line">        cc = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this approach, you are using nested loops to iterate through each row (<code>char[] c</code>) and then iterating through each character (<code>char cc</code>) within that row. However, the assignment <code>cc = &#39;.&#39;;</code> only updates the value of the loop variable <code>cc</code>, which does not have any effect on the actual characters stored in the <code>board</code> array. This means that the characters within the <code>board</code> array remain unchanged.</p>
<p>The key difference is that the first approach (<code>Arrays.fill()</code>) directly modifies the array elements, while the second approach (nested loops) only modifies the loop variables without affecting the array contents.</p>
<p>To achieve the same result as the <code>Arrays.fill()</code> approach, you would need to use the index to update the characters within the <code>board</code> array:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codefor (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">    Arrays.fill(board[i], &#x27;.&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This way, you are directly modifying the characters in the <code>board</code> array using the indices of the rows and columns.</p>
<p>这样也可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    for(int j = 0 ; j &lt; n; j++)&#123;</span><br><span class="line">        board[i][j] = &#x27;.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>[toc]</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://DanLovPotato.github.io">Dan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://danlovpotato.github.io/2023/08/17/LeetCode/BackTracking/">https://danlovpotato.github.io/2023/08/17/LeetCode/BackTracking/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/21/ImageProcess/classNote/" title="Image Process"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Image Process</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/28/LeetCode/tree/" title="Tree"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Tree</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/10/rjhHVtISdz28Tk3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dan</div><div class="author-info__description">Lack the words to compliment myself today.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DanLovPotato"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Back-Tracking%F0%9F%8C%BC"><span class="toc-number">1.</span> <span class="toc-text">Back Tracking🌼</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.1.</span> <span class="toc-text">回溯法解决的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.0.2.</span> <span class="toc-text">回溯法模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.0.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedList-VS-ArrayList"><span class="toc-number">1.0.4.</span> <span class="toc-text">linkedList VS. ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-Combinations-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.5.</span> <span class="toc-text">77. Combinations  排列问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77-Combinations-%E5%87%8F%E6%9E%9Dpruning"><span class="toc-number">1.0.6.</span> <span class="toc-text">77. Combinations  减枝pruning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-Combination-Sum-III"><span class="toc-number">1.0.7.</span> <span class="toc-text">216. Combination Sum III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Letter-Combinations-of-a-Phone-Number"><span class="toc-number">1.0.8.</span> <span class="toc-text">17. Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-Combination-Sum"><span class="toc-number">1.0.9.</span> <span class="toc-text">39. Combination Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-Combination-Sum-II"><span class="toc-number">1.0.10.</span> <span class="toc-text">40. Combination Sum II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131-Palindrome-Partitioning%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.11.</span> <span class="toc-text">131. Palindrome Partitioning分割问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-Restore-IP-Addresses"><span class="toc-number">1.0.12.</span> <span class="toc-text">93. Restore IP Addresses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-Subsets-%E6%B1%82%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.13.</span> <span class="toc-text">78. Subsets 求子集问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-Subsets-II"><span class="toc-number">1.0.14.</span> <span class="toc-text">90. Subsets II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#491-Non-decreasing-Subsequences"><span class="toc-number">1.0.15.</span> <span class="toc-text">491. Non-decreasing Subsequences</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-Permutations-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.16.</span> <span class="toc-text">46. Permutations 排列问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Permutations-II"><span class="toc-number">1.0.17.</span> <span class="toc-text">47. Permutations II</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">1.0.17.0.1.</span> <span class="toc-text">拓展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%EF%BC%88%E4%B8%80%E4%BA%9B%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95%E7%9A%84%E6%8F%90%E9%86%92%EF%BC%89"><span class="toc-number">1.0.18.</span> <span class="toc-text">去重（一些错误写法的提醒）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-N-Queens"><span class="toc-number">1.0.19.</span> <span class="toc-text">51. N-Queens</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/07/GaussianSplatting/code/" title="DOF-GS with Joint Camera Optimization">DOF-GS with Joint Camera Optimization</a><time datetime="2024-06-07T04:00:00.000Z" title="Created 2024-06-07 00:00:00">2024-06-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/06/Leetcode-2Month/tree/" title="Tree">Tree</a><time datetime="2024-06-06T04:00:00.000Z" title="Created 2024-06-06 00:00:00">2024-06-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/Leetcode-2Month/Stack/" title="Stack">Stack</a><time datetime="2024-06-03T04:00:00.000Z" title="Created 2024-06-03 00:00:00">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/Leetcode-2Month/String/" title="String">String</a><time datetime="2024-05-30T04:00:00.000Z" title="Created 2024-05-30 00:00:00">2024-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/27/Leetcode-2Month/Hash/" title="Hash">Hash</a><time datetime="2024-05-27T04:00:00.000Z" title="Created 2024-05-27 00:00:00">2024-05-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Dan</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>